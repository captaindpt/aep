‰¢idÙ@4a970810ae33a49047da25e271f483df30770caa2021bc9ad07e856617c7012a¢tsËAÚöĞHÿ*¨trace_idÙ$45436cc4-61ec-4952-bec5-dbda22caa236­parent_run_idÙ$f86aead6-e79e-496f-a762-b5521540fa83¦run_idÙ$45436cc4-61ec-4952-bec5-dbda22caa236ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚAmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name two ChatModel parameters that help avoid exceeding rate limits. \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\nSome important things to note:\n\n- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can\'t be supported on these.\n- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they\'re not enforced on models in `langchain-community`.\n\nChat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.\n\n## Tool calling\n\nChat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please\nsee the [tool calling](/docs/concepts/tool_calling) guide for more information.\n\nMany of the key methods of chat models operate on [messages](/docs/concepts/messages) as input and return messages as output.\n\nChat models offer a standard set of parameters that can be used to configure the model. These parameters are typically used to control the behavior of the model, such as the temperature of the output, the maximum number of tokens in the response, and the maximum time to wait for a response. Please see the [standard parameters](#standard-parameters) section for more details.\n\n:::note\nIn documentation, we will often use the terms "LLM" and "Chat Model" interchangeably. This is because most modern LLMs are exposed to users via a chat model interface. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@c4f6db29478d1b9f63b1657de8f1d295c3eae71114df09cda9668655471e96c3¢tsËAÚöĞ†8ø¨focus_msÍ¤§payload‚¤role©assistant§contentÙËTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after a rate limit error.ªfocus_kind¬exec_latency¨query_id¤Q056‰¢idÙ@448c1f900fe5e914abaeb8b7db1c91ae51ebf35dbe49d73bfbe685e004c85a9d¢tsËAÚöĞ†O¨trace_idÙ$f86aead6-e79e-496f-a762-b5521540fa83­parent_run_idÙ$6e201dbb-9ce7-4e37-a4cf-9409dad087f0¦run_idÙ$f86aead6-e79e-496f-a762-b5521540fa83ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙËTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after a rate limit error.¨query_id¤Q056ªfocus_kind¶chain_execution_result‰¢idÙ@93999ca1d2db5c0c8ebbf3330db9ea722171e02de9c47e948da377a7997802c3¢tsËAÚöĞ†Z’¨trace_idÙ$6e201dbb-9ce7-4e37-a4cf-9409dad087f0­parent_run_idÀ¦run_idÙ$6e201dbb-9ce7-4e37-a4cf-9409dad087f0ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙDName two ChatModel parameters that help avoid exceeding rate limits.§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËMany of the key methods of chat models operate on [messages](/docs/concepts/messages) as input and return messages as output.

Chat models offer a standard set of parameters that can be used to config...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÙËTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after a rate limit error.¨query_id¤Q056ªfocus_kind¶chain_execution_result‹¢idÙ@4c5ae0ac9cca6ab19a27fa784172017c0e776a80d54e6f9654e1347bd0b2396f¢tsËAÚöĞ†f4¨trace_id¤Q057­parent_run_idÀ¦run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?¨query_id¤Q057§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q057ªfocus_kind¯chain_execution‹¢idÙ@ef9f7a57eb398dc7d5ece237444575f6a3a8e03a8a666ad4ab3e26da889086c1¢tsËAÚöĞ†v%¨trace_id¤Q057­parent_run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335¦run_idÙ$ff053b13-c490-499a-99d5-e16c944d09ddªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context¦answer ¨query_id¤Q057¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q057®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:5c4431b5-bb8c-2047-66bc-3952b75eb394ªfocus_kind¯chain_execution‰¢idÙ@f5c229f9f2c86a29679107dbfa923de86efc8d72f09fc2578acc225728e081ec¢tsËAÚöĞ–
¨trace_idÙ$ff053b13-c490-499a-99d5-e16c944d09dd­parent_run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335¦run_idÙ$ff053b13-c490-499a-99d5-e16c944d09ddªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q057ªfocus_kind¶chain_execution_result‹¢idÙ@60b506c5fc92990bf16ae51fad767d18af786362741dd27c4df00ccd89b27ade¢tsËAÚöĞ–‹¨trace_id¤Q057­parent_run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335¦run_idÙ$e8388633-d05b-4d39-8844-c50e38e5e3ebªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q057¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q057®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:705df40f-3af6-1571-c716-56cb21843e0fªfocus_kind¯chain_execution‹¢idÙ@30499005740a5eb8add0900c42314e44ae0a8b92169cf776272e58b0af73bcc2¢tsËAÚöĞ–Ÿ¨trace_id¤Q057­parent_run_idÙ$e8388633-d05b-4d39-8844-c50e38e5e3eb¦run_idÙ$ff7143cd-3a75-4f90-af52-9fdde9a1927aªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ4How do you specify a custom UUID for a Runnable run?§contextÚN:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnecessary for most users.
:::

You may need to set a custom `run_id` for a given run, in case you want 
to reference it later or correlate it with other systems.

The `run_id` MUST be a valid UUID string and **unique** for each run. It is used to identify
the parent run, sub-class will get their own unique run ids automatically.

To set a custom `run_id`, you can pass it as a key-value pair in the `config` dictionary when invoking the Runnable:

```python
import uuid

run_id = uuid.uuid4()

some_runnable.invoke(
   some_input, 
   config={
      'run_id': run_id
   }
)

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.
* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.

See the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.

### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.

The `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.

The `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.

Using these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can
filter and search on.

The attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q057®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:705df40f-3af6-1571-c716-56cb21843e0f­checkpoint_nsÙ-generate:705df40f-3af6-1571-c716-56cb21843e0f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@80c77734e81f0bb31b91be3262e9c0fe1165fcd41168e99bc5d672e696a95fc8¢tsËAÚöĞ–*R¨trace_idÙ$ff7143cd-3a75-4f90-af52-9fdde9a1927a­parent_run_idÙ$e8388633-d05b-4d39-8844-c50e38e5e3eb¦run_idÙ$ff7143cd-3a75-4f90-af52-9fdde9a1927aªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ>messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you specify a custom UUID for a Runnable run? \nContext: :::note Related\n* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n:::\n\n### Setting run id\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nYou may need to set a custom `run_id` for a given run, in case you want \nto reference it later or correlate it with other systems.\n\nThe `run_id` MUST be a valid UUID string and **unique** for each run. It is used to identify\nthe parent run, sub-class will get their own unique run ids automatically.\n\nTo set a custom `run_id`, you can pass it as a key-value pair in the `config` dictionary when invoking the Runnable:\n\n```python\nimport uuid\n\nrun_id = uuid.uuid4()\n\nsome_runnable.invoke(\n   some_input, \n   config={\n      \'run_id\': run_id\n   }\n)\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.\n* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.\n\nSee the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.\n\n### Setting custom run name, tags, and metadata\n\nThe `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.\n\nThe `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.\n\nThe `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.\n\nUsing these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can\nfilter and search on.\n\nThe attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@e6c462bca5257fd59b57dc0e55a2b420b436a756adfa902f7d0af0eded1791fb¢tsËAÚöÑqù¾¨focus_msÍj§payload‚¤role©assistant§contentÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.ªfocus_kind¬exec_latency¨query_id¤Q057‰¢idÙ@0edc84030bb7568c304979e9e3c12ff88797b6889817353eaa0c9fcfae53df5c¢tsËAÚöÑrAÀ¨trace_idÙ$e8388633-d05b-4d39-8844-c50e38e5e3eb­parent_run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335¦run_idÙ$e8388633-d05b-4d39-8844-c50e38e5e3ebªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.¨query_id¤Q057ªfocus_kind¶chain_execution_result‰¢idÙ@ca2609f4cc561e547c431091e615644dfa3f086ae0b13cd7874870bfc1c0d080¢tsËAÚöÑsîN¨trace_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335­parent_run_idÀ¦run_idÙ$65dcc026-a6fb-4887-9cd9-d0028f1e7335ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.¨query_id¤Q057ªfocus_kind¶chain_execution_result‹¢idÙ@568fe71e40a30516f2d684630e6feefe286797c14bc3aaca6c24e345ea065f1d¢tsËAÚöÑu€²¨trace_id¤Q058­parent_run_idÀ¦run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.¨query_id¤Q058§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q058ªfocus_kind¯chain_execution‹¢idÙ@a8606de94b1351f3153cca56ebfe4edb10113e63001263b0f9dba5fbd6c15920¢tsËAÚöÑvÜ7¨trace_id¤Q058­parent_run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484¦run_idÙ$bc1a6445-3048-45dd-9c0f-ce9a33fe116bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context¦answer ¨query_id¤Q058¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q058®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3b73e1cf-ed82-44d9-4f5c-fa3dc5b3a28dªfocus_kind¯chain_execution‰¢idÙ@b59a038a9c4f7df05daf1c3b0f307bf24b33165a0e969ef8a72d390adc26eae2¢tsËAÚöÑŠş7¨trace_idÙ$bc1a6445-3048-45dd-9c0f-ce9a33fe116b­parent_run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484¦run_idÙ$bc1a6445-3048-45dd-9c0f-ce9a33fe116bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q058ªfocus_kind¶chain_execution_result‹¢idÙ@9dd5cae80dc9b3570062cd8cbfd526ef88b30fed3f4d2c051aa6512adb888fc9¢tsËAÚöÑŒíx¨trace_id¤Q058­parent_run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484¦run_idÙ$4b84ee6d-1ade-4e97-a74b-ca5d48df68b8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q058¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q058®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c491cd69-0dca-08d2-5992-8ff0a19ba10fªfocus_kind¯chain_execution‹¢idÙ@23f457bb1e48840bb684ef1a427528c3356f0b104c15cafa36e1fe2d2ce59b89¢tsËAÚöÑ‘n¬¨trace_id¤Q058­parent_run_idÙ$4b84ee6d-1ade-4e97-a74b-ca5d48df68b8¦run_idÙ$035bb99b-294f-4a44-9b55-1d45019768f7ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§contextÚÁ<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.
- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q058®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c491cd69-0dca-08d2-5992-8ff0a19ba10f­checkpoint_nsÙ-generate:c491cd69-0dca-08d2-5992-8ff0a19ba10f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@eb894eefd9fd96b08bdd7c78643f9329c7afbd15f285e1812ed70dfa69595492¢tsËAÚöÑ˜a¦¨trace_idÙ$035bb99b-294f-4a44-9b55-1d45019768f7­parent_run_idÙ$4b84ee6d-1ade-4e97-a74b-ca5d48df68b8¦run_idÙ$035bb99b-294f-4a44-9b55-1d45019768f7ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¤messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Compare `batch` and `batch_as_completed` when processing multiple inputs. \nContext: <a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\nThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.\n- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@e11ce449e22a6f65dc51996b050bedbf3ca15396fb54ecb0c5669a6fbac72c46¢tsËAÚöÒ`İ¨focus_msÍò§payload‚¤role©assistant§contentÚşThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. If order is not a concern, `batch_as_completed` can be more efficient as it returns results immediately when they are ready.ªfocus_kind¬exec_latency¨query_id¤Q058‰¢idÙ@7ca588043e9e1f76c4ea33b5f9e071302bbbbdab95f5483eeefa568e5e30f435¢tsËAÚöÒ`úã¨trace_idÙ$4b84ee6d-1ade-4e97-a74b-ca5d48df68b8­parent_run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484¦run_idÙ$4b84ee6d-1ade-4e97-a74b-ca5d48df68b8ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚşThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. If order is not a concern, `batch_as_completed` can be more efficient as it returns results immediately when they are ready.¨query_id¤Q058ªfocus_kind¶chain_execution_result‰¢idÙ@2fe177eb9a78d8aafd7088a7aac48f18c743f23b1a8b9c64414a8ee2dc673c2f¢tsËAÚöÒaÜ¨trace_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484­parent_run_idÀ¦run_idÙ$9a2ed0a9-a332-4dd8-8ad1-a2a36d540484ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚşThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. If order is not a concern, `batch_as_completed` can be more efficient as it returns results immediately when they are ready.¨query_id¤Q058ªfocus_kind¶chain_execution_result‹¢idÙ@e37b67787e9a4b35a1c10b706b109c6135963d8f04da1147a2ec1502df140711¢tsËAÚöÒa%‘¨trace_id¤Q059­parent_run_idÀ¦run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?¨query_id¤Q059§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q059ªfocus_kind¯chain_execution‹¢idÙ@79b8875da727c3284101dde8f463b96ae067c39cb1f8f549a1d003dc7df57395¢tsËAÚöÒa7±¨trace_id¤Q059­parent_run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8¦run_idÙ$5c80f7b1-de7e-4311-b086-1594ed10291aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context¦answer ¨query_id¤Q059¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q059®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d67ad56d-393e-e75e-fd02-4179a6aca3ceªfocus_kind¯chain_execution‰¢idÙ@c1f5fbe669a91688f57e50119de56b1edef082c70a0bbd0a1dfd5e34cf5a38b7¢tsËAÚöÒl{ª¨trace_idÙ$5c80f7b1-de7e-4311-b086-1594ed10291a­parent_run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8¦run_idÙ$5c80f7b1-de7e-4311-b086-1594ed10291aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q059ªfocus_kind¶chain_execution_result‹¢idÙ@073f044bce04813438a15d6ffbde41c631dc42adf9341170bd8e20dc0bc27a8e¢tsËAÚöÒlH¨trace_id¤Q059­parent_run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8¦run_idÙ$dc158b06-1c8d-4e71-90d9-e2dcca0b5f98ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q059¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q059®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3ddd2511-af63-204e-707b-f80f77c967ceªfocus_kind¯chain_execution‹¢idÙ@774ec9b5c70b02693373152a9795ac42717c5ab2d4132b759bad4cfb6e4c2860¢tsËAÚöÒl›‘¨trace_id¤Q059­parent_run_idÙ$dc158b06-1c8d-4e71-90d9-e2dcca0b5f98¦run_idÙ$29079c10-67be-4801-a832-7fa11700b7bcªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§contextÚ£## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally started as a single open source package, it has evolved into a company and a whole ecosystem.
This page will talk about the LangChain ecosystem as a whole.
Most of the components within the LangChain ecosystem can be used by themselves - so if you feel particularly drawn to certain components but not others, that is totally fine! Pick and choose whichever components you like best for your own use case!

## Features

There are several primary needs that LangChain aims to address:

### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: write a custom document loader](/docs/how_to/document_loader_custom)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)
- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)
- [How to: define a custom tool](/docs/how_to/custom_tools)
- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.
This diversity can make it challenging for developers to switch between providers or combine components when building applications.
LangChain exposes a standard interface for key components, making it easy to switch between providers.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q059®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3ddd2511-af63-204e-707b-f80f77c967ce­checkpoint_nsÙ-generate:3ddd2511-af63-204e-707b-f80f77c967ce¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@45a4ec551d8f158f51b164d7f134834c4424c04fd7ad5e9fa27b2be66e91a157¢tsËAÚöÒl¦¤¨trace_idÙ$29079c10-67be-4801-a832-7fa11700b7bc­parent_run_idÙ$dc158b06-1c8d-4e71-90d9-e2dcca0b5f98¦run_idÙ$29079c10-67be-4801-a832-7fa11700b7bcªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ”messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How can LangChain assist with evaluating generated answers automatically? \nContext: ## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n# Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n# Why LangChain?\n\nThe goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.\nWhile LangChain originally started as a single open source package, it has evolved into a company and a whole ecosystem.\nThis page will talk about the LangChain ecosystem as a whole.\nMost of the components within the LangChain ecosystem can be used by themselves - so if you feel particularly drawn to certain components but not others, that is totally fine! Pick and choose whichever components you like best for your own use case!\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n### Custom\n\nAll of LangChain components can easily be extended to support your own versions.\n\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: write a custom document loader](/docs/how_to/document_loader_custom)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)\n- [How to: define a custom tool](/docs/how_to/custom_tools)\n- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.\nThis diversity can make it challenging for developers to switch between providers or combine components when building applications.\nLangChain exposes a standard interface for key components, making it easy to switch between providers. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@33b75951ed134b2f8ab12b96ed5df6709e3d986904a82c83e1f623e081407b59¢tsËAÚöÒŞ¶|¨focus_msÍõ§payload‚¤role©assistant§contentÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.ªfocus_kind¬exec_latency¨query_id¤Q059‰¢idÙ@96cb81c13a1ff522194b3e324631b8e9cab9a467c0f0336426f00a15f7218a79¢tsËAÚöÒŞ¼'¨trace_idÙ$dc158b06-1c8d-4e71-90d9-e2dcca0b5f98­parent_run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8¦run_idÙ$dc158b06-1c8d-4e71-90d9-e2dcca0b5f98ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.¨query_id¤Q059ªfocus_kind¶chain_execution_result‰¢idÙ@289d1703826c4cfc6129e8f6595241f616246c3d36c0f080efa4dc883631b202¢tsËAÚöÒŞÀ˜¨trace_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8­parent_run_idÀ¦run_idÙ$e20760b5-558e-422c-9abc-d3ec27c3cca8ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.¨query_id¤Q059ªfocus_kind¶chain_execution_result‹¢idÙ@5d96e286a42c2145064202a51135d11f98e8419eac9908fcbd498788872b8648¢tsËAÚöÒŞÉê¨trace_id¤Q060­parent_run_idÀ¦run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.¨query_id¤Q060§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q060ªfocus_kind¯chain_execution‹¢idÙ@930f0a691017504931868463f5b129668bf6ba12704cf4f75931f0ad124ef479¢tsËAÚöÒŞÑd¨trace_id¤Q060­parent_run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1¦run_idÙ$318c9cbc-0880-4a1c-b85c-844eb0203390ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context¦answer ¨query_id¤Q060¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q060®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:6e1fd71d-fab0-b7c6-5b4e-27afc4b384b9ªfocus_kind¯chain_execution‰¢idÙ@951f732b1552ad80602efafc2fe44bfea71774a47a9528b3ae094cdfe30fb9fa¢tsËAÚöÒò+¨trace_idÙ$318c9cbc-0880-4a1c-b85c-844eb0203390­parent_run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1¦run_idÙ$318c9cbc-0880-4a1c-b85c-844eb0203390ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q060ªfocus_kind¶chain_execution_result‹¢idÙ@6e015d3a61770610e205744f2ad54ddbd507e07406e3f7dfafec3d4103643a3e¢tsËAÚöÒò!}¨trace_id¤Q060­parent_run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1¦run_idÙ$65723f60-841a-4019-b73f-f2d3c501d181ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q060¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q060®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:82e19858-33ea-36cd-5342-66d0d0f09cb6ªfocus_kind¯chain_execution‹¢idÙ@6f01d8de6f837d8efb22c19c16c7a9924f86b69c1201af391767bb9e1259d034¢tsËAÚöÒò(Ç¨trace_id¤Q060­parent_run_idÙ$65723f60-841a-4019-b73f-f2d3c501d181¦run_idÙ$c7813dbf-ab41-4a07-a7d3-ba818a6d1a39ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§contextÚ
# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.

To learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).

### Tracing
<span data-heading-keywords="trace,tracing"></span>

Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)

You can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).

## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.

:::

## Observability and evaluation

The pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. 
Developers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. 
High quality tracing and evaluations can help you rapidly answer these types of questions with confidence.
[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.
See our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.

:::info[Further reading]

:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## Conclusion

LangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:
- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.
- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q060®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:82e19858-33ea-36cd-5342-66d0d0f09cb6­checkpoint_nsÙ-generate:82e19858-33ea-36cd-5342-66d0d0f09cb6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@43b891ad9ab21fa4ca5f890028ac8d28786d8622d580e3d305239ae07f86cecd¢tsËAÚöÒò5;¨trace_idÙ$c7813dbf-ab41-4a07-a7d3-ba818a6d1a39­parent_run_idÙ$65723f60-841a-4019-b73f-f2d3c501d181¦run_idÙ$c7813dbf-ab41-4a07-a7d3-ba818a6d1a39ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÿmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Provide two metrics supported by LangChain\'s built in evaluation module. \nContext: # Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n### Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluating performance is a vital part of building LLM-powered applications.\nLangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.\n\nTo learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).\n\n### Tracing\n<span data-heading-keywords="trace,tracing"></span>\n\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\n- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n\nYou can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).\n\n## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n:::info[Further reading]\n\nHave a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.\n\n:::\n\n## Observability and evaluation\n\nThe pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. \nDevelopers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. \nHigh quality tracing and evaluations can help you rapidly answer these types of questions with confidence.\n[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.\nSee our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.\n\n:::info[Further reading]\n\n:::info[Further reading]\n\nSee our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.\n\n:::\n\n## Conclusion\n\nLangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:\n- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.\n- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/). \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@700eab870551e46ca08494805e6bcc88c0ab083590f256100fa70b795eb7a7ea¢tsËAÚöÓ9ó0¨focus_msÍ`§payload‚¤role©assistant§contentÙùLangChain's built-in evaluation module supports various metrics, including accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications. For more details, you can refer to the LangSmith documentation.ªfocus_kind¬exec_latency¨query_id¤Q060‰¢idÙ@b1e9330ef53f17d508fbbe93a3174070603be9c9b328971e5efcaa745660f91e¢tsËAÚöÓ:K¨trace_idÙ$65723f60-841a-4019-b73f-f2d3c501d181­parent_run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1¦run_idÙ$65723f60-841a-4019-b73f-f2d3c501d181ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙùLangChain's built-in evaluation module supports various metrics, including accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications. For more details, you can refer to the LangSmith documentation.¨query_id¤Q060ªfocus_kind¶chain_execution_result‰¢idÙ@9a433777a77e356ae7e62e7d0ea96d8de45bea9a2b455d013c1947a67619133a¢tsËAÚöÓ:²¨trace_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1­parent_run_idÀ¦run_idÙ$d39673da-25b4-4119-b1ce-c6aea0e8a8e1ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÙùLangChain's built-in evaluation module supports various metrics, including accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications. For more details, you can refer to the LangSmith documentation.¨query_id¤Q060ªfocus_kind¶chain_execution_result‹¢idÙ@cf8e0484d026a04cb3738305bf698986e2dbef8f812cfe05f1d335c67885183d¢tsËAÚöÓ:¬¨trace_id¤Q061­parent_run_idÀ¦run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?¨query_id¤Q061§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q061ªfocus_kind¯chain_execution‹¢idÙ@e5ce41c992a823b952e731a7ec56989fdd71b8c69ea9c8f35e121c4642b1a6a3¢tsËAÚöÓ:$¨trace_id¤Q061­parent_run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513¦run_idÙ$606ff9df-a043-493e-8110-18537a89fa64ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context¦answer ¨query_id¤Q061¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q061®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:213be049-43dc-36ac-79e9-a9d08d311c34ªfocus_kind¯chain_execution‰¢idÙ@77d01db916a81cd5101a93945205014ce8d826b9d931ec8c392785a17d810c3b¢tsËAÚöÓMÊÕ¨trace_idÙ$606ff9df-a043-493e-8110-18537a89fa64­parent_run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513¦run_idÙ$606ff9df-a043-493e-8110-18537a89fa64ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q061ªfocus_kind¶chain_execution_result‹¢idÙ@cdd58bb747736532fef45c9be5a05fd05b569682b7a1d272d0d09f6f6fe06a4d¢tsËAÚöÓM×I¨trace_id¤Q061­parent_run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513¦run_idÙ$8b719299-1c2f-4054-bbbe-01c3bd940d12ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q061¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q061®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e78a508c-486f-1165-3a1b-b134387c469cªfocus_kind¯chain_execution‹¢idÙ@926938a249c8e1cc9ead05defde20461362da8a4a1a4e3fa5f73c57a7782fada¢tsËAÚöÓMŞ/¨trace_id¤Q061­parent_run_idÙ$8b719299-1c2f-4054-bbbe-01c3bd940d12¦run_idÙ$5de918d2-c104-4b49-a2b3-a6d0e795f6bbªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§contextÚÃ# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.

This means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloading, you can use the `.pipe` method instead. This is equivalent to the `|` operator.

```python
chain = runnable1.pipe(runnable2)
```

### Coercion

LCEL applies automatic type coercion to make it easier to compose chains.

If you do not understand the type coercion, you can always use the `RunnableSequence` and `RunnableParallel` classes directly.

This will make the code more verbose, but it will also make it more explicit.

#### Dictionary to RunnableParallel

Inside an LCEL expression, a dictionary is automatically converted to a `RunnableParallel`.

For example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q061®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e78a508c-486f-1165-3a1b-b134387c469c­checkpoint_nsÙ-generate:e78a508c-486f-1165-3a1b-b134387c469c¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@350499bcfaf43d1f42a3a85bcd614b5a1443a29d16864ce5def9177791b60402¢tsËAÚöÓMä—¨trace_idÙ$5de918d2-c104-4b49-a2b3-a6d0e795f6bb­parent_run_idÙ$8b719299-1c2f-4054-bbbe-01c3bd940d12¦run_idÙ$5de918d2-c104-4b49-a2b3-a6d0e795f6bbªevent_type¬chain_output¬event_source¥chain§payload§outputsÚĞmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which LangChain concept allows combining multiple Runnables with the `|` operator? \nContext: # LangChain Expression Language (LCEL)\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n:::\n\nThe **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.\n\nThis means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n```python\nchain = runnable1 | runnable2\n```\n\nis Equivalent to:\n\n```python\nchain = RunnableSequence([runnable1, runnable2])\n```\n\n### The `.pipe` method\n\nIf you have moral qualms with operator overloading, you can use the `.pipe` method instead. This is equivalent to the `|` operator.\n\n```python\nchain = runnable1.pipe(runnable2)\n```\n\n### Coercion\n\nLCEL applies automatic type coercion to make it easier to compose chains.\n\nIf you do not understand the type coercion, you can always use the `RunnableSequence` and `RunnableParallel` classes directly.\n\nThis will make the code more verbose, but it will also make it more explicit.\n\n#### Dictionary to RunnableParallel\n\nInside an LCEL expression, a dictionary is automatically converted to a `RunnableParallel`.\n\nFor example, the following code:\n\n```python\nmapping = {\n    "key1": runnable1,\n    "key2": runnable2,\n}\n\nchain = mapping | runnable3\n```\n\nIt gets automatically converted to the following:\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@c14402b1a877cd472036a981feee7be75b08b0c14fb076c043c2853b21b5146d¢tsËAÚöÓÄÒØ¨focus_msÍB§payload‚¤role©assistant§contentÚOThe LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. The `|` operator is equivalent to using `RunnableSequence` to combine Runnables.ªfocus_kind¬exec_latency¨query_id¤Q061‰¢idÙ@1e008c82f95e8b1bc17d54f55175b8c845809fce184c88371ab5724e59fa7c1a¢tsËAÚöÓÄÚM¨trace_idÙ$8b719299-1c2f-4054-bbbe-01c3bd940d12­parent_run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513¦run_idÙ$8b719299-1c2f-4054-bbbe-01c3bd940d12ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚOThe LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. The `|` operator is equivalent to using `RunnableSequence` to combine Runnables.¨query_id¤Q061ªfocus_kind¶chain_execution_result‰¢idÙ@6870346927a4dc61daab2f4fbd6a35d1984171bed6d033381d3fb49973f23f69¢tsËAÚöÓÄßQ¨trace_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513­parent_run_idÀ¦run_idÙ$80a47d8f-16e4-4230-b403-38c90bb4e513ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚOThe LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. The `|` operator is equivalent to using `RunnableSequence` to combine Runnables.¨query_id¤Q061ªfocus_kind¶chain_execution_result‹¢idÙ@95a3611531251ae92ac6ae1873681a6b281288add6c33ab953255c2c569086b2¢tsËAÚöÓÄä¨trace_id¤Q062­parent_run_idÀ¦run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ffªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.¨query_id¤Q062§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q062ªfocus_kind¯chain_execution‹¢idÙ@9ea388da4438702b126183bfef00e8dc1555fc093554856b74716bdf1d69ab30¢tsËAÚöÓÄìK¨trace_id¤Q062­parent_run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ff¦run_idÙ$ed892413-a61f-4888-8d2d-7d1035c50544ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context¦answer ¨query_id¤Q062¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q062®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:9015a4bd-0133-696d-2bc2-ea86459bd182ªfocus_kind¯chain_execution‰¢idÙ@5cc9b98f691b085153f4587b0ad0c5cc0f56e4e6c4c1c2794bb110917aeef384¢tsËAÚöÓÖ:&¨trace_idÙ$ed892413-a61f-4888-8d2d-7d1035c50544­parent_run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ff¦run_idÙ$ed892413-a61f-4888-8d2d-7d1035c50544ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q062ªfocus_kind¶chain_execution_result‹¢idÙ@fb3dc8059576826d7e907670fcdf3a07fee61ecf70e9cdc0ec1a1ac3bf66c49c¢tsËAÚöÓÖF¨trace_id¤Q062­parent_run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ff¦run_idÙ$58ee6af6-9755-485a-84b8-de20ccd2afe7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q062¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q062®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:133a0b73-d4b6-a5dc-5065-a16bc02b96e5ªfocus_kind¯chain_execution‹¢idÙ@46a432a03bac4502b5bc8649ebf7a75e677e9859554004782d369f47ee73bbdd¢tsËAÚöÓÖJ²¨trace_id¤Q062­parent_run_idÙ$58ee6af6-9755-485a-84b8-de20ccd2afe7¦run_idÙ$a350ea04-cd1f-4882-8a52-ba51ae1c9bbcªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§contextÚİ# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may need to stream **custom data** that goes beyond the information provided by the pipeline or workflow structure. This custom information is injected within a specific step in the workflow, whether that step is a tool or a LangGraph node. For example, you could stream updates about what a tool is doing in real-time or the progress through a LangGraph node. This granular data, which is emitted directly from within the step, provides more detailed insights into the execution of the workflow and is especially useful in complex processes where more visibility is needed.

## Streaming APIs

In this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM applications

In applications involving LLMs, several types of data can be streamed to improve user experience by reducing perceived latency and increasing transparency. These include:

### 1. Streaming LLM outputs

The most common and critical data to stream is the output generated by the LLM itself. LLMs often take time to generate full responses, and by streaming the output in real-time, users can see partial results as they are produced. This provides immediate feedback and helps reduce the wait time for users.

### 2. Streaming pipeline or workflow progress

Beyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

Beyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

- **In LangGraph Workflows:**
With [LangGraph](/docs/concepts/architecture#langgraph), workflows are composed of nodes and edges that represent various steps. Streaming here involves tracking changes to the **graph state** as individual **nodes** request updates. This allows for more granular monitoring of which node in the workflow is currently active, giving real-time updates about the status of the workflow as it progresses through different stages.

```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/) is an extremely common use case. 
Providers support different approaches for this, including [JSON mode or tool calling](https://platform.openai.com/docs/guides/structured-outputs), with different APIs.
LangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to produce structured outputs using the `with_structured_output()` method:

```python
# Define schema
schema = ...
# Bind schema to model
model_with_structure = model.with_structured_output(schema)
```

### Example: retrievers¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q062®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:133a0b73-d4b6-a5dc-5065-a16bc02b96e5­checkpoint_nsÙ-generate:133a0b73-d4b6-a5dc-5065-a16bc02b96e5¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d4e28a6d5da60c248e0c8b5c004fb465b25edd48c020786d1af618c5fa38b8a3¢tsËAÚöÓÖPÛ¨trace_idÙ$a350ea04-cd1f-4882-8a52-ba51ae1c9bbc­parent_run_idÙ$58ee6af6-9755-485a-84b8-de20ccd2afe7¦run_idÙ$a350ea04-cd1f-4882-8a52-ba51ae1c9bbcªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how to set up tool streaming so that tool results are incrementally passed back to the model. \nContext: # Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\nIn some cases, you may need to stream **custom data** that goes beyond the information provided by the pipeline or workflow structure. This custom information is injected within a specific step in the workflow, whether that step is a tool or a LangGraph node. For example, you could stream updates about what a tool is doing in real-time or the progress through a LangGraph node. This granular data, which is emitted directly from within the step, provides more detailed insights into the execution of the workflow and is especially useful in complex processes where more visibility is needed.\n\n## Streaming APIs\n\nIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.\n\n## What to stream in LLM applications\n\nIn applications involving LLMs, several types of data can be streamed to improve user experience by reducing perceived latency and increasing transparency. These include:\n\n### 1. Streaming LLM outputs\n\nThe most common and critical data to stream is the output generated by the LLM itself. LLMs often take time to generate full responses, and by streaming the output in real-time, users can see partial results as they are produced. This provides immediate feedback and helps reduce the wait time for users.\n\n### 2. Streaming pipeline or workflow progress\n\nBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:\n\nBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:\n\n- **In LangGraph Workflows:**\nWith [LangGraph](/docs/concepts/architecture#langgraph), workflows are composed of nodes and edges that represent various steps. Streaming here involves tracking changes to the **graph state** as individual **nodes** request updates. This allows for more granular monitoring of which node in the workflow is currently active, giving real-time updates about the status of the workflow as it progresses through different stages.\n\n```python\n# Tool creation\ntools = [my_tool]\n# Tool binding\nmodel_with_tools = model.bind_tools(tools)\n```\n\nSimilarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/) is an extremely common use case. \nProviders support different approaches for this, including [JSON mode or tool calling](https://platform.openai.com/docs/guides/structured-outputs), with different APIs.\nLangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to produce structured outputs using the `with_structured_output()` method:\n\n```python\n# Define schema\nschema = ...\n# Bind schema to model\nmodel_with_structure = model.with_structured_output(schema)\n```\n\n### Example: retrievers \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ebf604675279864eb17c11e5618b3f346a938e073b63d40b125f25d547f59929¢tsËAÚöÔ ?>¨focus_msÍR§payload‚¤role©assistant§contentÚ’To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your workflow is designed to stream updates, providing real-time feedback on the tool's progress.ªfocus_kind¬exec_latency¨query_id¤Q062‰¢idÙ@e3784d6ef570919ed594e4db7f7fd1e5245f5259e9de6705734db4e861d049a4¢tsËAÚöÔ M/¨trace_idÙ$58ee6af6-9755-485a-84b8-de20ccd2afe7­parent_run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ff¦run_idÙ$58ee6af6-9755-485a-84b8-de20ccd2afe7ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ’To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your workflow is designed to stream updates, providing real-time feedback on the tool's progress.¨query_id¤Q062ªfocus_kind¶chain_execution_result‰¢idÙ@7b409db35464d71735b1139ebbce3a4bd040d4f6fd95e1d93acc2d740ee7c217¢tsËAÚöÔ V¨trace_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ff­parent_run_idÀ¦run_idÙ$b0a2a913-23c1-42f7-a250-9dbb6955b7ffªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÚ’To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your workflow is designed to stream updates, providing real-time feedback on the tool's progress.¨query_id¤Q062ªfocus_kind¶chain_execution_result‹¢idÙ@4c46e9397072b2fe578ae0c55f9b457d8a7cc248b87ebfe3722f234c0774b2f4¢tsËAÚöÔ ^u¨trace_id¤Q063­parent_run_idÀ¦run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?¨query_id¤Q063§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q063ªfocus_kind¯chain_execution‹¢idÙ@caeb4eaeecdc6ed0e3b9d18693683f747b908e95c759ff2e9ec83a3ff3f6a419¢tsËAÚöÔ l‹¨trace_id¤Q063­parent_run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87f¦run_idÙ$1bde261c-b6db-4d26-bd74-4fe1ec87a0b2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context¦answer ¨query_id¤Q063¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q063®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:1bed4d9b-84af-a3c2-5eb8-1040cbe59f1dªfocus_kind¯chain_execution‰¢idÙ@4bec0c782e520ccbbc055dbd1629fa98452c75872381525890a7de5d8f9175a1¢tsËAÚöÔº]:¨trace_idÙ$1bde261c-b6db-4d26-bd74-4fe1ec87a0b2­parent_run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87f¦run_idÙ$1bde261c-b6db-4d26-bd74-4fe1ec87a0b2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q063ªfocus_kind¶chain_execution_result‹¢idÙ@e626f30e3660d0b1bd37ac1fdf4d9cb049ee2ef957e39d04f46b4e333fb33960¢tsËAÚöÔºpe¨trace_id¤Q063­parent_run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87f¦run_idÙ$ee6ab40b-08a4-4924-848c-db5a31565be3ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q063¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q063®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:846d42cc-5c26-5419-4af6-137e43694c80ªfocus_kind¯chain_execution‹¢idÙ@8e305bd3a0244dfdae0c6aa688899b66d461be398ea0928b05b67c743be2aa81¢tsËAÚöÔº{(¨trace_id¤Q063­parent_run_idÙ$ee6ab40b-08a4-4924-848c-db5a31565be3¦run_idÙ$29fc3182-7897-47e5-9f3a-d77c92a35d3eªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§contextÚÈ## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q063®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:846d42cc-5c26-5419-4af6-137e43694c80­checkpoint_nsÙ-generate:846d42cc-5c26-5419-4af6-137e43694c80¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@9dd669ec388637b2557970c46ea328f335613560eb3393b7367aa1d93c685fa5¢tsËAÚöÔº‡¨trace_idÙ$29fc3182-7897-47e5-9f3a-d77c92a35d3e­parent_run_idÙ$ee6ab40b-08a4-4924-848c-db5a31565be3¦run_idÙ$29fc3182-7897-47e5-9f3a-d77c92a35d3eªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ·messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the benefit of using `RunnableLambda` over subclassing a Runnable? \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span> \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@bf6f22e3481ad6f07eed2cc5802b8e5bafe502ec9349bc3c2b7afc473f44a3f1¢tsËAÚöÕ)G¨focus_msÍ½§payload‚¤role©assistant§contentÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.ªfocus_kind¬exec_latency¨query_id¤Q063‰¢idÙ@b16b270970ff7423341440bc143e6a541cfb55ed0f55f17ea0295e141c4c361c¢tsËAÚöÕ)¨trace_idÙ$ee6ab40b-08a4-4924-848c-db5a31565be3­parent_run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87f¦run_idÙ$ee6ab40b-08a4-4924-848c-db5a31565be3ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.¨query_id¤Q063ªfocus_kind¶chain_execution_result‰¢idÙ@89bdefae9e9483f497c03799666c9dcc9267fbd110564584e554e7c60d18d8a6¢tsËAÚöÕ)£¨trace_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87f­parent_run_idÀ¦run_idÙ$8f56d03c-89e7-4675-a148-e927abf0b87fªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.¨query_id¤Q063ªfocus_kind¶chain_execution_result‹¢idÙ@7a0eb8d2dedb7f80ab58adc774aa68448e3356a088b0ac5a118c8d2933b08605¢tsËAÚöÕ)$Ù¨trace_id¤Q064­parent_run_idÀ¦run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?¨query_id¤Q064§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q064ªfocus_kind¯chain_execution‹¢idÙ@705f21d35d750469d5d42dd9c2dd9ecf64af299bef2515709001e612bc4ead41¢tsËAÚöÕ)1A¨trace_id¤Q064­parent_run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503¦run_idÙ$cec7f879-d9f2-4b7c-b137-3c32d903b9d2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context¦answer ¨query_id¤Q064¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q064®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:08e8b6b8-d4d8-5a09-f546-b4da38ffe3a2ªfocus_kind¯chain_execution‰¢idÙ@af14feecfdabb6dbb254e550f8e2e466a3f2fc97b3da2a9dc7903382384a11cb¢tsËAÚöÕ<µ1¨trace_idÙ$cec7f879-d9f2-4b7c-b137-3c32d903b9d2­parent_run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503¦run_idÙ$cec7f879-d9f2-4b7c-b137-3c32d903b9d2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q064ªfocus_kind¶chain_execution_result‹¢idÙ@b1bc5e318ca2d4b61e2bfdc1eedba609730c974795ca46d34644c80863f38554¢tsËAÚöÕ<½à¨trace_id¤Q064­parent_run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503¦run_idÙ$057d7f18-9f2d-40ae-b9a5-54fe1f2aa0cdªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q064¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q064®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:82fb706b-d4a6-ffc2-867d-5a70da4eeb10ªfocus_kind¯chain_execution‹¢idÙ@791f078db602c568f9e4282688c7899f9bc02879a24283a1062e3e1a7a5fcc22¢tsËAÚöÕ<Ä¹¨trace_id¤Q064­parent_run_idÙ$057d7f18-9f2d-40ae-b9a5-54fe1f2aa0cd¦run_idÙ$4e261de6-f026-435c-ada0-818137cadd73ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§contextÚ@### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: write a custom document loader](/docs/how_to/document_loader_custom)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)
- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)
- [How to: define a custom tool](/docs/how_to/custom_tools)
- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data.
For a high-level tutorial on RAG, check out [this guide](/docs/tutorials/rag/).

- [How to: add chat history](/docs/how_to/qa_chat_history_how_to/)
- [How to: stream](/docs/how_to/qa_streaming/)
- [How to: return sources](/docs/how_to/qa_sources/)
- [How to: return citations](/docs/how_to/qa_citations/)
- [How to: do per-user retrieval](/docs/how_to/qa_per_user/)


### Extraction

Extraction is when you use LLMs to extract structured information from unstructured text.
For a high level tutorial on extraction, check out [this guide](/docs/tutorials/extraction/).

| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a question. | Rewrite the user question with multiple phrasings, retrieve documents for each rewritten question, return the unique documents for all queries.                                                                                                                                        |
| [Decomposition](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb) | When a question can be broken down into smaller subproblems.                                    | Decompose a question into a set of subproblems / questions, which can either be solved sequentially (use the answer from first + retrieval to answer the second) or in parallel (consolidate each answer into final answer).                                                           |

- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semantic search](/docs/tutorials/retrievers): Build a semantic search engine over a PDF with [document loaders](/docs/concepts/document_loaders), [embedding models](/docs/concepts/embedding_models/), and [vector stores](/docs/concepts/vectorstores/).
- [Classification](/docs/tutorials/classification): Classify text into categories or labels using [chat models](/docs/concepts/chat_models) with [structured outputs](/docs/concepts/structured_outputs/).
- [Extraction](/docs/tutorials/extraction): Extract structured data from text and other unstructured media using [chat models](/docs/concepts/chat_models) and [few-shot examples](/docs/concepts/few_shot_prompting/).

Refer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve results](/docs/how_to/sql_prompting)
- [How to: do query validation](/docs/how_to/sql_query_checking)
- [How to: deal with large databases](/docs/how_to/sql_large_db)
- [How to: deal with CSV files](/docs/how_to/sql_csv)

### Q&A over graph databases

You can use an LLM to do question answering over graph databases.
For a high-level tutorial, check out [this guide](/docs/tutorials/graph/).

- [How to: add a semantic layer over the database](/docs/how_to/graph_semantic)
- [How to: construct knowledge graphs](/docs/how_to/graph_constructing)

### Summarization

LLMs can summarize and otherwise distill desired information from text, including
large volumes of text. For a high-level tutorial, check out [this guide](/docs/tutorials/summarization).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q064®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:82fb706b-d4a6-ffc2-867d-5a70da4eeb10­checkpoint_nsÙ-generate:82fb706b-d4a6-ffc2-867d-5a70da4eeb10¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@57d390a66c6e98fcabf640f7228354685e904438b5b46923eb6ba9c1c1d06230¢tsËAÚöÕ<Ì¨trace_idÙ$4e261de6-f026-435c-ada0-818137cadd73­parent_run_idÙ$057d7f18-9f2d-40ae-b9a5-54fe1f2aa0cd¦run_idÙ$4e261de6-f026-435c-ada0-818137cadd73ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚTmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two documents together explain how to build a streaming question answering chain with citations? \nContext: ### Custom\n\nAll of LangChain components can easily be extended to support your own versions.\n\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: write a custom document loader](/docs/how_to/document_loader_custom)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)\n- [How to: define a custom tool](/docs/how_to/custom_tools)\n- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\nRetrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data.\nFor a high-level tutorial on RAG, check out [this guide](/docs/tutorials/rag/).\n\n- [How to: add chat history](/docs/how_to/qa_chat_history_how_to/)\n- [How to: stream](/docs/how_to/qa_streaming/)\n- [How to: return sources](/docs/how_to/qa_sources/)\n- [How to: return citations](/docs/how_to/qa_citations/)\n- [How to: do per-user retrieval](/docs/how_to/qa_per_user/)\n\n\n### Extraction\n\nExtraction is when you use LLMs to extract structured information from unstructured text.\nFor a high level tutorial on extraction, check out [this guide](/docs/tutorials/extraction/).\n\n| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a question. | Rewrite the user question with multiple phrasings, retrieve documents for each rewritten question, return the unique documents for all queries.                                                                                                                                        |\n| [Decomposition](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb) | When a question can be broken down into smaller subproblems.                                    | Decompose a question into a set of subproblems / questions, which can either be solved sequentially (use the answer from first + retrieval to answer the second) or in parallel (consolidate each answer into final answer).                                                           |\n\n- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).\n- [Semantic search](/docs/tutorials/retrievers): Build a semantic search engine over a PDF with [document loaders](/docs/concepts/document_loaders), [embedding models](/docs/concepts/embedding_models/), and [vector stores](/docs/concepts/vectorstores/).\n- [Classification](/docs/tutorials/classification): Classify text into categories or labels using [chat models](/docs/concepts/chat_models) with [structured outputs](/docs/concepts/structured_outputs/).\n- [Extraction](/docs/tutorials/extraction): Extract structured data from text and other unstructured media using [chat models](/docs/concepts/chat_models) and [few-shot examples](/docs/concepts/few_shot_prompting/).\n\nRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.\n\n## Orchestration\n\n### Q&A over SQL + CSV\n\nYou can use LLMs to do question answering over tabular data.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).\n\n- [How to: use prompting to improve results](/docs/how_to/sql_prompting)\n- [How to: do query validation](/docs/how_to/sql_query_checking)\n- [How to: deal with large databases](/docs/how_to/sql_large_db)\n- [How to: deal with CSV files](/docs/how_to/sql_csv)\n\n### Q&A over graph databases\n\nYou can use an LLM to do question answering over graph databases.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/graph/).\n\n- [How to: add a semantic layer over the database](/docs/how_to/graph_semantic)\n- [How to: construct knowledge graphs](/docs/how_to/graph_constructing)\n\n### Summarization\n\nLLMs can summarize and otherwise distill desired information from text, including\nlarge volumes of text. For a high-level tutorial, check out [this guide](/docs/tutorials/summarization). \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4899bfde8e3f3ae67ab57f8e6b08a1a299348df0b0d189e30c9618bf8a5f8fdc¢tsËAÚöÕx^>¨focus_msÍ¢§payload‚¤role©assistant§contentÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.ªfocus_kind¬exec_latency¨query_id¤Q064‰¢idÙ@3117a7237570c01210daf89744f5386d2480f0b1af946ddf43d3cdb22b950b42¢tsËAÚöÕxz¨trace_idÙ$057d7f18-9f2d-40ae-b9a5-54fe1f2aa0cd­parent_run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503¦run_idÙ$057d7f18-9f2d-40ae-b9a5-54fe1f2aa0cdªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.¨query_id¤Q064ªfocus_kind¶chain_execution_result‰¢idÙ@e386114162b3d9abe86c600bb98727e114a7caf9650b47bcb2e20dc62bae1c65¢tsËAÚöÕxƒŒ¨trace_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503­parent_run_idÀ¦run_idÙ$baf0e2f0-71d3-4ecb-9f72-592c8fdc0503ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.¨query_id¤Q064ªfocus_kind¶chain_execution_result‹¢idÙ@39401f7c857774b0a4ef16ef6b9e982b197494c766bd679da67bd93d06501f83¢tsËAÚöÕx‹¹¨trace_id¤Q065­parent_run_idÀ¦run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?¨query_id¤Q065§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q065ªfocus_kind¯chain_execution‹¢idÙ@feda307e236b4f84a6d0eac4a798fd94c22fb9dc1ddb758bc6f3bdfb3542a451¢tsËAÚöÕx”â¨trace_id¤Q065­parent_run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9¦run_idÙ$310c9dfd-b8b8-432d-b6b5-991bfd50b80cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context¦answer ¨query_id¤Q065¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q065®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:4c9079f4-b29b-ee60-a071-3338cde7f0d1ªfocus_kind¯chain_execution‰¢idÙ@dcdfce9c07ffa74ae4689463208d8f2f1412ef67b36b49417d51052c0219e857¢tsËAÚöÕŒ2¨trace_idÙ$310c9dfd-b8b8-432d-b6b5-991bfd50b80c­parent_run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9¦run_idÙ$310c9dfd-b8b8-432d-b6b5-991bfd50b80cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q065ªfocus_kind¶chain_execution_result‹¢idÙ@216cd20905f4baaf94d37e5efa9903a69b31f9909f9b2763ac0fe6fd1388892d¢tsËAÚöÕŒ¹¨trace_id¤Q065­parent_run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9¦run_idÙ$de41c074-d678-47e3-a06a-393a7bee70b1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q065¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q065®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:57b302af-3e2d-08f3-2bd2-d5294ec839d5ªfocus_kind¯chain_execution‹¢idÙ@7c10a452f14df827f8a24f86c3e732de772136f2d790e010f191d0fb65556ad7¢tsËAÚöÕŒ´¨trace_id¤Q065­parent_run_idÙ$de41c074-d678-47e3-a06a-393a7bee70b1¦run_idÙ$4df45361-01f0-4d16-ac7d-73f67ac351f9ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ7How do you measure BLEU score in LangChain evaluations?§contextÚ»:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Each embedding is essentially a set of coordinates, often in a high-dimensional space. 
In this space, the position of each point (embedding) reflects the meaning of its corresponding text.
Just as similar words might be close to each other in a thesaurus, similar concepts end up close to each other in this embedding space. 
This allows for intuitive comparisons between different pieces of text.
By reducing text to these numerical representations, we can use simple mathematical operations to quickly measure how alike two pieces of text are, regardless of their original length or structure.
Some common similarity metrics include:

## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.

To learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).

### Tracing
<span data-heading-keywords="trace,tracing"></span>

Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)

You can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).

:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.

:::

## Observability and evaluation

The pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. 
Developers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. 
High quality tracing and evaluations can help you rapidly answer these types of questions with confidence.
[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.
See our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.

:::info[Further reading]¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q065®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:57b302af-3e2d-08f3-2bd2-d5294ec839d5­checkpoint_nsÙ-generate:57b302af-3e2d-08f3-2bd2-d5294ec839d5¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@8755f813bc3a091ffda36a4ad474c40efef64e62304e7e4dbec5343e713e1845¢tsËAÚöÕŒ"S¨trace_idÙ$4df45361-01f0-4d16-ac7d-73f67ac351f9­parent_run_idÙ$de41c074-d678-47e3-a06a-393a7bee70b1¦run_idÙ$4df45361-01f0-4d16-ac7d-73f67ac351f9ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¡messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you measure BLEU score in LangChain evaluations? \nContext: :::\n\n### Integrations\n\nLangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.\n\n## Measure similarity\n\nEach embedding is essentially a set of coordinates, often in a high-dimensional space. \nIn this space, the position of each point (embedding) reflects the meaning of its corresponding text.\nJust as similar words might be close to each other in a thesaurus, similar concepts end up close to each other in this embedding space. \nThis allows for intuitive comparisons between different pieces of text.\nBy reducing text to these numerical representations, we can use simple mathematical operations to quickly measure how alike two pieces of text are, regardless of their original length or structure.\nSome common similarity metrics include:\n\n## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n# Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n### Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluating performance is a vital part of building LLM-powered applications.\nLangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.\n\nTo learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).\n\n### Tracing\n<span data-heading-keywords="trace,tracing"></span>\n\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\n- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n\nYou can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).\n\n:::info[Further reading]\n\nHave a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.\n\n:::\n\n## Observability and evaluation\n\nThe pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. \nDevelopers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. \nHigh quality tracing and evaluations can help you rapidly answer these types of questions with confidence.\n[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.\nSee our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.\n\n:::info[Further reading] \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@c585ba7baa3732d4812241e62dfad58574f94a62a23412e114cf916ec6a2378a¢tsËAÚöÕâ³)¨focus_msÍH§payload‚¤role©assistant§contentÙäThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know the answer.ªfocus_kind¬exec_latency¨query_id¤Q065‰¢idÙ@def0057040981aadaca028ea4906c6c379bd3c32ea52dd163d4b6b3b5fdf623b¢tsËAÚöÕâÔ¿¨trace_idÙ$de41c074-d678-47e3-a06a-393a7bee70b1­parent_run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9¦run_idÙ$de41c074-d678-47e3-a06a-393a7bee70b1ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙäThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know the answer.¨query_id¤Q065ªfocus_kind¶chain_execution_result‰¢idÙ@75d9bd4b58a6343354ba17a31979b0817902829799f74117e3fd501c9b640658¢tsËAÚöÕâß¨trace_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9­parent_run_idÀ¦run_idÙ$ab3823ef-bc34-40b3-9307-1dfa89c83bd9ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÙäThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know the answer.¨query_id¤Q065ªfocus_kind¶chain_execution_result‹¢idÙ@533b8dc41366e155a5b3317923c4c1390493cdf9bdeaed2310cce0c7f73cdc16¢tsËAÚöÕâå“¨trace_id¤Q066­parent_run_idÀ¦run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?¨query_id¤Q066§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q066ªfocus_kind¯chain_execution‹¢idÙ@914dd36f0726c17e39db34c74433d25b23418facfbbd4f862fe95795c329954e¢tsËAÚöÕâõß¨trace_id¤Q066­parent_run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2¦run_idÙ$4d8fabe5-58f9-47c4-b4f8-dae7d0759de2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context¦answer ¨query_id¤Q066¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q066®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7dcc7596-3873-a5ff-c7d4-60cbf4ffbb60ªfocus_kind¯chain_execution‰¢idÙ@d23cfa906856b5f687428305b9a290869dea1088124767f5b0abed5cf0e86fc8¢tsËAÚöÕòĞS¨trace_idÙ$4d8fabe5-58f9-47c4-b4f8-dae7d0759de2­parent_run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2¦run_idÙ$4d8fabe5-58f9-47c4-b4f8-dae7d0759de2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q066ªfocus_kind¶chain_execution_result‹¢idÙ@01871f59a885af46dd3a621a99e56d6b95616ab287f8e47077dfa0960b6235b2¢tsËAÚöÕòØV¨trace_id¤Q066­parent_run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2¦run_idÙ$c3ba2fdb-6fb3-45e0-98dd-9bd63b694254ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q066¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q066®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:93a8c6a6-d76e-a1fb-bb12-20b38562784bªfocus_kind¯chain_execution‹¢idÙ@85193ff39e33a5268dba7c8f5fd2ce8fa81c1441f63cefb102867d11c7273a77¢tsËAÚöÕòÜÓ¨trace_id¤Q066­parent_run_idÙ$c3ba2fdb-6fb3-45e0-98dd-9bd63b694254¦run_idÙ$aece939e-ba74-42b3-ba44-cc26f2add3d2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§contextÚïThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often involves a combination of two patterns of alternating messages:

1. The **user** and the **assistant** representing a back-and-forth conversation.
2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.

## Managing chat history

Since chat models have a maximum limit on input size, it's important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.
    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.
- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.

:::tip
Understanding correct conversation structure is essential for being able to properly implement
[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.
:::

## Related resources

## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q066®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:93a8c6a6-d76e-a1fb-bb12-20b38562784b­checkpoint_nsÙ-generate:93a8c6a6-d76e-a1fb-bb12-20b38562784b¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@6314a43f488b2f5723ef700d0fb9d9428b602ea48f5a781a2f915dd751c4ca42¢tsËAÚöÕòâ¨¨trace_idÙ$aece939e-ba74-42b3-ba44-cc26f2add3d2­parent_run_idÙ$c3ba2fdb-6fb3-45e0-98dd-9bd63b694254¦run_idÙ$aece939e-ba74-42b3-ba44-cc26f2add3d2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚËmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does the `ConversationBufferWindowMemory` keep in memory? \nContext: The **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.\n\nA full conversation often involves a combination of two patterns of alternating messages:\n\n1. The **user** and the **assistant** representing a back-and-forth conversation.\n2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.\n\n## Managing chat history\n\nSince chat models have a maximum limit on input size, it\'s important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n- The conversation should follow one of these structures:\n    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.\n    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.\n- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.\n\n:::tip\nUnderstanding correct conversation structure is essential for being able to properly implement\n[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.\n:::\n\n## Related resources\n\n## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\n### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4ad4a972b341f5af2986a4f5548c533d28011aa50f5d6abffc6d8c3178b224a1¢tsËAÚöÖz§¨focus_msÍI§payload‚¤role©assistant§contentÚŒThe `ConversationBufferWindowMemory` keeps track of the chat history in a structured format, preserving the sequence of messages exchanged between the user and the assistant. It manages the conversation to ensure it adheres to the correct structure while also trimming messages as needed to stay within the model's context window. This allows for effective memory management in chat interactions.ªfocus_kind¬exec_latency¨query_id¤Q066‰¢idÙ@f97911240020db0a5791b6932dfbfea723461adf60031a56d9090d0827552cb0¢tsËAÚöÖz»¨trace_idÙ$c3ba2fdb-6fb3-45e0-98dd-9bd63b694254­parent_run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2¦run_idÙ$c3ba2fdb-6fb3-45e0-98dd-9bd63b694254ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚŒThe `ConversationBufferWindowMemory` keeps track of the chat history in a structured format, preserving the sequence of messages exchanged between the user and the assistant. It manages the conversation to ensure it adheres to the correct structure while also trimming messages as needed to stay within the model's context window. This allows for effective memory management in chat interactions.¨query_id¤Q066ªfocus_kind¶chain_execution_result‰¢idÙ@49416c0fe617a7f76c347519a90312dc89e8829e6ff83327d0a1e3839d4a8271¢tsËAÚöÖzÇX¨trace_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2­parent_run_idÀ¦run_idÙ$900f2ec2-34c6-4324-a4b0-cda2af350ee2ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚŒThe `ConversationBufferWindowMemory` keeps track of the chat history in a structured format, preserving the sequence of messages exchanged between the user and the assistant. It manages the conversation to ensure it adheres to the correct structure while also trimming messages as needed to stay within the model's context window. This allows for effective memory management in chat interactions.¨query_id¤Q066ªfocus_kind¶chain_execution_result‹¢idÙ@13b7ca91e11664a4489965fdde5f8337e96f5df720e5a1577fdf4212e23622de¢tsËAÚöÖzÏy¨trace_id¤Q067­parent_run_idÀ¦run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.¨query_id¤Q067§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q067ªfocus_kind¯chain_execution‹¢idÙ@17490d1608b234c6544f1fc63300f5939b8f0c68a66d8b356cf1b63906d8c118¢tsËAÚöÖzØ'¨trace_id¤Q067­parent_run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4e¦run_idÙ$1fab8d39-1a04-413c-824b-fce401a86f08ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context¦answer ¨query_id¤Q067¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q067®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:a4e9ad53-7aa4-7755-4736-955801cea620ªfocus_kind¯chain_execution‰¢idÙ@b908c600c7789e8f49df60ae4aaedafeaf1b1801c46fde68b84e999c84080de7¢tsËAÚöÖˆM”¨trace_idÙ$1fab8d39-1a04-413c-824b-fce401a86f08­parent_run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4e¦run_idÙ$1fab8d39-1a04-413c-824b-fce401a86f08ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¨query_id¤Q067ªfocus_kind¶chain_execution_result‹¢idÙ@6a05d493f4c21a93eb9cbc784910c5a21d558a5b9edde61023898013fcd304e6¢tsËAÚöÖˆUÖ¨trace_id¤Q067­parent_run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4e¦run_idÙ$f9d0d85b-a9d4-4eee-aad8-4f9a2c64d70bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¦answer ¨query_id¤Q067¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q067®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:259bde3d-ac47-6650-53f9-ae2e097296fdªfocus_kind¯chain_execution‹¢idÙ@7bfaa9fc4ea1bfed9974e9326f9d529ba9610f9923b096d1c1ebb9ce06bee356¢tsËAÚöÖˆZh¨trace_id¤Q067­parent_run_idÙ$f9d0d85b-a9d4-4eee-aad8-4f9a2c64d70b¦run_idÙ$5fc8c97d-09b8-4704-93f0-8e54c451caa5ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§contextÚì# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.

## Integrations

You can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).

## Interface

Documents loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).

Each DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.

Here's a simple example:

```python
from langchain_community.document_loaders.csv_loader import CSVLoader

## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
based service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from
digital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.

This [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.

### Prerequisite

# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attributeâ€“value pairs and arrays (or other serializable values).

[JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.

LangChain implements a [JSONLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.json_loader.JSONLoader.html) 
to convert JSON and JSONL data into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) 
objects. It uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_(programming_language)) to parse the JSON files, allowing for the extraction of specific fields into the content 
and metadata of the LangChain Document.

### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don't have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.

```python
%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence

from langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader

file_path = "<filepath>"
endpoint = "<endpoint>"
key = "<key>"
loader = AzureAIDocumentIntelligenceLoader(
    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"
)

documents = loader.load()
```

It uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load JSON and JSONL data into the content of a LangChain `Document`;
- How to load JSON and JSONL data into metadata associated with a `Document`.


```python
#!pip install jq
```


```python
from langchain_community.document_loaders import JSONLoader
```


```python
import json
from pathlib import Path
from pprint import pprint


file_path='./example_data/facebook_chat.json'
data = json.loads(Path(file_path).read_text())
```¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q067®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:259bde3d-ac47-6650-53f9-ae2e097296fd­checkpoint_nsÙ-generate:259bde3d-ac47-6650-53f9-ae2e097296fd¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@cbf4ac0300ed5e2050f40d96b81a50428bfdc7f5bdab848cb9a44b239a3f065e¢tsËAÚöÖˆ`x¨trace_idÙ$5fc8c97d-09b8-4704-93f0-8e54c451caa5­parent_run_idÙ$f9d0d85b-a9d4-4eee-aad8-4f9a2c64d70b¦run_idÙ$5fc8c97d-09b8-4704-93f0-8e54c451caa5ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚêmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name a loader designed specifically for PDF files in LangChain. \nContext: # Document loaders\n<span data-heading-keywords="document loader,document loaders"></span>\n\n:::info[Prerequisites]\n\n* [Document loaders API reference](/docs/how_to/#document-loaders)\n:::\n\nDocument loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.\n\n## Integrations\n\nYou can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).\n\n## Interface\n\nDocuments loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).\n\nEach DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.\n\nHere\'s a simple example:\n\n```python\nfrom langchain_community.document_loaders.csv_loader import CSVLoader\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning \nbased service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from\ndigital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.\n\nThis [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.\n\n### Prerequisite\n\n# How to load JSON\n\n[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attributeâ€“value pairs and arrays (or other serializable values).\n\n[JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.\n\nLangChain implements a [JSONLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.json_loader.JSONLoader.html) \nto convert JSON and JSONL data into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) \nobjects. It uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_(programming_language)) to parse the JSON files, allowing for the extraction of specific fields into the content \nand metadata of the LangChain Document.\n\n### Prerequisite\n\nAn Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don\'t have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.\n\n```python\n%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence\n\nfrom langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader\n\nfile_path = "<filepath>"\nendpoint = "<endpoint>"\nkey = "<key>"\nloader = AzureAIDocumentIntelligenceLoader(\n    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"\n)\n\ndocuments = loader.load()\n```\n\nIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.\n\nHere we will demonstrate: \n\n- How to load JSON and JSONL data into the content of a LangChain `Document`;\n- How to load JSON and JSONL data into metadata associated with a `Document`.\n\n\n```python\n#!pip install jq\n```\n\n\n```python\nfrom langchain_community.document_loaders import JSONLoader\n```\n\n\n```python\nimport json\nfrom pathlib import Path\nfrom pprint import pprint\n\n\nfile_path=\'./example_data/facebook_chat.json\'\ndata = json.loads(Path(file_path).read_text())\n``` \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@08b5e6597331e7cec07a3e3cdb6a4472d9caf0563ac973774c508f19622bca28¢tsËAÚöÖÉIw¨focus_msÍõ§payload‚¤role©assistant§contentÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.ªfocus_kind¬exec_latency¨query_id¤Q067‰¢idÙ@8a29a2b9ba85a35a117c3830e9fedeb0d4926ff637d7014efa4d39bd91cffd7b¢tsËAÚöÖÉa}¨trace_idÙ$f9d0d85b-a9d4-4eee-aad8-4f9a2c64d70b­parent_run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4e¦run_idÙ$f9d0d85b-a9d4-4eee-aad8-4f9a2c64d70bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.¨query_id¤Q067ªfocus_kind¶chain_execution_result‰¢idÙ@743d3a3e6d077f477424c9abf2734f0148f5e43a09254554f4063a7ed81aaba8¢tsËAÚöÖÉqÚ¨trace_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4e­parent_run_idÀ¦run_idÙ$346c39c0-8b9a-4a8c-9237-59a2406e2a4eªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¦answerÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.¨query_id¤Q067ªfocus_kind¶chain_execution_result‹¢idÙ@edcfbdf83f8c7e35b87c288dedf577998d80667988ab19135668de54d42471d2¢tsËAÚöÖÉ|¢¨trace_id¤Q068­parent_run_idÀ¦run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?¨query_id¤Q068§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q068ªfocus_kind¯chain_execution‹¢idÙ@7d27b4cef8a41993405f3519d5603160b5cc7e0c42e5d1d0a309b53027326eb7¢tsËAÚöÖÉ†ô¨trace_id¤Q068­parent_run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234¦run_idÙ$6c52c343-e2ae-4de5-9fef-b31e28b714b0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context¦answer ¨query_id¤Q068¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q068®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:a9deeb56-2ae8-4ff8-5e7d-756402b12ffeªfocus_kind¯chain_execution‰¢idÙ@edefb3739079c36e301d7fb508623da881c9f24455ecd0bc54d575c390b9f188¢tsËAÚöÖÛ8¨trace_idÙ$6c52c343-e2ae-4de5-9fef-b31e28b714b0­parent_run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234¦run_idÙ$6c52c343-e2ae-4de5-9fef-b31e28b714b0ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q068ªfocus_kind¶chain_execution_result‹¢idÙ@5d2a02b22e5b9cf4d9cc594e7dce03a45f513aa56b841db8a2383d273fd80ad3¢tsËAÚöÖÛB…¨trace_id¤Q068­parent_run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234¦run_idÙ$e131b8b3-1ceb-4615-a544-6eec89544b09ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q068¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q068®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2fc04596-9314-f060-da11-7700e2f8e8f8ªfocus_kind¯chain_execution‹¢idÙ@cafaa0e42b5a7b440ec56008e4bbf331d9f2150d953ff118376d4d5e43f98c63¢tsËAÚöÖÛGà¨trace_id¤Q068­parent_run_idÙ$e131b8b3-1ceb-4615-a544-6eec89544b09¦run_idÙ$12a3648a-75e2-4543-adfe-2c601c6e4d17ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§contextÚPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in making applications based on LLMs feel responsive to end-users.

Runnables expose the following three streaming APIs:

1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): yields the output a Runnable as it is generated.
2. The async `astream_events`: a more advanced streaming API that allows streaming intermediate steps and final output
3. The **legacy** async `astream_log`: a legacy streaming API that streams intermediate steps and final output

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Related Resources
* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).
:::

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

Please refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.

Runnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.

* invoke: Accepts an input and returns an output.
* batch: Accepts a list of inputs and returns a list of outputs.
* stream: Accepts an input and returns a generator that yields outputs.

The **input type** and **output type** vary by component:

Please review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides for specific examples of streaming in LangChain:
* [LangGraph conceptual guide on streaming](https://langchain-ai.github.io/langgraph/concepts/streaming/)
* [LangGraph streaming how-to guides](https://langchain-ai.github.io/langgraph/how-tos/#streaming)
* [How to stream runnables](/docs/how_to/streaming/): This how-to guide goes over common streaming patterns with LangChain components (e.g., chat models) and with [LCEL](/docs/concepts/lcel).
* [How to stream chat models](/docs/how_to/chat_streaming/)
* [How to stream tool calls](/docs/how_to/tool_streaming/)

For writing custom data to the stream, please see the following resources:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q068®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2fc04596-9314-f060-da11-7700e2f8e8f8­checkpoint_nsÙ-generate:2fc04596-9314-f060-da11-7700e2f8e8f8¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@74786c4af6a220249af9af5949b5130de654c3b75e0e8dfe20f4c2e0139b62f1¢tsËAÚöÖÛP˜¨trace_idÙ$12a3648a-75e2-4543-adfe-2c601c6e4d17­parent_run_idÙ$e131b8b3-1ceb-4615-a544-6eec89544b09¦run_idÙ$12a3648a-75e2-4543-adfe-2c601c6e4d17ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚrmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which concept guide covers the standard streaming APIs exposed by Runnables? \nContext: Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\nStreaming is critical in making applications based on LLMs feel responsive to end-users.\n\nRunnables expose the following three streaming APIs:\n\n1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): yields the output a Runnable as it is generated.\n2. The async `astream_events`: a more advanced streaming API that allows streaming intermediate steps and final output\n3. The **legacy** async `astream_log`: a legacy streaming API that streams intermediate steps and final output\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n:::info Related Resources\n* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).\n:::\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.\n\n## Input and output types\n\nEvery `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.\n\nRunnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.\n\n* invoke: Accepts an input and returns an output.\n* batch: Accepts a list of inputs and returns a list of outputs.\n* stream: Accepts an input and returns a generator that yields outputs.\n\nThe **input type** and **output type** vary by component:\n\nPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.\n\n## Related Resources\n\nPlease see the following how-to guides for specific examples of streaming in LangChain:\n* [LangGraph conceptual guide on streaming](https://langchain-ai.github.io/langgraph/concepts/streaming/)\n* [LangGraph streaming how-to guides](https://langchain-ai.github.io/langgraph/how-tos/#streaming)\n* [How to stream runnables](/docs/how_to/streaming/): This how-to guide goes over common streaming patterns with LangChain components (e.g., chat models) and with [LCEL](/docs/concepts/lcel).\n* [How to stream chat models](/docs/how_to/chat_streaming/)\n* [How to stream tool calls](/docs/how_to/tool_streaming/)\n\nFor writing custom data to the stream, please see the following resources: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@b0e9422a1bd1be870631c5afe33679eab5ac84a4e162071779ff97bc8cd313f8¢tsËAÚö×8Ê¨focus_msÍ©§payload‚¤role©assistant§contentÚMThe concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, you can also refer to the [Async Programming with LangChain](/docs/concepts/async) guide.ªfocus_kind¬exec_latency¨query_id¤Q068‰¢idÙ@0f1791c9194f101368d2d7978365d776cf0f5c0540a1cbe7f8415d0d4786ae02¢tsËAÚö×85+¨trace_idÙ$e131b8b3-1ceb-4615-a544-6eec89544b09­parent_run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234¦run_idÙ$e131b8b3-1ceb-4615-a544-6eec89544b09ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚMThe concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, you can also refer to the [Async Programming with LangChain](/docs/concepts/async) guide.¨query_id¤Q068ªfocus_kind¶chain_execution_result‰¢idÙ@eb341063d48a8914ed0dff18d915cb539e6e8e19fc2ae674d8b0c9ba6f7bce99¢tsËAÚö×8Se¨trace_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234­parent_run_idÀ¦run_idÙ$e867b805-368a-4e9f-a5cd-1875d7e34234ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚMThe concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, you can also refer to the [Async Programming with LangChain](/docs/concepts/async) guide.¨query_id¤Q068ªfocus_kind¶chain_execution_result‹¢idÙ@b1fde06ddee747b11a1d2382ed6f50e8305f3bd65774358f027abff1272803cc¢tsËAÚö×8Zy¨trace_id¤Q069­parent_run_idÀ¦run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?¨query_id¤Q069§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q069ªfocus_kind¯chain_execution‹¢idÙ@ee44660d741d04e7a772950e1f0a4ad7f18c01e8baf32f556237e8bcbcae0890¢tsËAÚö×8bE¨trace_id¤Q069­parent_run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5¦run_idÙ$ab868db1-1e23-4995-8870-141f6e83f211ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context¦answer ¨query_id¤Q069¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q069®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7b4ef4cd-5f64-99c7-eea5-4413d07eee32ªfocus_kind¯chain_execution‰¢idÙ@959bca8aec8cbe6cb9657db19f7b2a8a4382f67d0258443562d0618adae7673a¢tsËAÚö×L¿+¨trace_idÙ$ab868db1-1e23-4995-8870-141f6e83f211­parent_run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5¦run_idÙ$ab868db1-1e23-4995-8870-141f6e83f211ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q069ªfocus_kind¶chain_execution_result‹¢idÙ@de46e8b2911ddf7f6ca34e32b75a0c4b82a3c274f9711642ff8960b8b143af10¢tsËAÚö×LÈó¨trace_id¤Q069­parent_run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5¦run_idÙ$cbcf1e0d-c282-4f4d-8b45-2e06adab44e0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q069¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q069®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1899f43e-8551-1882-18f4-19fa7466fc79ªfocus_kind¯chain_execution‹¢idÙ@7a3358183cad215a1e0ac9b2f9aa498eb0f2cfa55678355a0ea0b323962e80f3¢tsËAÚö×LÍÄ¨trace_id¤Q069­parent_run_idÙ$cbcf1e0d-c282-4f4d-8b45-2e06adab44e0¦run_idÙ$7c46fe6b-08b0-4f77-aaa8-17ba29ab31a2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ:What is the advantage of using `LangServe` with Runnables?§contextÚw# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Related Resources
* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).
:::

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q069®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1899f43e-8551-1882-18f4-19fa7466fc79­checkpoint_nsÙ-generate:1899f43e-8551-1882-18f4-19fa7466fc79¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3f1ee83fed0d60f4ee9c3809ef3dd920275c369ffa59a7fcba962afddf5d184d¢tsËAÚö×LÔ¨trace_idÙ$7c46fe6b-08b0-4f77-aaa8-17ba29ab31a2­parent_run_idÙ$cbcf1e0d-c282-4f4d-8b45-2e06adab44e0¦run_idÙ$7c46fe6b-08b0-4f77-aaa8-17ba29ab31a2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚPmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the advantage of using `LangServe` with Runnables? \nContext: # Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n:::info Related Resources\n* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).\n:::\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@e0cec3bdcd362e28c776e7988417d72962eb8498b4fa022792114264b0463efe¢tsËAÚö×µ8q¨focus_msÍ^§payload‚¤role©assistant§contentÚ­The advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models easily. This flexibility simplifies the process of adjusting settings like temperature in chat models or switching between various models. Additionally, it enhances the runtime execution of chains built with the LangChain Expression Language (LCEL).ªfocus_kind¬exec_latency¨query_id¤Q069‰¢idÙ@de2dcbcf5c6f18677713f480613f493dd80a81b12e2dfb030d48bfbe9aa0c36b¢tsËAÚö×µFR¨trace_idÙ$cbcf1e0d-c282-4f4d-8b45-2e06adab44e0­parent_run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5¦run_idÙ$cbcf1e0d-c282-4f4d-8b45-2e06adab44e0ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ­The advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models easily. This flexibility simplifies the process of adjusting settings like temperature in chat models or switching between various models. Additionally, it enhances the runtime execution of chains built with the LangChain Expression Language (LCEL).¨query_id¤Q069ªfocus_kind¶chain_execution_result‰¢idÙ@921a41b0d793e07d865e3f831d5fdc1494a4129bf11181b5cd80b13363c94967¢tsËAÚö×µQ¾¨trace_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5­parent_run_idÀ¦run_idÙ$b17ee60c-ad39-47c7-ae7e-de84cf4e8fe5ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚ­The advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models easily. This flexibility simplifies the process of adjusting settings like temperature in chat models or switching between various models. Additionally, it enhances the runtime execution of chains built with the LangChain Expression Language (LCEL).¨query_id¤Q069ªfocus_kind¶chain_execution_result‹¢idÙ@95d73e41f743dd8f9f618780bed00dbd56348e8a9ea8a5d88e1916416adb36f2¢tsËAÚö×µY¨trace_id¤Q070­parent_run_idÀ¦run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.¨query_id¤Q070§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q070ªfocus_kind¯chain_execution‹¢idÙ@0f12ac1e3c317acfa944159ac27f44fb423335d9181c3cee40c2fca391785afb¢tsËAÚö×µb$¨trace_id¤Q070­parent_run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13¦run_idÙ$37236b03-4e59-4999-9f87-ecad9dda4254ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context¦answer ¨query_id¤Q070¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q070®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:ec42bc79-0631-5433-a131-c3c55e39c436ªfocus_kind¯chain_execution‰¢idÙ@bbe95bec5a9ec3624800fe22bf98ec6e9dd0db005bc31d43f841fcbfce4108a3¢tsËAÚö×¿AÈ¨trace_idÙ$37236b03-4e59-4999-9f87-ecad9dda4254­parent_run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13¦run_idÙ$37236b03-4e59-4999-9f87-ecad9dda4254ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q070ªfocus_kind¶chain_execution_result‹¢idÙ@be9dd134ee3f397950524c1c070da6d282cd8fc56b79b1e74c5efbbf3a97a028¢tsËAÚö×¿Jù¨trace_id¤Q070­parent_run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13¦run_idÙ$7c74f2b2-6cd3-4bc2-be42-0f5daa48d3e4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q070¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q070®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:6038290d-92be-ca84-b960-deec854ce2c6ªfocus_kind¯chain_execution‹¢idÙ@fffe064712b242451069b62b6b07e4184d1dab41ef47471c250852ec10913c1d¢tsËAÚö×¿O¶¨trace_id¤Q070­parent_run_idÙ$7c74f2b2-6cd3-4bc2-be42-0f5daa48d3e4¦run_idÙ$f846fcfb-d4d5-4596-8130-b72282366e9eªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ1Explain how ChatModels support multimodal inputs.§contextÚC:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specific formats
2. Adhering to a cross-provider standard (see [how-to guides](/docs/how_to/#multimodal) for detail)

### How to use multimodal models

* Use the [chat model integration table](/docs/integrations/chat/) to identify which models support multimodality.
* Reference the [relevant how-to guides](/docs/how_to/#multimodal) for specific examples of how to use multimodal models.

### What kind of multimodality is supported?

#### Inputs

# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various components, allowing models and systems to handle and process a mix of these data types seamlessly.

- **Chat Models**: These could, in theory, accept and generate multimodal inputs and outputs, handling a variety of data types like text, images, audio, and video.
- **Embedding Models**: Embedding Models can represent multimodal content, embedding various forms of dataâ€”such as text, images, and audioâ€”into vector spaces.
- **Vector Stores**: Vector stores could search over embeddings that represent multimodal data, enabling retrieval across different types of information.

## Multimodality in chat models

:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the model provider. For instance,
[OpenAI](/docs/integrations/chat/openai/),
[Anthropic](/docs/integrations/chat/anthropic/), and
[Google Gemini](/docs/integrations/chat/google_generative_ai/)
support documents like PDFs as inputs.

The gist of passing multimodal inputs to a chat model is to use content blocks that
specify a type and corresponding data. For example, to pass an image to a chat model
as URL:

```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {
            "type": "image",
            "source_type": "url",
            "url": "https://...",
        },
    ],
)
response = model.invoke([message])
```

We can also pass the image as in-line data:

# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.

Modern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.

The newest generation of chat models offer additional capabilities:

#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

However, a chat model can easily interact with multimodal data by invoking tools with references (e.g., a URL) to the multimodal data, rather than the data itself. For example, any model capable of [tool calling](/docs/concepts/tool_calling) can be equipped with tools to download and process images, audio, or video.

## Multimodality in embedding models

:::info Prerequisites
* [Embedding Models](/docs/concepts/embedding_models)
:::

**Embeddings** are vector representations of data used for tasks like similarity search and retrieval.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q070®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:6038290d-92be-ca84-b960-deec854ce2c6­checkpoint_nsÙ-generate:6038290d-92be-ca84-b960-deec854ce2c6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@7a02c1b5e8fc9f5a5445a059943baf23b0bd7991b3f48bbf14504af4c038c0fb¢tsËAÚö×¿W¨trace_idÙ$f846fcfb-d4d5-4596-8130-b72282366e9e­parent_run_idÙ$7c74f2b2-6cd3-4bc2-be42-0f5daa48d3e4¦run_idÙ$f846fcfb-d4d5-4596-8130-b72282366e9eªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ1messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how ChatModels support multimodal inputs. \nContext: :::info Pre-requisites\n* [Chat models](/docs/concepts/chat_models)\n* [Messages](/docs/concepts/messages)\n:::\n \nLangChain supports multimodal data as input to chat models:\n\n1. Following provider-specific formats\n2. Adhering to a cross-provider standard (see [how-to guides](/docs/how_to/#multimodal) for detail)\n\n### How to use multimodal models\n\n* Use the [chat model integration table](/docs/integrations/chat/) to identify which models support multimodality.\n* Reference the [relevant how-to guides](/docs/how_to/#multimodal) for specific examples of how to use multimodal models.\n\n### What kind of multimodality is supported?\n\n#### Inputs\n\n# Multimodality\n\n## Overview\n\n**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various components, allowing models and systems to handle and process a mix of these data types seamlessly.\n\n- **Chat Models**: These could, in theory, accept and generate multimodal inputs and outputs, handling a variety of data types like text, images, audio, and video.\n- **Embedding Models**: Embedding Models can represent multimodal content, embedding various forms of dataâ€”such as text, images, and audioâ€”into vector spaces.\n- **Vector Stores**: Vector stores could search over embeddings that represent multimodal data, enabling retrieval across different types of information.\n\n## Multimodality in chat models\n\n:::info Pre-requisites\n* [Chat models](/docs/concepts/chat_models)\n* [Messages](/docs/concepts/messages)\n:::\n \nLangChain supports multimodal data as input to chat models:\n\n### What kind of multimodality is supported?\n\n#### Inputs\n\nSome models can accept multimodal inputs, such as images, audio, video, or files.\nThe types of multimodal inputs supported depend on the model provider. For instance,\n[OpenAI](/docs/integrations/chat/openai/),\n[Anthropic](/docs/integrations/chat/anthropic/), and\n[Google Gemini](/docs/integrations/chat/google_generative_ai/)\nsupport documents like PDFs as inputs.\n\nThe gist of passing multimodal inputs to a chat model is to use content blocks that\nspecify a type and corresponding data. For example, to pass an image to a chat model\nas URL:\n\n```python\nfrom langchain_core.messages import HumanMessage\n\nmessage = HumanMessage(\n    content=[\n        {"type": "text", "text": "Describe the weather in this image:"},\n        {\n            "type": "image",\n            "source_type": "url",\n            "url": "https://...",\n        },\n    ],\n)\nresponse = model.invoke([message])\n```\n\nWe can also pass the image as in-line data:\n\n# Chat models\n\n## Overview\n\nLarge Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.\n\nModern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.\n\nThe newest generation of chat models offer additional capabilities:\n\n#### Tools\n\nCurrently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.\n\nHowever, a chat model can easily interact with multimodal data by invoking tools with references (e.g., a URL) to the multimodal data, rather than the data itself. For example, any model capable of [tool calling](/docs/concepts/tool_calling) can be equipped with tools to download and process images, audio, or video.\n\n## Multimodality in embedding models\n\n:::info Prerequisites\n* [Embedding Models](/docs/concepts/embedding_models)\n:::\n\n**Embeddings** are vector representations of data used for tasks like similarity search and retrieval. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@7429d2380bf35ccefa54d63341272585217e14ca97165f70e737dd79cf8f086d¢tsËAÚöØ8I¿¨focus_msÍa§payload‚¤role©assistant§contentÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.ªfocus_kind¬exec_latency¨query_id¤Q070‰¢idÙ@db89ad84dcbc0fb6559358e44b69a5b262520cbd89a1a77c20d22997ac6d19f4¢tsËAÚöØ8_Ğ¨trace_idÙ$7c74f2b2-6cd3-4bc2-be42-0f5daa48d3e4­parent_run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13¦run_idÙ$7c74f2b2-6cd3-4bc2-be42-0f5daa48d3e4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.¨query_id¤Q070ªfocus_kind¶chain_execution_result‰¢idÙ@3c1a2703ac4fc8ec9bdc4c92a12080ce9172e8103753769751672b620145083d¢tsËAÚöØ8gw¨trace_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13­parent_run_idÀ¦run_idÙ$4dcce9f2-b89c-4ce1-bc76-ed9760704a13ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.¨query_id¤Q070ªfocus_kind¶chain_execution_result‹¢idÙ@f81664b18ca855c1b681a3b44147e20023ccc6e3cb7f653457b1b0cbe9984e78¢tsËAÚöØ8m¨trace_id¤Q071­parent_run_idÀ¦run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?¨query_id¤Q071§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q071ªfocus_kind¯chain_execution‹¢idÙ@3c1f79f0e91cfdba5bbbadef03d093fae3e859b94b8509631d20a7b46057eb67¢tsËAÚöØ8u¼¨trace_id¤Q071­parent_run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222¦run_idÙ$93610879-41c5-48de-8981-7002aa2e3a2eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context¦answer ¨query_id¤Q071¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q071®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:76c8f735-56e8-eaef-6137-99cd4f3ca1e4ªfocus_kind¯chain_execution‰¢idÙ@2e161cef714f4b250f7f858a190d60d1eef95decb97c037cabe050ed84142f66¢tsËAÚöØNuò¨trace_idÙ$93610879-41c5-48de-8981-7002aa2e3a2e­parent_run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222¦run_idÙ$93610879-41c5-48de-8981-7002aa2e3a2eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¨query_id¤Q071ªfocus_kind¶chain_execution_result‹¢idÙ@0ae40f17b65984b0b88572dd32f46aa00ba54f97f99ec7a42632dd8ce1731c02¢tsËAÚöØN€¨trace_id¤Q071­parent_run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222¦run_idÙ$be5b8890-2238-4947-b264-107cc7f031eeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¦answer ¨query_id¤Q071¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q071®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:51180623-49eb-cc0c-58a7-f8e9b79215c6ªfocus_kind¯chain_execution‹¢idÙ@ae64765c59e825d68771e9b9cf11971e1b7699648dc23285501bb1528524c9bc¢tsËAÚöØN…/¨trace_id¤Q071­parent_run_idÙ$be5b8890-2238-4947-b264-107cc7f031ee¦run_idÙ$0094e481-b581-4b84-ad2d-e2064184ec41ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§contextÚ‘If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                       | First prompt the LLM to ask a generic step-back question about higher-level concepts or principles, and retrieve relevant facts about them. Use this grounding to help answer the user question. [Paper](https://arxiv.org/pdf/2310.06117).                                            |
| [HyDE](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)          | If you have challenges retrieving relevant documents using the raw user inputs.                 | Use an LLM to convert questions into hypothetical documents that answer the question. Use the embedded hypothetical documents to retrieve real documents with the premise that doc-doc similarity search can produce more relevant matches. [Paper](https://arxiv.org/abs/2212.10496). |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q071®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:51180623-49eb-cc0c-58a7-f8e9b79215c6­checkpoint_nsÙ-generate:51180623-49eb-cc0c-58a7-f8e9b79215c6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@cc4b48506da71f22f3be78fb1f2b09f284f64fb06a48a06845eaafa1b8cea470¢tsËAÚöØN‹ƒ¨trace_idÙ$0094e481-b581-4b84-ad2d-e2064184ec41­parent_run_idÙ$be5b8890-2238-4947-b264-107cc7f031ee¦run_idÙ$0094e481-b581-4b84-ad2d-e2064184ec41ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚJmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What two steps are recommended to recover from ratelimiting errors? \nContext: If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\nYou have a few options to deal with rate limits:\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                       | First prompt the LLM to ask a generic step-back question about higher-level concepts or principles, and retrieve relevant facts about them. Use this grounding to help answer the user question. [Paper](https://arxiv.org/pdf/2310.06117).                                            |\n| [HyDE](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)          | If you have challenges retrieving relevant documents using the raw user inputs.                 | Use an LLM to convert questions into hypothetical documents that answer the question. Use the embedded hypothetical documents to retrieve real documents with the premise that doc-doc similarity search can produce more relevant matches. [Paper](https://arxiv.org/abs/2212.10496). | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@121a649b6cfe76504dcbe3f6131e4e84c38702fc06da07f35cc72b23cbeadf21¢tsËAÚöØ€Cé¨focus_msÍ§payload‚¤role©assistant§contentÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.ªfocus_kind¬exec_latency¨query_id¤Q071‰¢idÙ@4b8cc39acda7e2abdc13b7c94f5085b38d8abad999245f8d15908c673e8a2dd9¢tsËAÚöØ€U?¨trace_idÙ$be5b8890-2238-4947-b264-107cc7f031ee­parent_run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222¦run_idÙ$be5b8890-2238-4947-b264-107cc7f031eeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.¨query_id¤Q071ªfocus_kind¶chain_execution_result‰¢idÙ@7334c93198bdb67d1318bd74f59378b285b9606bfc7c68b9378b15ca099f9ae3¢tsËAÚöØ€^Ä¨trace_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222­parent_run_idÀ¦run_idÙ$e754fab7-99a4-4e9d-a8e9-2342ec5c8222ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¦answerÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.¨query_id¤Q071ªfocus_kind¶chain_execution_result‹¢idÙ@f1472443b153fe53584dc94fbd7dfe0dffee981ef3dad4cc143d74c9f7e28928¢tsËAÚöØ€g(¨trace_id¤Q072­parent_run_idÀ¦run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?¨query_id¤Q072§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q072ªfocus_kind¯chain_execution‹¢idÙ@e4e3a6b6635d712fb4866ea7ad329ca1bef12a1490b42a4f216487ad3364582a¢tsËAÚöØ€z¦¨trace_id¤Q072­parent_run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188¦run_idÙ$602110de-e7d5-4093-9bab-6baaa0644cc3ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context¦answer ¨query_id¤Q072¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q072®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:fd70521b-c23e-5fe3-4264-c5641c8541c5ªfocus_kind¯chain_execution‰¢idÙ@cd7f3f7829ed434af93f6df98084ecdea9ef3249bc2b1b839f528e95da00cf62¢tsËAÚöØŒV¹¨trace_idÙ$602110de-e7d5-4093-9bab-6baaa0644cc3­parent_run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188¦run_idÙ$602110de-e7d5-4093-9bab-6baaa0644cc3ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q072ªfocus_kind¶chain_execution_result‹¢idÙ@7ae34c5e9d60f3a8636317242307ece2ea369caf41715ed1f44687589097db7f¢tsËAÚöØŒ^¦¨trace_id¤Q072­parent_run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188¦run_idÙ$c1bb0fd2-c459-4680-ad10-30178e354f04ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q072¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q072®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:4529b8c3-98f5-25e4-a0b2-67ab5af11bbfªfocus_kind¯chain_execution‹¢idÙ@a67a37a7ab10b03e442c9f527c53ba114e6ce100d9ce032d595731a764a5b944¢tsËAÚöØŒc=¨trace_id¤Q072­parent_run_idÙ$c1bb0fd2-c459-4680-ad10-30178e354f04¦run_idÙ$d514c249-9c58-4758-aa3e-b54288680aadªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§contextÚò## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).

- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline's progress.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.



### `astream_events`
<span data-heading-keywords="astream_events,stream_events,stream events"></span>

:::tip
Use the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). 

While this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.
:::

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q072®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:4529b8c3-98f5-25e4-a0b2-67ab5af11bbf­checkpoint_nsÙ-generate:4529b8c3-98f5-25e4-a0b2-67ab5af11bbf¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@2e90687f48a0668da0ccab4f4e051b4fb78a735d43ed1a5fbb166e483b4acd57¢tsËAÚöØŒi¨trace_idÙ$d514c249-9c58-4758-aa3e-b54288680aad­parent_run_idÙ$c1bb0fd2-c459-4680-ad10-30178e354f04¦run_idÙ$d514c249-9c58-4758-aa3e-b54288680aadªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÌmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which parameter allows a Runnable to stream events as JSON for UIs? \nContext: ## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n## Streaming APIs\n\nLangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).\n\n- **In LCEL Pipelines:**\nStreaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline\'s progress.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\n#### Usage with LCEL\n\nIf you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.\n\n\n\n### `astream_events`\n<span data-heading-keywords="astream_events,stream_events,stream events"></span>\n\n:::tip\nUse the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). \n\nWhile this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.\n:::\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@9b4293537d1ecaf1ac3c1c21e493f0b0565d5ec8d0476e6bca9a126a067eb4d2¢tsËAÚöÙFğ4¨focus_msÍb§payload‚¤role©assistant§contentÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.ªfocus_kind¬exec_latency¨query_id¤Q072‰¢idÙ@f97cc4734c7403d71bae644b8d51962e0117938b133c12f0fdaa9f214e323e2c¢tsËAÚöÙGW¨trace_idÙ$c1bb0fd2-c459-4680-ad10-30178e354f04­parent_run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188¦run_idÙ$c1bb0fd2-c459-4680-ad10-30178e354f04ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.¨query_id¤Q072ªfocus_kind¶chain_execution_result‰¢idÙ@6e436876eb369070f7eff5394ee9e80f379ee511388c1660588f77faa9551026¢tsËAÚöÙG"¨trace_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188­parent_run_idÀ¦run_idÙ$e842a8be-a39d-4269-a94b-51ad9c73e188ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.¨query_id¤Q072ªfocus_kind¶chain_execution_result‹¢idÙ@0c0dc0032d0f3e84e3a44543bbc2ae108bb616502befa03f0d5ce187e093eccc¢tsËAÚöÙG%¨trace_id¤Q073­parent_run_idÀ¦run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.¨query_id¤Q073§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q073ªfocus_kind¯chain_execution‹¢idÙ@cb2123d4abe0bf382dd4cab92e0af68c854c3f30cb52fecfbee77e3fdf62a4e4¢tsËAÚöÙG6Æ¨trace_id¤Q073­parent_run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413¦run_idÙ$805e791c-efb1-48aa-8ee7-918620c5898cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context¦answer ¨query_id¤Q073¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q073®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:a72382eb-579f-3a64-3f9d-7ff90309baaaªfocus_kind¯chain_execution‰¢idÙ@2031acdf858ea2fce5ca529988727428e7042a219a99a702634b41643cb62da0¢tsËAÚöÙWy¨trace_idÙ$805e791c-efb1-48aa-8ee7-918620c5898c­parent_run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413¦run_idÙ$805e791c-efb1-48aa-8ee7-918620c5898cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q073ªfocus_kind¶chain_execution_result‹¢idÙ@34fe5e3baf8c25cc85a09b80fc6c9e45560f9a99a5bda49539bff5c860913d06¢tsËAÚöÙW0¨trace_id¤Q073­parent_run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413¦run_idÙ$e76735be-44d8-4666-992a-564cf7da611eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q073¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q073®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:73db7662-1730-ec00-94e3-cc9293b49228ªfocus_kind¯chain_execution‹¢idÙ@992ecf6f7d945a98b408b1ef86cca310d21aaef85ea02043d8345282451450c2¢tsËAÚöÙW/¨trace_id¤Q073­parent_run_idÙ$e76735be-44d8-4666-992a-564cf7da611e¦run_idÙ$b4d2c0e9-58b6-4166-8486-3d66fdd2fac1ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§contextÚ# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html)

:::

:::info[Note]
This conceptual overview focuses on text-based embedding models.

Embedding models can also be [multimodal](/docs/concepts/multimodality) though such models are not currently supported by LangChain.
:::

# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.

Embeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.

- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategies for documents (which are to be searched) versus queries (the search input itself).
To illustrate, here's a practical example using LangChain's `.embed_documents` method to embed a list of strings:

```python
from langchain_openai import OpenAIEmbeddings
embeddings_model = OpenAIEmbeddings()
embeddings = embeddings_model.embed_documents(
    [
        "Hi there!",
        "Oh, hello!",
        "What's your name?",
        "My friends call me World",
        "Hello World!"
    ]
)
len(embeddings), len(embeddings[0])
(5, 1536)
```

For convenience, you can also use the `embed_query` method to embed a single text:

```python
query_embedding = embeddings_model.embed_query("What is the meaning of life?")
```

:::info[Further reading]

<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embeddings = embeddings_model.embed_documents(
    [
        "Hi there!",
        "Oh, hello!",
        "What's your name?",
        "My friends call me World",
        "Hello World!"
    ]
)
len(embeddings), len(embeddings[0])
```

```output
(5, 1536)
```


### `embed_query`
#### Embed single query
Use `.embed_query` to embed a single piece of text (e.g., for the purpose of comparing to other embedded pieces of texts).

```python
embedded_query = embeddings_model.embed_query("What was the name mentioned in the conversation?")
embedded_query[:5]
```

```output
[0.0053587136790156364,
 -0.0004999046213924885,
 0.038883671164512634,
 -0.003001077566295862,
 -0.00900818221271038]
```

```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url", "image_url": {"url": image_url}},
    ],
)
response = model.invoke([message])
```

Otherwise, chat models will typically accept the native, provider-specific content
block format. See [chat model integrations](/docs/integrations/chat/) for detail
on specific providers.


#### Outputs

Some chat models support multimodal outputs, such as images and audio. Multimodal
outputs will appear as part of the [AIMessage](/docs/concepts/messages/#aimessage)
response object. See for example:

- Generating [audio outputs](/docs/integrations/chat/openai/#audio-generation-preview) with OpenAI;
- Generating [image outputs](/docs/integrations/chat/google_generative_ai/#multimodal-usage) with Google Gemini.

#### Tools¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q073®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:73db7662-1730-ec00-94e3-cc9293b49228­checkpoint_nsÙ-generate:73db7662-1730-ec00-94e3-cc9293b49228¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@0dec730f6cf40175434668f6f151d8da15863c6545fa2a3049fa5da65a390e1c¢tsËAÚöÙWÎ¨trace_idÙ$b4d2c0e9-58b6-4166-8486-3d66fdd2fac1­parent_run_idÙ$e76735be-44d8-4666-992a-564cf7da611e¦run_idÙ$b4d2c0e9-58b6-4166-8486-3d66fdd2fac1ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ.messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Provide a code snippet to embed text with a local HuggingFace model. \nContext: # Embedding models\n<span data-heading-keywords="embedding,embeddings"></span>\n\n:::info[Prerequisites]\n\n* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html)\n\n:::\n\n:::info[Note]\nThis conceptual overview focuses on text-based embedding models.\n\nEmbedding models can also be [multimodal](/docs/concepts/multimodality) though such models are not currently supported by LangChain.\n:::\n\n# Text embedding models\n\n:::info\nHead to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.\n:::\n\nThe Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.\n\nEmbeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.\n\n- `embed_documents`: For embedding multiple texts (documents)\n- `embed_query`: For embedding a single text (query)\n\nThis distinction is important, as some providers employ different embedding strategies for documents (which are to be searched) versus queries (the search input itself).\nTo illustrate, here\'s a practical example using LangChain\'s `.embed_documents` method to embed a list of strings:\n\n```python\nfrom langchain_openai import OpenAIEmbeddings\nembeddings_model = OpenAIEmbeddings()\nembeddings = embeddings_model.embed_documents(\n    [\n        "Hi there!",\n        "Oh, hello!",\n        "What\'s your name?",\n        "My friends call me World",\n        "Hello World!"\n    ]\n)\nlen(embeddings), len(embeddings[0])\n(5, 1536)\n```\n\nFor convenience, you can also use the `embed_query` method to embed a single text:\n\n```python\nquery_embedding = embeddings_model.embed_query("What is the meaning of life?")\n```\n\n:::info[Further reading]\n\n<EmbeddingTabs customVarName="embeddings_model" />\n\n### `embed_documents`\n#### Embed list of texts\n\nUse `.embed_documents` to embed a list of strings, recovering a list of embeddings:\n\n```python\nembeddings = embeddings_model.embed_documents(\n    [\n        "Hi there!",\n        "Oh, hello!",\n        "What\'s your name?",\n        "My friends call me World",\n        "Hello World!"\n    ]\n)\nlen(embeddings), len(embeddings[0])\n```\n\n```output\n(5, 1536)\n```\n\n\n### `embed_query`\n#### Embed single query\nUse `.embed_query` to embed a single piece of text (e.g., for the purpose of comparing to other embedded pieces of texts).\n\n```python\nembedded_query = embeddings_model.embed_query("What was the name mentioned in the conversation?")\nembedded_query[:5]\n```\n\n```output\n[0.0053587136790156364,\n -0.0004999046213924885,\n 0.038883671164512634,\n -0.003001077566295862,\n -0.00900818221271038]\n```\n\n```python\nfrom langchain_core.messages import HumanMessage\n\nmessage = HumanMessage(\n    content=[\n        {"type": "text", "text": "Describe the weather in this image:"},\n        {"type": "image_url", "image_url": {"url": image_url}},\n    ],\n)\nresponse = model.invoke([message])\n```\n\nOtherwise, chat models will typically accept the native, provider-specific content\nblock format. See [chat model integrations](/docs/integrations/chat/) for detail\non specific providers.\n\n\n#### Outputs\n\nSome chat models support multimodal outputs, such as images and audio. Multimodal\noutputs will appear as part of the [AIMessage](/docs/concepts/messages/#aimessage)\nresponse object. See for example:\n\n- Generating [audio outputs](/docs/integrations/chat/openai/#audio-generation-preview) with OpenAI;\n- Generating [image outputs](/docs/integrations/chat/google_generative_ai/#multimodal-usage) with Google Gemini.\n\n#### Tools \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@16d5f293bfb1770d3c60da7696539b285cc248050f4088868ce5792289f0228e¢tsËAÚöÙÅ©Î¨focus_msÍ¾§payload‚¤role©assistant§contentÚYTo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Hello, world!", "How are you?"])
```

This will create embeddings for the provided list of strings.ªfocus_kind¬exec_latency¨query_id¤Q073‰¢idÙ@ffdff3c49d092debe6e95f36885842ecf4b87a7a10fae5c1f661daea7a0a195e¢tsËAÚöÙÅ¶š¨trace_idÙ$e76735be-44d8-4666-992a-564cf7da611e­parent_run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413¦run_idÙ$e76735be-44d8-4666-992a-564cf7da611eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚYTo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Hello, world!", "How are you?"])
```

This will create embeddings for the provided list of strings.¨query_id¤Q073ªfocus_kind¶chain_execution_result‰¢idÙ@4bdebfd0abad93f262e6168aa1e37fad67dbb311737be27f1a70811f26b0d798¢tsËAÚöÙÅÀn¨trace_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413­parent_run_idÀ¦run_idÙ$c0df6035-7dc2-433f-824a-9dab16a44413ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÚYTo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Hello, world!", "How are you?"])
```

This will create embeddings for the provided list of strings.¨query_id¤Q073ªfocus_kind¶chain_execution_result‹¢idÙ@933744f12985ae21e2e329368e49ba9901a4b158e2192119f6e02ad4038affc4¢tsËAÚöÙÅÊš¨trace_id¤Q074­parent_run_idÀ¦run_idÙ$1b695821-1a03-430d-af62-e7a635afc647ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?¨query_id¤Q074§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q074ªfocus_kind¯chain_execution‹¢idÙ@2354ef97a8cfda8b60c09496f6c98306bdbfcb34b148e568c1bb695aff08b180¢tsËAÚöÙÅÔ¨trace_id¤Q074­parent_run_idÙ$1b695821-1a03-430d-af62-e7a635afc647¦run_idÙ$6e05a6e9-58c3-4759-a3b6-3a98720d682bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context¦answer ¨query_id¤Q074¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q074®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:24754bd5-eed9-1ee1-1db0-0f19a0d61a26ªfocus_kind¯chain_execution‰¢idÙ@9aa78d812f66c24cc19fad5b859398e0c5a2e4209727e6dbe48fdc512dc892ee¢tsËAÚöÙÓÍ6¨trace_idÙ$6e05a6e9-58c3-4759-a3b6-3a98720d682b­parent_run_idÙ$1b695821-1a03-430d-af62-e7a635afc647¦run_idÙ$6e05a6e9-58c3-4759-a3b6-3a98720d682bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q074ªfocus_kind¶chain_execution_result‹¢idÙ@d5ff5299e3051c398c2d4dc6d23e4235bbd626193de11a1d80f83420e2c20dde¢tsËAÚöÙÓÖA¨trace_id¤Q074­parent_run_idÙ$1b695821-1a03-430d-af62-e7a635afc647¦run_idÙ$42ed6d52-1f49-4758-9b0d-326892ff9da2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q074¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q074®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:688e02bb-c111-66ab-003c-bbd66528ecd4ªfocus_kind¯chain_execution‹¢idÙ@8c9e1016e87e4ac58c6d9d9dfe49d0338de9388e50378f4a033a7be6f6ce5475¢tsËAÚöÙÓÛ©¨trace_id¤Q074­parent_run_idÙ$42ed6d52-1f49-4758-9b0d-326892ff9da2¦run_idÙ$6b133bb7-ad9a-4061-a7ca-b1fdf93627deªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§contextÚº![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small chunk size for indexing documents in a vectorstore. 
If you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. 

LangChain has two different retrievers that can be used to address this challenge. 
The [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. 
The [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we combine search results from many retrievers? 
This motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).

### Source document retention 

Many retrievers utilize some kind of index to make documents easily searchable.
The process of indexing can include a transformation step (e.g., vectorstores often use document splitting). 
Whatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.

![Retrieval with full docs](/img/retriever_full_docs.png)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q074®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:688e02bb-c111-66ab-003c-bbd66528ecd4­checkpoint_nsÙ-generate:688e02bb-c111-66ab-003c-bbd66528ecd4¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@65ae1f92ed40d35932387cf91c114299315b31f7f47160b6910442e63d70712e¢tsËAÚöÙÓâ¨trace_idÙ$6b133bb7-ad9a-4061-a7ca-b1fdf93627de­parent_run_idÙ$42ed6d52-1f49-4758-9b0d-326892ff9da2¦run_idÙ$6b133bb7-ad9a-4061-a7ca-b1fdf93627deªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¢messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How does the `ContextualCompressionRetriever` reduce context windows? \nContext: ![Retrieval with full docs](/img/retriever_full_docs.png)\n\nThis is particularly useful in AI applications, because it ensures no loss in document context for the model.\nFor example, you may use small chunk size for indexing documents in a vectorstore. \nIf you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. \n\nLangChain has two different retrievers that can be used to address this challenge. \nThe [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. \nThe [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\nWhen ensembling, how do we combine search results from many retrievers? \nThis motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).\n\n### Source document retention \n\nMany retrievers utilize some kind of index to make documents easily searchable.\nThe process of indexing can include a transformation step (e.g., vectorstores often use document splitting). \nWhatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.\n\n![Retrieval with full docs](/img/retriever_full_docs.png) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@abe9b05750c6f138ccc8910cfa7e127a607a563b49847cfc7eca875dc51fbd36¢tsËAÚöÚX ¨focus_msÍ§payload‚¤role©assistant§contentÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.ªfocus_kind¬exec_latency¨query_id¤Q074‰¢idÙ@55dbe1aa803ce7002c4ebe1a39fce88ea8207925fdf2e3f2529ae8645df84bc5¢tsËAÚöÚX4ù¨trace_idÙ$42ed6d52-1f49-4758-9b0d-326892ff9da2­parent_run_idÙ$1b695821-1a03-430d-af62-e7a635afc647¦run_idÙ$42ed6d52-1f49-4758-9b0d-326892ff9da2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.¨query_id¤Q074ªfocus_kind¶chain_execution_result‰¢idÙ@f057ede181df79722608275da32dc22ad2f8430e6e86315c4e48a6982ee7f851¢tsËAÚöÚX>¸¨trace_idÙ$1b695821-1a03-430d-af62-e7a635afc647­parent_run_idÀ¦run_idÙ$1b695821-1a03-430d-af62-e7a635afc647ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.¨query_id¤Q074ªfocus_kind¶chain_execution_result‹¢idÙ@551b5a237b5641044c3aa850571538135cd16cf6db720404628700348e67ed01¢tsËAÚöÚXG¢¨trace_id¤Q075­parent_run_idÀ¦run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?¨query_id¤Q075§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q075ªfocus_kind¯chain_execution‹¢idÙ@5cf4f9ca0af900db0891307cf94d372b08419169e431848147b48dd29a5c8b07¢tsËAÚöÚX[À¨trace_id¤Q075­parent_run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048¦run_idÙ$f4fa16b3-4e16-4c7d-b5f7-1d901bc2ae0dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context¦answer ¨query_id¤Q075¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q075®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:15a06de3-4053-6dc4-9be9-266d8e06c637ªfocus_kind¯chain_execution‰¢idÙ@97cf67e4e27d7909e595b0c496973b1c3cea97f01aa59717e8211b51cdd53689¢tsËAÚöÚl†¡¨trace_idÙ$f4fa16b3-4e16-4c7d-b5f7-1d901bc2ae0d­parent_run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048¦run_idÙ$f4fa16b3-4e16-4c7d-b5f7-1d901bc2ae0dªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q075ªfocus_kind¶chain_execution_result‹¢idÙ@138405a817bca71283539aedaafa52a8a66f841ac9a26ba6991e46a82d3681c5¢tsËAÚöÚl˜š¨trace_id¤Q075­parent_run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048¦run_idÙ$905ce197-707f-471f-957e-c26308e0af8dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q075¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q075®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f8d41f6d-ab50-85d9-7775-0a865ea9045aªfocus_kind¯chain_execution‹¢idÙ@ad2eb0d4159c7a62b510a7fb9cddf615b2f810482652ea2fa6ad78a5d8e40f16¢tsËAÚöÚlŸ²¨trace_id¤Q075­parent_run_idÙ$905ce197-707f-471f-957e-c26308e0af8d¦run_idÙ$d1fa6bd6-8444-4fdc-9728-2000ef24888bªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§contextÚIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check out [the relevant how-to guides](/docs/how_to/#langchain-expression-language-lcel).

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.
* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.

See the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)

Refer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble LangChain components into full-featured applications.

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q075®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f8d41f6d-ab50-85d9-7775-0a865ea9045a­checkpoint_nsÙ-generate:f8d41f6d-ab50-85d9-7775-0a865ea9045a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@ba93cec753906724b2af45ceb3c1cfd792992b2c721dd2644c950b2729fb33c4¢tsËAÚöÚl¬~¨trace_idÙ$d1fa6bd6-8444-4fdc-9728-2000ef24888b­parent_run_idÙ$905ce197-707f-471f-957e-c26308e0af8d¦run_idÙ$d1fa6bd6-8444-4fdc-9728-2000ef24888bªevent_type¬chain_output¬event_source¥chain§payload§outputsÚúmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What guide should you consult for configuring runtime chain internals like temperature? \nContext: If you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).\n\nFor guides on how to do specific tasks with LCEL, check out [the relevant how-to guides](/docs/how_to/#langchain-expression-language-lcel).\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.\n* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.\n\nSee the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph)\n\nRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.\n\n## Orchestration\n\nGet started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble LangChain components into full-featured applications.\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@50c7f641b07981a5d30256f2da914dc7bde78357febb7008c64887536063b117¢tsËAÚöÚµEF¨focus_msÍn§payload‚¤role©assistant§contentÙåYou should consult the guide titled "How to configure runtime chain internals" for configuring runtime chain internals like temperature. This guide provides detailed information on how to adjust specific attributes in a Runnable.ªfocus_kind¬exec_latency¨query_id¤Q075‰¢idÙ@abd97f650109230a91fe3b3e4c38843b84c3b1e4d939f1e1b2f1df19db756eb1¢tsËAÚöÚµRŸ¨trace_idÙ$905ce197-707f-471f-957e-c26308e0af8d­parent_run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048¦run_idÙ$905ce197-707f-471f-957e-c26308e0af8dªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙåYou should consult the guide titled "How to configure runtime chain internals" for configuring runtime chain internals like temperature. This guide provides detailed information on how to adjust specific attributes in a Runnable.¨query_id¤Q075ªfocus_kind¶chain_execution_result‰¢idÙ@4f14302e113153f2efbb7a249c436b812f201519eb77ebd90eaf54bdc1b94002¢tsËAÚöÚµY“¨trace_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048­parent_run_idÀ¦run_idÙ$b705a8af-8cc0-4b33-85f2-1af909244048ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÙåYou should consult the guide titled "How to configure runtime chain internals" for configuring runtime chain internals like temperature. This guide provides detailed information on how to adjust specific attributes in a Runnable.¨query_id¤Q075ªfocus_kind¶chain_execution_result‹¢idÙ@b52e3869965f5e7c71abb5a65e59c480edb3fba407badaef331154353d29d609¢tsËAÚöÚµ_¨trace_id¤Q076­parent_run_idÀ¦run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?¨query_id¤Q076§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q076ªfocus_kind¯chain_execution‹¢idÙ@04dfa8027d61b710026b8b03396e0ede9ea15665c3243032dfaabab44671dfdb¢tsËAÚöÚµi”¨trace_id¤Q076­parent_run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76¦run_idÙ$f078d897-ed73-4112-98d0-7aece8be9f63ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context¦answer ¨query_id¤Q076¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q076®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:75b29298-8edb-3c51-7065-0c66c3d391fbªfocus_kind¯chain_execution‰¢idÙ@68fa1d91df514fa848a371e9b77fa9d4bf681fc4b57c47b513aa854f222e665e¢tsËAÚöÚÏ¨trace_idÙ$f078d897-ed73-4112-98d0-7aece8be9f63­parent_run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76¦run_idÙ$f078d897-ed73-4112-98d0-7aece8be9f63ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¨query_id¤Q076ªfocus_kind¶chain_execution_result‹¢idÙ@7e14edcdc6085181e11505a59d24e37d39e36750fd0cd4d921602b8da010bc17¢tsËAÚöÚÏ¨“¨trace_id¤Q076­parent_run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76¦run_idÙ$43b7c4da-a2c5-4e2b-ad54-441626079314ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¦answer ¨query_id¤Q076¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q076®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:af0bb77a-4974-b2e6-b67f-26147d94b0d7ªfocus_kind¯chain_execution‹¢idÙ@f48f0eee63b851d40cadd8b021defdccd2cefeb647270f2e8d3b50d7cd6089ea¢tsËAÚöÚÏ®¬¨trace_id¤Q076­parent_run_idÙ$43b7c4da-a2c5-4e2b-ad54-441626079314¦run_idÙ$93a5b573-ecd8-4c54-b662-c9028f12bb09ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§contextÚ| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeVectorStore.max_marginal_relevance_search) | When needing to diversify search results.             | MMR attempts to diversify the results of a search to avoid returning similar and redundant documents.                                        |

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs/how_to/example_selectors)
- [How to: select examples by length](/docs/how_to/example_selectors_length_based)
- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)
- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)
- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)
- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).

This gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.
Sometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.

**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.

## Related resources

* [Example selector how-to guides](/docs/how_to/#example-selectors)

At a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's responses are used as examples for a worse (presumably cheaper/faster) model.
- User feedback: users (or labelers) leave feedback on interactions with the application and examples are generated based on that feedback (for example, all interactions with positive feedback could be turned into examples).
- LLM feedback: same as user feedback but the process is automated by having models evaluate themselves.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q076®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:af0bb77a-4974-b2e6-b67f-26147d94b0d7­checkpoint_nsÙ-generate:af0bb77a-4974-b2e6-b67f-26147d94b0d7¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@7550d6ba1299f7d09e9dba770495b075fe18d5234497f1a12669d7f03225388e¢tsËAÚöÚÏµt¨trace_idÙ$93a5b573-ecd8-4c54-b662-c9028f12bb09­parent_run_idÙ$43b7c4da-a2c5-4e2b-ad54-441626079314¦run_idÙ$93a5b573-ecd8-4c54-b662-c9028f12bb09ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚğmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which selector uses Maximal Marginal Relevance (MMR) to diversify examples? \nContext: | [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeVectorStore.max_marginal_relevance_search) | When needing to diversify search results.             | MMR attempts to diversify the results of a search to avoid returning similar and redundant documents.                                        |\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n### Example selectors\n\n[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.\n\n- [How to: use example selectors](/docs/how_to/example_selectors)\n- [How to: select examples by length](/docs/how_to/example_selectors_length_based)\n- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)\n- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)\n- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)\n- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n# Example selectors\n\n:::note Prerequisites\n\n- [Chat models](/docs/concepts/chat_models/)\n- [Few-shot prompting](/docs/concepts/few_shot_prompting/)\n:::\n\n## Overview\n\nOne common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).\n\nThis gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.\nSometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.\n\n**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.\n\n## Related resources\n\n* [Example selector how-to guides](/docs/how_to/#example-selectors)\n\nAt a high-level, the basic ways to generate examples are:\n- Manual: a person/people generates examples they think are useful.\n- Better model: a better (presumably more expensive/slower) model's responses are used as examples for a worse (presumably cheaper/faster) model.\n- User feedback: users (or labelers) leave feedback on interactions with the application and examples are generated based on that feedback (for example, all interactions with positive feedback could be turned into examples).\n- LLM feedback: same as user feedback but the process is automated by having models evaluate themselves. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ccafd2ad56d8b253707d07a9bc6efe53bf584065649bc68dca34b2fe47ffe626¢tsËAÚöÛ¦s¨focus_msÍ§payload‚¤role©assistant§contentÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.ªfocus_kind¬exec_latency¨query_id¤Q076‰¢idÙ@2dc4ae178b791d48238a0bb9ca88e040839979ae4173068830eb056af1034413¢tsËAÚöÛ¦Ï¨trace_idÙ$43b7c4da-a2c5-4e2b-ad54-441626079314­parent_run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76¦run_idÙ$43b7c4da-a2c5-4e2b-ad54-441626079314ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.¨query_id¤Q076ªfocus_kind¶chain_execution_result‰¢idÙ@ff1b1d0fc9ebb125e67472f947ecb649d63623b864162461e9a7c49d46cdb413¢tsËAÚöÛ¦âd¨trace_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76­parent_run_idÀ¦run_idÙ$45b1e9e4-5583-483f-9bf5-f869b6e03f76ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¦answerÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.¨query_id¤Q076ªfocus_kind¶chain_execution_result‹¢idÙ@c099961ee93e66eebab88d1786aed406d4ca7df3f21d3ec58c268ab9e0f97815¢tsËAÚöÛ¦ïÃ¨trace_id¤Q077­parent_run_idÀ¦run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?¨query_id¤Q077§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q077ªfocus_kind¯chain_execution‹¢idÙ@493a09ae31eae991bc513e9dc5d1e178db6438f31a5cb933cf58fb9a706f7aaa¢tsËAÚöÛ§6P¨trace_id¤Q077­parent_run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9¦run_idÙ$2c7df9f0-4578-48ca-b07b-9d9be099792aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context¦answer ¨query_id¤Q077¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q077®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:858d97e6-172e-4242-6509-038c213390f1ªfocus_kind¯chain_execution‰¢idÙ@f605e4069e6ec0e10ff13cac333c9d39ce95ddb7c2b6f10996b6bd1e436aca32¢tsËAÚöÛ¼o3¨trace_idÙ$2c7df9f0-4578-48ca-b07b-9d9be099792a­parent_run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9¦run_idÙ$2c7df9f0-4578-48ca-b07b-9d9be099792aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q077ªfocus_kind¶chain_execution_result‹¢idÙ@b7fb705754f2eaea02286005b4a82293f62a1a556857c4de54ea8183e86c5581¢tsËAÚöÛ¼wæ¨trace_id¤Q077­parent_run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9¦run_idÙ$75bc90d4-5aa6-4d67-a180-eda6721444baªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q077¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q077®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:41e90cea-b0eb-972d-ce46-8be9031d3519ªfocus_kind¯chain_execution‹¢idÙ@d7e43337130070d11a92370399a38da04bb7ba4273183afbfe724c7b0f42821e¢tsËAÚöÛ¼{í¨trace_id¤Q077­parent_run_idÙ$75bc90d4-5aa6-4d67-a180-eda6721444ba¦run_idÙ$96b7efec-f7aa-4c03-aef1-36a9aeded860ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§contextÚû### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, tool calling involves binding a tool to a model and, when appropriate, the model can *decide* to call this tool and ensure its response conforms to the tool's schema.
With this in mind, the central concept is straightforward: *simply bind our schema to a model as a tool!*
Here is an example using the `ResponseFormatter` schema defined above:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o", temperature=0)
# Bind responseformatter schema as a tool to the model
model_with_tools = model.bind_tools([ResponseFormatter])
# Invoke the model
ai_msg = model_with_tools.invoke("What is the powerhouse of the cell?")
```

# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.
But what about cases where we want a model to also interact *directly* with systems, such as databases or an API?
These systems often have a particular input schema; for example, APIs frequently have a required payload structure.
This need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.

:::info
You will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. 
:::

![Conceptual overview of tool calling](/img/tool_calling_concept.png)

## Key concepts

### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/)), that allows a developer to request model responses that match a particular schema.
The APIs for each provider differ. 
LangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to bind [tools](/docs/concepts/tools) to a model in order to support [tool calling](/docs/concepts/tool_calling/):

```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSON output.
You can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).
Here is an example of how to use JSON mode with OpenAI:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")
ai_msg = model.invoke("Return a JSON object with key 'random_ints' and a value of 10 random ints in [0-99]")
ai_msg
{'random_ints': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}
```

## Structured output method 

There are a few challenges when producing structured output with the above methods: 

(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.

Some important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can't be supported on these.
- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they're not enforced on models in `langchain-community`.

Chat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.

## Tool calling

Chat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please
see the [tool calling](/docs/concepts/tool_calling) guide for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q077®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:41e90cea-b0eb-972d-ce46-8be9031d3519­checkpoint_nsÙ-generate:41e90cea-b0eb-972d-ce46-8be9031d3519¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@2c5964bdb57074af975230b1e10299b4634decc8b4c14d92f6555074417c9eee¢tsËAÚöÛ¼Ì¨trace_idÙ$96b7efec-f7aa-4c03-aef1-36a9aeded860­parent_run_idÙ$75bc90d4-5aa6-4d67-a180-eda6721444ba¦run_idÙ$96b7efec-f7aa-4c03-aef1-36a9aeded860ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the recommended way to expose tool schemas to chat models that use OpenAI function calling? \nContext: ### Using tool calling\n\nMany [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).\nIn short, tool calling involves binding a tool to a model and, when appropriate, the model can *decide* to call this tool and ensure its response conforms to the tool\'s schema.\nWith this in mind, the central concept is straightforward: *simply bind our schema to a model as a tool!*\nHere is an example using the `ResponseFormatter` schema defined above:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o", temperature=0)\n# Bind responseformatter schema as a tool to the model\nmodel_with_tools = model.bind_tools([ResponseFormatter])\n# Invoke the model\nai_msg = model_with_tools.invoke("What is the powerhouse of the cell?")\n```\n\n# Tool calling\n\n:::info[Prerequisites]\n* [Tools](/docs/concepts/tools)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n\n## Overview \n\nMany AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.\nBut what about cases where we want a model to also interact *directly* with systems, such as databases or an API?\nThese systems often have a particular input schema; for example, APIs frequently have a required payload structure.\nThis need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.\n\n:::info\nYou will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. \n:::\n\n![Conceptual overview of tool calling](/img/tool_calling_concept.png)\n\n## Key concepts\n\n### Example: chat models \n\nMany [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/)), that allows a developer to request model responses that match a particular schema.\nThe APIs for each provider differ. \nLangChain\'s [chat model](/docs/concepts/chat_models/) interface provides a common way to bind [tools](/docs/concepts/tools) to a model in order to support [tool calling](/docs/concepts/tool_calling/):\n\n```python\n# Tool creation\ntools = [my_tool]\n# Tool binding\nmodel_with_tools = model.bind_tools(tools)\n```\n\n### JSON mode\n\nIn addition to tool calling, some model providers support a feature called `JSON mode`. \nThis supports JSON schema definition as input and enforces the model to produce a conforming JSON output.\nYou can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).\nHere is an example of how to use JSON mode with OpenAI:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")\nai_msg = model.invoke("Return a JSON object with key \'random_ints\' and a value of 10 random ints in [0-99]")\nai_msg\n{\'random_ints\': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}\n```\n\n## Structured output method \n\nThere are a few challenges when producing structured output with the above methods: \n\n(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.\n\nSome important things to note:\n\n- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can\'t be supported on these.\n- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they\'re not enforced on models in `langchain-community`.\n\nChat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.\n\n## Tool calling\n\nChat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please\nsee the [tool calling](/docs/concepts/tool_calling) guide for more information. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@8efc3b0795eed37bd533e90e7f3d8074c247d11f1e288c0a6a8d6513ae47ce75¢tsËAÚöÜDšg¨focus_msÍN§payload‚¤role©assistant§contentÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.ªfocus_kind¬exec_latency¨query_id¤Q077‰¢idÙ@3cec4e47ce203a9c462702ae8014d685bae2c562efd81a01360bae92489036aa¢tsËAÚöÜD®d¨trace_idÙ$75bc90d4-5aa6-4d67-a180-eda6721444ba­parent_run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9¦run_idÙ$75bc90d4-5aa6-4d67-a180-eda6721444baªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.¨query_id¤Q077ªfocus_kind¶chain_execution_result‰¢idÙ@2b132c19496f96420403d1a23805fad376606488c9dbf516be9f899621d5d9d0¢tsËAÚöÜD¸€¨trace_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9­parent_run_idÀ¦run_idÙ$e4665602-77a0-4c9d-95e0-0aae921a75d9ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.¨query_id¤Q077ªfocus_kind¶chain_execution_result‹¢idÙ@0bb91b2d785a562d8d85f14bd1474ba015513ad77549a436017797c346785151¢tsËAÚöÜDÁ	¨trace_id¤Q078­parent_run_idÀ¦run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.¨query_id¤Q078§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q078ªfocus_kind¯chain_execution‹¢idÙ@90c1e2cfbd9c1550375ae03ab355bf017546bcf51ff2fd5b0393054a3e046c33¢tsËAÚöÜDÎ«¨trace_id¤Q078­parent_run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772¦run_idÙ$d9a0894e-bf94-4f2e-a422-bfda6a5c1c40ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context¦answer ¨query_id¤Q078¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q078®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:4c5da566-df70-c278-92e9-10ef895ce9a6ªfocus_kind¯chain_execution‰¢idÙ@4630e1e68336ee9154ca131a6de81691a647025609c728ed8876ab938e53d195¢tsËAÚöÜQÄ¨trace_idÙ$d9a0894e-bf94-4f2e-a422-bfda6a5c1c40­parent_run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772¦run_idÙ$d9a0894e-bf94-4f2e-a422-bfda6a5c1c40ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q078ªfocus_kind¶chain_execution_result‹¢idÙ@58cab5e7f736d0ded2e2e08cc409dc1614f9851bd8c9da1791c38ce41018d8aa¢tsËAÚöÜQÌ¨trace_id¤Q078­parent_run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772¦run_idÙ$a78f7d50-e15f-4cbc-8bec-b02a14133a2fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q078¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q078®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5ef1cca0-2c65-07f3-0cf1-c77bcacae431ªfocus_kind¯chain_execution‹¢idÙ@7dcb8673f8c3fe76fd7bbfece42a708cbf5f3427ebc2fe211cd6a5dd9874a0d8¢tsËAÚöÜQÒE¨trace_id¤Q078­parent_run_idÙ$a78f7d50-e15f-4cbc-8bec-b02a14133a2f¦run_idÙ$bc93232f-17d6-4651-b7ec-d97265e7d69cªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§contextÚÁThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.
- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q078®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5ef1cca0-2c65-07f3-0cf1-c77bcacae431­checkpoint_nsÙ-generate:5ef1cca0-2c65-07f3-0cf1-c77bcacae431¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@75d634000d2452a517b2352db3f52a99f0acd9195df658a39a5da448af25dd98¢tsËAÚöÜQÙM¨trace_idÙ$bc93232f-17d6-4651-b7ec-d97265e7d69c­parent_run_idÙ$a78f7d50-e15f-4cbc-8bec-b02a14133a2f¦run_idÙ$bc93232f-17d6-4651-b7ec-d97265e7d69cªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¦messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain the advantage of using `batch_as_completed` for long running tasks. \nContext: The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.\n- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ac13b61fdd406adcdc6133d10c669ee7cb001b38c5f5cfea02235819fc2ec88c¢tsËAÚöÜİ·Ô¨focus_msÍ‰§payload‚¤role©assistant§contentÚThe advantage of using `batch_as_completed` for long-running tasks is that it allows for parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly improve performance, especially for I/O-bound tasks, by reducing overall latency. Additionally, it simplifies thread management for users, as the execution is handled efficiently in the background.ªfocus_kind¬exec_latency¨query_id¤Q078‰¢idÙ@67ff2afde8ef37494a2e8227c3df05faf907cdd97ea3610b6d5a6f656142ef5e¢tsËAÚöÜİÄa¨trace_idÙ$a78f7d50-e15f-4cbc-8bec-b02a14133a2f­parent_run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772¦run_idÙ$a78f7d50-e15f-4cbc-8bec-b02a14133a2fªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe advantage of using `batch_as_completed` for long-running tasks is that it allows for parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly improve performance, especially for I/O-bound tasks, by reducing overall latency. Additionally, it simplifies thread management for users, as the execution is handled efficiently in the background.¨query_id¤Q078ªfocus_kind¶chain_execution_result‰¢idÙ@b765ef0c8ea0d40b29c646cfaed4942ab6698e4049f3eeb84d2c2e63490fb874¢tsËAÚöÜİÎp¨trace_idÙ$a06ec254-9bd7-4036-822c-e8370c942772­parent_run_idÀ¦run_idÙ$a06ec254-9bd7-4036-822c-e8370c942772ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚThe advantage of using `batch_as_completed` for long-running tasks is that it allows for parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly improve performance, especially for I/O-bound tasks, by reducing overall latency. Additionally, it simplifies thread management for users, as the execution is handled efficiently in the background.¨query_id¤Q078ªfocus_kind¶chain_execution_result‹¢idÙ@5d1062f4952ee4d873c3ff8ff93fe674d99f23629f7e7e11cd40780ac0b90212¢tsËAÚöÜİÖé¨trace_id¤Q079­parent_run_idÀ¦run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?¨query_id¤Q079§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q079ªfocus_kind¯chain_execution‹¢idÙ@d9bd0b7d7856b76a95a10d862fc6ba31636ef32d577e945ba2f42111e5d46f76¢tsËAÚöÜŞ{¨trace_id¤Q079­parent_run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4b¦run_idÙ$e4f51029-16f1-4c0a-a50b-bd6ba1982f71ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context¦answer ¨query_id¤Q079¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q079®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d1fad4e8-6d2f-9675-a3ae-b14db4499ba0ªfocus_kind¯chain_execution‰¢idÙ@925a43ed81d7aaf30f4207fa2922ef968c6fc9437302d1d7f627417ac8b14431¢tsËAÚöÜøj­¨trace_idÙ$e4f51029-16f1-4c0a-a50b-bd6ba1982f71­parent_run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4b¦run_idÙ$e4f51029-16f1-4c0a-a50b-bd6ba1982f71ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q079ªfocus_kind¶chain_execution_result‹¢idÙ@191d5e77bc41f7bf5609dc0965b631e469a251ad5d0603dc4b2efe8b524c5b87¢tsËAÚöÜøqX¨trace_id¤Q079­parent_run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4b¦run_idÙ$58437967-1365-4f97-9edc-3b55f0239ae6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q079¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q079®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:6c837c3a-def3-7dcb-9d1e-e26ca01fa73aªfocus_kind¯chain_execution‹¢idÙ@f960e744815a8dd6a28724552563257ac0f45fe64bc5ceaeefcb7371d8a47dc3¢tsËAÚöÜøu¨trace_id¤Q079­parent_run_idÙ$58437967-1365-4f97-9edc-3b55f0239ae6¦run_idÙ$95b583c1-7269-4e51-bf8b-39f0e285bdc4ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§contextÚB## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

The **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often involves a combination of two patterns of alternating messages:

1. The **user** and the **assistant** representing a back-and-forth conversation.
2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.

## Managing chat history

Since chat models have a maximum limit on input size, it's important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.
    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.
- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.

:::tip
Understanding correct conversation structure is essential for being able to properly implement
[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.
:::

## Related resources

### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](/docs/how_to/trim_messages/)
- [How to: filter messages](/docs/how_to/filter_messages/)
- [How to: merge consecutive messages of the same type](/docs/how_to/merge_message_runs/)

### Prompt templates

[Prompt Templates](/docs/concepts/prompt_templates) are responsible for formatting user input into a format that can be passed to a language model.

- [How to: use few shot examples](/docs/how_to/few_shot_examples)
- [How to: use few shot examples in chat models](/docs/how_to/few_shot_examples_chat/)
- [How to: partially format prompt templates](/docs/how_to/prompts_partial)
- [How to: compose prompts together](/docs/how_to/prompts_composition)
- [How to: use multimodal prompts](/docs/how_to/multimodal_prompts/)

### Example selectors¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q079®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:6c837c3a-def3-7dcb-9d1e-e26ca01fa73a­checkpoint_nsÙ-generate:6c837c3a-def3-7dcb-9d1e-e26ca01fa73a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@da77af3daa58783b82c5c043a314623a9afdd6430da6696961a1a9a43ea65e8a¢tsËAÚöÜø{[¨trace_idÙ$95b583c1-7269-4e51-bf8b-39f0e285bdc4­parent_run_idÙ$58437967-1365-4f97-9edc-3b55f0239ae6¦run_idÙ$95b583c1-7269-4e51-bf8b-39f0e285bdc4ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ:messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two files outline strategies to trim messages to fit the context window? \nContext: ## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\nThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.\n\nA full conversation often involves a combination of two patterns of alternating messages:\n\n1. The **user** and the **assistant** representing a back-and-forth conversation.\n2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.\n\n## Managing chat history\n\nSince chat models have a maximum limit on input size, it\'s important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n- The conversation should follow one of these structures:\n    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.\n    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.\n- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.\n\n:::tip\nUnderstanding correct conversation structure is essential for being able to properly implement\n[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.\n:::\n\n## Related resources\n\n### Messages\n\n[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.\n\n- [How to: trim messages](/docs/how_to/trim_messages/)\n- [How to: filter messages](/docs/how_to/filter_messages/)\n- [How to: merge consecutive messages of the same type](/docs/how_to/merge_message_runs/)\n\n### Prompt templates\n\n[Prompt Templates](/docs/concepts/prompt_templates) are responsible for formatting user input into a format that can be passed to a language model.\n\n- [How to: use few shot examples](/docs/how_to/few_shot_examples)\n- [How to: use few shot examples in chat models](/docs/how_to/few_shot_examples_chat/)\n- [How to: partially format prompt templates](/docs/how_to/prompts_partial)\n- [How to: compose prompts together](/docs/how_to/prompts_composition)\n- [How to: use multimodal prompts](/docs/how_to/multimodal_prompts/)\n\n### Example selectors \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@14f5060988121f58afb935568be06367d8f2b50998783c3aed895ec6c7160b53¢tsËAÚöİVçê¨focus_msÍÃ§payload‚¤role©assistant§contentÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."ªfocus_kind¬exec_latency¨query_id¤Q079‰¢idÙ@bb0e43f3057f1f31bf364decc38bc4c43720edcf370493397baece136cfdaebe¢tsËAÚöİVõ{¨trace_idÙ$58437967-1365-4f97-9edc-3b55f0239ae6­parent_run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4b¦run_idÙ$58437967-1365-4f97-9edc-3b55f0239ae6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."¨query_id¤Q079ªfocus_kind¶chain_execution_result‰¢idÙ@d5d4f394164029772475202be7c8306a368495402ba7ceff8031d35fb99c491a¢tsËAÚöİVş‚¨trace_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4b­parent_run_idÀ¦run_idÙ$9b88af35-b354-4f80-b8e3-fe98f4f85c4bªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."¨query_id¤Q079ªfocus_kind¶chain_execution_result‹¢idÙ@b703c424eb70c016e1324e37ae4dd54240913dcc1177c3c263290ef687be9d1f¢tsËAÚöİW>¨trace_id¤Q080­parent_run_idÀ¦run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?¨query_id¤Q080§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q080ªfocus_kind¯chain_execution‹¢idÙ@6e0c790a1645f7731da14e9bcba64c4adb5076d27a74644516347249dcc1a4c8¢tsËAÚöİW=¨trace_id¤Q080­parent_run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616c¦run_idÙ$1f7f7063-a501-43cd-a5b1-6ee8a832086dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context¦answer ¨query_id¤Q080¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q080®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:9dfa1ccd-6759-6e6d-9b69-594278a51d73ªfocus_kind¯chain_execution‰¢idÙ@618737fc5ac30104543f0a506a959c81da7391fd20efff65590da1114c8cdf44¢tsËAÚöİoÄ¨trace_idÙ$1f7f7063-a501-43cd-a5b1-6ee8a832086d­parent_run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616c¦run_idÙ$1f7f7063-a501-43cd-a5b1-6ee8a832086dªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q080ªfocus_kind¶chain_execution_result‹¢idÙ@e6181a753beee63d04a38687fd81d27b6e11695a49a466c60680fd9c30f127c2¢tsËAÚöİo@¨trace_id¤Q080­parent_run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616c¦run_idÙ$f983c8f4-787e-4226-92b5-49cbf11006dcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q080¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q080®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:10bf4138-2481-859e-aa51-7ba1ab46e33aªfocus_kind¯chain_execution‹¢idÙ@70080770e42ae5fe6a6cdd5f6780d60d2986de4a00939ed9e98ca8073838caac¢tsËAÚöİoO¨trace_id¤Q080­parent_run_idÙ$f983c8f4-787e-4226-92b5-49cbf11006dc¦run_idÙ$09d446a2-b00e-41e7-83fa-f4bc581269e8ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§contextÚ—1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.

### Setting max concurrency

If using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.


:::tip
If you're trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q080®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:10bf4138-2481-859e-aa51-7ba1ab46e33a­checkpoint_nsÙ-generate:10bf4138-2481-859e-aa51-7ba1ab46e33a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@e15354a671587f499ff235fe36e86e71d7b365b85b745a884844516cfd1e1917¢tsËAÚöİo"â¨trace_idÙ$09d446a2-b00e-41e7-83fa-f4bc581269e8­parent_run_idÙ$f983c8f4-787e-4226-92b5-49cbf11006dc¦run_idÙ$09d446a2-b00e-41e7-83fa-f4bc581269e8ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚtmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does the `max_concurrency` field not control when using a ChatModel? \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nSome Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.\n\n### Setting max concurrency\n\nIf using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.\n\n\n:::tip\nIf you\'re trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@00e914f9112bd0b61dd0ce94409bbd593ccbf4d04f813105adfaea19257fe646¢tsËAÚöŞ/F€¨focus_msÍ¹§payload‚¤role©assistant§contentÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.ªfocus_kind¬exec_latency¨query_id¤Q080‰¢idÙ@3e75d3884af6809c861f606c609780ee9540d6e80be49b64aa32af8719881e24¢tsËAÚöŞ/XÄ¨trace_idÙ$f983c8f4-787e-4226-92b5-49cbf11006dc­parent_run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616c¦run_idÙ$f983c8f4-787e-4226-92b5-49cbf11006dcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.¨query_id¤Q080ªfocus_kind¶chain_execution_result‰¢idÙ@0d2f0c638824b26ad7ac222c5e4e56d2073fdf32e2d2c865d45107cda3495df7¢tsËAÚöŞ/`5¨trace_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616c­parent_run_idÀ¦run_idÙ$0cb0b70f-8cf2-4262-a1f8-9eff4716616cªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.¨query_id¤Q080ªfocus_kind¶chain_execution_result‹¢idÙ@67081322e61f3aa1755b6ea722971767661cc136df3e9d639bd126d3ca7dc4eb¢tsËAÚöŞ/f¨trace_id¤Q081­parent_run_idÀ¦run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?¨query_id¤Q081§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q081ªfocus_kind¯chain_execution‹¢idÙ@301a3c78314ac6c18c819e3419a2e3b9dfdfdc6fa6e0463bae6ced663c4ff0f4¢tsËAÚöŞ/nÉ¨trace_id¤Q081­parent_run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142f¦run_idÙ$3262297a-0646-47fb-b3aa-6d5be2c751a0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context¦answer ¨query_id¤Q081¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q081®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d0e004a2-303b-b3db-5833-eaaf2b1e6edbªfocus_kind¯chain_execution‰¢idÙ@d24aeede21e119a6f4c568ec6020dfe72244cfa555ddb4119d3615873bc6247f¢tsËAÚöŞ@IN¨trace_idÙ$3262297a-0646-47fb-b3aa-6d5be2c751a0­parent_run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142f¦run_idÙ$3262297a-0646-47fb-b3aa-6d5be2c751a0ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¨query_id¤Q081ªfocus_kind¶chain_execution_result‹¢idÙ@d9393db6dcf557d07a251cddcb0a7661dd5d480258002f2910d6d5bcbf2e93ce¢tsËAÚöŞ@Oè¨trace_id¤Q081­parent_run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142f¦run_idÙ$762b40ed-0839-452f-8e17-2874de14c11bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¦answer ¨query_id¤Q081¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q081®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c4b812dd-82af-122c-fff5-59e935491964ªfocus_kind¯chain_execution‹¢idÙ@4691e7a68e923e0a86aa17aa71f93e606541cda8868acafc99f8a84719d776fc¢tsËAÚöŞ@S“¨trace_id¤Q081­parent_run_idÙ$762b40ed-0839-452f-8e17-2874de14c11b¦run_idÙ$ce191028-63c3-4dce-b96e-f852dcd6a202ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§contextÚ[- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How to: pass tool outputs to chat models](/docs/how_to/tool_results_pass_to_model)
- [How to: pass run time values to tools](/docs/how_to/tool_runtime)
- [How to: add a human-in-the-loop for tools](/docs/how_to/tools_human)
- [How to: handle tool errors](/docs/how_to/tools_error)
- [How to: force models to call a tool](/docs/how_to/tool_choice)
- [How to: disable parallel tool calling](/docs/how_to/tool_calling_parallel)
- [How to: access the `RunnableConfig` from a tool](/docs/how_to/tool_configure)
- [How to: stream events from a tool](/docs/how_to/tool_stream_events)
- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)

- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_model_caching)
- [How to: get log probabilities](/docs/how_to/logprobs)
- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: stream a response back](/docs/how_to/chat_streaming)
- [How to: track token usage](/docs/how_to/chat_token_usage_tracking)
- [How to: track response metadata across providers](/docs/how_to/response_metadata)
- [How to: use chat model to call tools](/docs/how_to/tool_calling)
- [How to: stream tool calls](/docs/how_to/tool_streaming)
- [How to: handle rate limits](/docs/how_to/chat_model_rate_limiting)
- [How to: few shot prompt tool behavior](/docs/how_to/tools_few_shot)
- [How to: bind model-specific formatted tools](/docs/how_to/tools_model_specific)
- [How to: force a specific tool call](/docs/how_to/tool_choice)

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.
* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).

:::

## Best practices

When designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:

- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)
- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)

# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.
But what about cases where we want a model to also interact *directly* with systems, such as databases or an API?
These systems often have a particular input schema; for example, APIs frequently have a required payload structure.
This need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.

:::info
You will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. 
:::

![Conceptual overview of tool calling](/img/tool_calling_concept.png)

## Key concepts¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q081®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c4b812dd-82af-122c-fff5-59e935491964­checkpoint_nsÙ-generate:c4b812dd-82af-122c-fff5-59e935491964¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@67516ce2dc7f1874d64894f3ffe6039ff727f62d8d6edc7f071f15746eca626a¢tsËAÚöŞ@X›¨trace_idÙ$ce191028-63c3-4dce-b96e-f852dcd6a202­parent_run_idÙ$762b40ed-0839-452f-8e17-2874de14c11b¦run_idÙ$ce191028-63c3-4dce-b96e-f852dcd6a202ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚCmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which document explains how to call tools in parallel with OpenAI? \nContext: - [How to: create tools](/docs/how_to/custom_tools)\n- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)\n- [How to: use chat models to call tools](/docs/how_to/tool_calling)\n- [How to: pass tool outputs to chat models](/docs/how_to/tool_results_pass_to_model)\n- [How to: pass run time values to tools](/docs/how_to/tool_runtime)\n- [How to: add a human-in-the-loop for tools](/docs/how_to/tools_human)\n- [How to: handle tool errors](/docs/how_to/tools_error)\n- [How to: force models to call a tool](/docs/how_to/tool_choice)\n- [How to: disable parallel tool calling](/docs/how_to/tool_calling_parallel)\n- [How to: access the `RunnableConfig` from a tool](/docs/how_to/tool_configure)\n- [How to: stream events from a tool](/docs/how_to/tool_stream_events)\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n\n- [How to: do function/tool calling](/docs/how_to/tool_calling)\n- [How to: get models to return structured output](/docs/how_to/structured_output)\n- [How to: cache model responses](/docs/how_to/chat_model_caching)\n- [How to: get log probabilities](/docs/how_to/logprobs)\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: stream a response back](/docs/how_to/chat_streaming)\n- [How to: track token usage](/docs/how_to/chat_token_usage_tracking)\n- [How to: track response metadata across providers](/docs/how_to/response_metadata)\n- [How to: use chat model to call tools](/docs/how_to/tool_calling)\n- [How to: stream tool calls](/docs/how_to/tool_streaming)\n- [How to: handle rate limits](/docs/how_to/chat_model_rate_limiting)\n- [How to: few shot prompt tool behavior](/docs/how_to/tools_few_shot)\n- [How to: bind model-specific formatted tools](/docs/how_to/tools_model_specific)\n- [How to: force a specific tool call](/docs/how_to/tool_choice)\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.\n* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).\n\n:::\n\n## Best practices\n\nWhen designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:\n\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)\n- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)\n\n# Tool calling\n\n:::info[Prerequisites]\n* [Tools](/docs/concepts/tools)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n\n## Overview \n\nMany AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.\nBut what about cases where we want a model to also interact *directly* with systems, such as databases or an API?\nThese systems often have a particular input schema; for example, APIs frequently have a required payload structure.\nThis need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.\n\n:::info\nYou will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. \n:::\n\n![Conceptual overview of tool calling](/img/tool_calling_concept.png)\n\n## Key concepts \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@bfe0797e79cbfc2ee3888fa2fbd43c6f03bfd3cbf40099ecbc69a26ae782d658¢tsËAÚöŞŒ¡n¨focus_msÍ§§payload‚¤role©assistant§contentÙúThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context of tool calling documentation. For more details, refer to the specific guide linked in the context.ªfocus_kind¬exec_latency¨query_id¤Q081‰¢idÙ@3420ae8ed3192aaacf23198f5aa03c0c868ed97c271172488b156b210d285db4¢tsËAÚöŞŒ¶9¨trace_idÙ$762b40ed-0839-452f-8e17-2874de14c11b­parent_run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142f¦run_idÙ$762b40ed-0839-452f-8e17-2874de14c11bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙúThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context of tool calling documentation. For more details, refer to the specific guide linked in the context.¨query_id¤Q081ªfocus_kind¶chain_execution_result‰¢idÙ@7f8e654e46592fc58ab55fc3172440d1edd59f4e67513254c8c79ac1a3e8096b¢tsËAÚöŞŒÃj¨trace_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142f­parent_run_idÀ¦run_idÙ$6734d8d2-7f37-4312-aa4c-9933eefc142fªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¦answerÙúThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context of tool calling documentation. For more details, refer to the specific guide linked in the context.¨query_id¤Q081ªfocus_kind¶chain_execution_result‹¢idÙ@56ccb35dd20edf6a76e18dfa65717fb322413a5fd61c1dd450155ca9f33de216¢tsËAÚöŞŒÏ¨trace_id¤Q082­parent_run_idÀ¦run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.¨query_id¤Q082§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q082ªfocus_kind¯chain_execution‹¢idÙ@1c503b3d77234572246fbefb4c11536a2f2cca7007e98f66a5d980038e9c4071¢tsËAÚöŞŒÛU¨trace_id¤Q082­parent_run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88¦run_idÙ$d4aa627f-d318-48f1-ba83-cb07a39199b1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context¦answer ¨query_id¤Q082¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q082®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f60c0232-2007-382b-5b00-ece3560cdc18ªfocus_kind¯chain_execution‰¢idÙ@23602f700d43e2745689a33735ea219472056c0e8bb903046c1d28d8a8493e12¢tsËAÚöŞŸ›|¨trace_idÙ$d4aa627f-d318-48f1-ba83-cb07a39199b1­parent_run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88¦run_idÙ$d4aa627f-d318-48f1-ba83-cb07a39199b1ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q082ªfocus_kind¶chain_execution_result‹¢idÙ@394b7a0eec980ddae5abcd29661d1cfc2375a1c414ecff543c90959564269efb¢tsËAÚöŞŸ¤<¨trace_id¤Q082­parent_run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88¦run_idÙ$4e94b58a-2599-4379-927d-55dd2557572aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q082¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q082®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:a827cc6b-e4d1-5867-4a9d-34ea4f887795ªfocus_kind¯chain_execution‹¢idÙ@5ad340e58221e56b3ff89979c09d53642423ec57cd795cbd33dacf2c32e5e5b7¢tsËAÚöŞŸ¨¹¨trace_id¤Q082­parent_run_idÙ$4e94b58a-2599-4379-927d-55dd2557572a¦run_idÙ$46f4a776-26f9-45b0-96da-2be520e9aa05ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§contextÚË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

For example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
chain = RunnableSequence([RunnableParallel(mapping), runnable3])
```

:::caution
You have to be careful because the `mapping` dictionary is not a `RunnableParallel` object, it is just a dictionary. This means that the following code will raise an `AttributeError`:

```python
mapping.invoke(some_input)
```
:::

#### Function to RunnableLambda

Inside an LCEL expression, a function is automatically converted to a `RunnableLambda`.

```
def some_func(x):
    return x

chain = some_func | runnable1
```

It gets automatically converted to the following:

```python
chain = RunnableSequence([RunnableLambda(some_func), runnable1])
```

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q082®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:a827cc6b-e4d1-5867-4a9d-34ea4f887795­checkpoint_nsÙ-generate:a827cc6b-e4d1-5867-4a9d-34ea4f887795¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@31fad16e2b5ed71f839b1f3fc8b4ecb791bbae73f7d43771e05f56f122033f4c¢tsËAÚöŞŸ®\¨trace_idÙ$46f4a776-26f9-45b0-96da-2be520e9aa05­parent_run_idÙ$4e94b58a-2599-4379-927d-55dd2557572a¦run_idÙ$46f4a776-26f9-45b0-96da-2be520e9aa05ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÌmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe how `RunnableGenerator` differs from `RunnableLambda`. \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nFor example, the following code:\n\n```python\nmapping = {\n    "key1": runnable1,\n    "key2": runnable2,\n}\n\nchain = mapping | runnable3\n```\n\nIt gets automatically converted to the following:\n\n```python\nchain = RunnableSequence([RunnableParallel(mapping), runnable3])\n```\n\n:::caution\nYou have to be careful because the `mapping` dictionary is not a `RunnableParallel` object, it is just a dictionary. This means that the following code will raise an `AttributeError`:\n\n```python\nmapping.invoke(some_input)\n```\n:::\n\n#### Function to RunnableLambda\n\nInside an LCEL expression, a function is automatically converted to a `RunnableLambda`.\n\n```\ndef some_func(x):\n    return x\n\nchain = some_func | runnable1\n```\n\nIt gets automatically converted to the following:\n\n```python\nchain = RunnableSequence([RunnableLambda(some_func), runnable1])\n```\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4e1ca8c8a442c0d0832eb182e4b3d8e4bfb66ef927da5f02a6dba494a55ce581¢tsËAÚößW?¨focus_msÍÀ§payload‚¤role©assistant§contentÚ¿`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their processing logic. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.ªfocus_kind¬exec_latency¨query_id¤Q082‰¢idÙ@48543f2a05d22091cf5582c9229658955152338f41124772531173b166e9cfc4¢tsËAÚößp?¨trace_idÙ$4e94b58a-2599-4379-927d-55dd2557572a­parent_run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88¦run_idÙ$4e94b58a-2599-4379-927d-55dd2557572aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ¿`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their processing logic. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.¨query_id¤Q082ªfocus_kind¶chain_execution_result‰¢idÙ@d3a8d3bbcf88784dee1fdd6e53e468250fbd898b7e9602d006262b1c54cd6f93¢tsËAÚöß¨¨trace_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88­parent_run_idÀ¦run_idÙ$18eb55b5-24f5-4a55-b182-92a326bd2a88ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚ¿`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their processing logic. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.¨query_id¤Q082ªfocus_kind¶chain_execution_result‹¢idÙ@fe72b6d801de8338a05ccefb76453bd4deeda32d7be16d6aaba550dc8430ab1c¢tsËAÚößÃ7¨trace_id¤Q083­parent_run_idÀ¦run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?¨query_id¤Q083§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q083ªfocus_kind¯chain_execution‹¢idÙ@df3fde0734a66de8553473c94c2e79598f3dea23500d5cf038ec45f01b8447ad¢tsËAÚößÒF¨trace_id¤Q083­parent_run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128b¦run_idÙ$57bbb149-355a-4250-8f9f-5e4e72774882ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context¦answer ¨query_id¤Q083¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q083®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f0578749-dc07-c4b9-b614-6532c0a5cfc8ªfocus_kind¯chain_execution‰¢idÙ@f522b2a274e12f42772799d1c6f5f2d5b60edd8f0f2196d6ed577260761a6312¢tsËAÚöß#6¨trace_idÙ$57bbb149-355a-4250-8f9f-5e4e72774882­parent_run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128b¦run_idÙ$57bbb149-355a-4250-8f9f-5e4e72774882ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q083ªfocus_kind¶chain_execution_result‹¢idÙ@fefe5e46e20bf981170640e6afc1b45f3975ca829cdc1acac080af5dd49e5269¢tsËAÚöß1ç¨trace_id¤Q083­parent_run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128b¦run_idÙ$0f664709-b5f5-4b4a-bee8-b8cb39f4bde6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q083¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q083®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:eda5923d-0919-21a8-203a-56113bbf0314ªfocus_kind¯chain_execution‹¢idÙ@7c8568e071ce9e2ee4b2a6ce00957dd612cb03d17afcb7e6243a378f7aeee838¢tsËAÚöß:Î¨trace_id¤Q083­parent_run_idÙ$0f664709-b5f5-4b4a-bee8-b8cb39f4bde6¦run_idÙ$fb690e0a-37fd-4e13-9281-cf5deb55ea88ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Which vector store integration supports time weighted relevance?§contextÚèThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, such as text, images, and audio, to retrieve relevant information based on semantic similarity rather than exact keyword matches.

![Vector stores](/img/vectorstores.png)

## Integrations

LangChain has a large number of vectorstore integrations, allowing users to easily switch between different vectorstore implementations.

Please see the [full list of LangChain vectorstore integrations](/docs/integrations/vectorstores/).

## Interface

LangChain provides a standard interface for working with vector stores, allowing users to easily switch between different vectorstore implementations.

The interface consists of basic methods for writing, deleting and searching for documents in the vector store.

The key methods are:

::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview.  
In short, rather than using word frequencies, vectorstores use an [embedding model](/docs/concepts/embedding_models/) to compress documents into high-dimensional vector representation. 
This allows for efficient similarity search over embedding vectors using simple mathematical operations like cosine similarity.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/vectorstore_retriever/) for more details on working with vectorstores.
* See our [list of vectorstore integrations](/docs/integrations/vectorstores/).
* See Cameron Wolfe's [blog post](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2) on the basics of vector search.

:::

#### Relational databases

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

### Vector store 

[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. 
A vectorstore can be used as a retriever by calling the `as_retriever()` method.

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble

# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/docs/concepts/text_splitters/)

:::
:::info[Note]

This conceptual overview focuses on text-based indexing and retrieval for simplicity. 
However, embedding models can be [multi-modal](https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings)
and vector stores can be used to store and retrieve a variety of data types beyond text.
:::

## Overview

Vector stores are specialized data stores that enable indexing and retrieving information based on vector representations.

These vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

As use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q083®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:eda5923d-0919-21a8-203a-56113bbf0314­checkpoint_nsÙ-generate:eda5923d-0919-21a8-203a-56113bbf0314¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@a687aec15b9cac470008fb829aca75818bb01a6bc294d612c458ee0d8a67a037¢tsËAÚößB)¨trace_idÙ$fb690e0a-37fd-4e13-9281-cf5deb55ea88­parent_run_idÙ$0f664709-b5f5-4b4a-bee8-b8cb39f4bde6¦run_idÙ$fb690e0a-37fd-4e13-9281-cf5deb55ea88ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÜmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which vector store integration supports time weighted relevance? \nContext: These vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.\n\nVector stores are frequently used to search over unstructured data, such as text, images, and audio, to retrieve relevant information based on semantic similarity rather than exact keyword matches.\n\n![Vector stores](/img/vectorstores.png)\n\n## Integrations\n\nLangChain has a large number of vectorstore integrations, allowing users to easily switch between different vectorstore implementations.\n\nPlease see the [full list of LangChain vectorstore integrations](/docs/integrations/vectorstores/).\n\n## Interface\n\nLangChain provides a standard interface for working with vector stores, allowing users to easily switch between different vectorstore implementations.\n\nThe interface consists of basic methods for writing, deleting and searching for documents in the vector store.\n\nThe key methods are:\n\n::: \n\n#### Vector indexes\n\nVector indexes are an alternative way to index and store unstructured data.\nSee our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview.  \nIn short, rather than using word frequencies, vectorstores use an [embedding model](/docs/concepts/embedding_models/) to compress documents into high-dimensional vector representation. \nThis allows for efficient similarity search over embedding vectors using simple mathematical operations like cosine similarity.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/vectorstore_retriever/) for more details on working with vectorstores.\n* See our [list of vectorstore integrations](/docs/integrations/vectorstores/).\n* See Cameron Wolfe\'s [blog post](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2) on the basics of vector search.\n\n:::\n\n#### Relational databases\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n### Vector store \n\n[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. \nA vectorstore can be used as a retriever by calling the `as_retriever()` method.\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble\n\n# Vector stores\n<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>\n\n:::info[Prerequisites]\n\n* [Embeddings](/docs/concepts/embedding_models/)\n* [Text splitters](/docs/concepts/text_splitters/)\n\n:::\n:::info[Note]\n\nThis conceptual overview focuses on text-based indexing and retrieval for simplicity. \nHowever, embedding models can be [multi-modal](https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings)\nand vector stores can be used to store and retrieve a variety of data types beyond text.\n:::\n\n## Overview\n\nVector stores are specialized data stores that enable indexing and retrieving information based on vector representations.\n\nThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.\n\nAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ac2cd32fc51ef6c6b4d31127eabbeb8a7fe187208aa688900f925f02297eea29¢tsËAÚöß\ïå¨focus_msÍ§payload‚¤role©assistant§contentÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.ªfocus_kind¬exec_latency¨query_id¤Q083‰¢idÙ@d8696dc49e570dc514fc3fdf0357394e4ce8d641abad9171c8c9cbf5cd2351f6¢tsËAÚöß]ç¨trace_idÙ$0f664709-b5f5-4b4a-bee8-b8cb39f4bde6­parent_run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128b¦run_idÙ$0f664709-b5f5-4b4a-bee8-b8cb39f4bde6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.¨query_id¤Q083ªfocus_kind¶chain_execution_result‰¢idÙ@0ed0bb7f4faf661553c4ae14f4d3cbd4f100d1e38006f443d39c0f46780bacda¢tsËAÚöß]b¨trace_idÙ$c573c37b-a824-49d8-8a35-98802c9a128b­parent_run_idÀ¦run_idÙ$c573c37b-a824-49d8-8a35-98802c9a128bªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.¨query_id¤Q083ªfocus_kind¶chain_execution_result‹¢idÙ@8840633412a610110b5f5d3a305988983c84c63368e469b46ac9e61a91d69b24¢tsËAÚöß]O¨trace_id¤Q084­parent_run_idÀ¦run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769beªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.¨query_id¤Q084§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q084ªfocus_kind¯chain_execution‹¢idÙ@b7d72d4e53a345b20614af454f05b36350cdf8928e235bd40ac27ee4e633cccf¢tsËAÚöß](¦¨trace_id¤Q084­parent_run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769be¦run_idÙ$c081c027-655a-43ed-a979-9735860ff958ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context¦answer ¨query_id¤Q084¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q084®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3c4b34c5-6029-7051-529b-5c6c29d2a321ªfocus_kind¯chain_execution‰¢idÙ@5d9dc91394da67698b5ad92c7e36957c6e72418e555a6ee341117cef3b003823¢tsËAÚöß††ì¨trace_idÙ$c081c027-655a-43ed-a979-9735860ff958­parent_run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769be¦run_idÙ$c081c027-655a-43ed-a979-9735860ff958ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q084ªfocus_kind¶chain_execution_result‹¢idÙ@4349d2f24376a0aab5d095609e0ad0cb3a4c051773d76ef638eb0c080f90a9cf¢tsËAÚöß†Å¨trace_id¤Q084­parent_run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769be¦run_idÙ$1f40160b-e876-447a-9be4-8b64a6f7f21cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q084¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q084®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:caa8a2a9-6cb8-efb4-a75c-564c12cbe3f3ªfocus_kind¯chain_execution‹¢idÙ@447c7cdd3b87f04c13a6ca3849319849d06360cf2f65fa1b813ad1b64693b3fb¢tsËAÚöß†”S¨trace_id¤Q084­parent_run_idÙ$1f40160b-e876-447a-9be4-8b64a6f7f21c¦run_idÙ$687a044a-93d9-464b-9a4b-fcfbd3389460ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§contextÚ„## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.

The `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.

The `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.

Using these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can
filter and search on.

The attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.

# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called `runs`. These can be individual calls from a model, retriever,
tool, or sub-chains.
Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

For a deeper dive, check out [this LangSmith conceptual guide](https://docs.smith.langchain.com/concepts/tracing).

[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like including [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/), [human-in-the-loop](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/), or [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

[LangSmith](https://docs.smith.langchain.com/) makes it possible to iterate with confidence on your applications, by providing LLM-specific observability and framework for testing and evaluating your application.

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q084®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:caa8a2a9-6cb8-efb4-a75c-564c12cbe3f3­checkpoint_nsÙ-generate:caa8a2a9-6cb8-efb4-a75c-564c12cbe3f3¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@4cc6709c2ddab87fc9cf2319b7e7e068938520698639ef3216184c979b312afc¢tsËAÚöß†š™¨trace_idÙ$687a044a-93d9-464b-9a4b-fcfbd3389460­parent_run_idÙ$1f40160b-e876-447a-9be4-8b64a6f7f21c¦run_idÙ$687a044a-93d9-464b-9a4b-fcfbd3389460ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ\messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how to use `run_name` for easier debugging in LangSmith. \nContext: ## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n### Setting custom run name, tags, and metadata\n\nThe `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.\n\nThe `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.\n\nThe `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.\n\nUsing these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can\nfilter and search on.\n\nThe attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.\n\n# Tracing\n\n<span data-heading-keywords="trace,tracing"></span>\n\nA trace is essentially a series of steps that your application takes to go from input to output.\nTraces contain individual steps called `runs`. These can be individual calls from a model, retriever,\ntool, or sub-chains.\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\nFor a deeper dive, check out [this LangSmith conceptual guide](https://docs.smith.langchain.com/concepts/tracing).\n\n[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like including [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/), [human-in-the-loop](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/), or [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\n[LangSmith](https://docs.smith.langchain.com/) makes it possible to iterate with confidence on your applications, by providing LLM-specific observability and framework for testing and evaluating your application.\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4eb7d82cc0d5d3c1f41466cb62023808d26d91a1053b171c702b889579e2ac50¢tsËAÚöà ‡+¨focus_msÍp§payload‚¤role©assistant§contentÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.ªfocus_kind¬exec_latency¨query_id¤Q084‰¢idÙ@3eb8eafd526d8bb45e2c66d9608813656bf2e3872d034e4201aa9ff04f551257¢tsËAÚöà «T¨trace_idÙ$1f40160b-e876-447a-9be4-8b64a6f7f21c­parent_run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769be¦run_idÙ$1f40160b-e876-447a-9be4-8b64a6f7f21cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.¨query_id¤Q084ªfocus_kind¶chain_execution_result‰¢idÙ@9657ae59b66745385ec92c018139da16dd121470fb94ff1dcc81d6850a9b8f5b¢tsËAÚöà »s¨trace_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769be­parent_run_idÀ¦run_idÙ$a57ad23d-7146-4e7a-b8d6-1a41791769beªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.¨query_id¤Q084ªfocus_kind¶chain_execution_result‹¢idÙ@bc55e4a44bf8f88ddb0efb0b302e9c1602cad356f0c09906b2e2c058a73ceebe¢tsËAÚöà Ğú¨trace_id¤Q085­parent_run_idÀ¦run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?¨query_id¤Q085§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q085ªfocus_kind¯chain_execution‹¢idÙ@dc422d3f2f30bcf33da9c7f2f8f88259b22ec0538c974d342a51ec04318d5612¢tsËAÚöà Ş¨trace_id¤Q085­parent_run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86¦run_idÙ$67e42449-bd68-44e3-8da7-942176f80662ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context¦answer ¨query_id¤Q085¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q085®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:54c78b57-eb10-90a7-4070-371d1d46a891ªfocus_kind¯chain_execution‰¢idÙ@1f317fb653f4894ed2315e8de6e35eacee473a5102d6ad1b356c692312cde591¢tsËAÚöà•¨trace_idÙ$67e42449-bd68-44e3-8da7-942176f80662­parent_run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86¦run_idÙ$67e42449-bd68-44e3-8da7-942176f80662ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¨query_id¤Q085ªfocus_kind¶chain_execution_result‹¢idÙ@8046fc87ead1390012cec61c2ba7c5e5bb7aad4ed58f3b83c84af13911c40f10¢tsËAÚöà¾õ¨trace_id¤Q085­parent_run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86¦run_idÙ$7e2ead24-14ac-491a-be5d-b098ab7e4203ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¦answer ¨query_id¤Q085¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q085®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:35f06782-e60b-d74d-8da5-8e066c14070aªfocus_kind¯chain_execution‹¢idÙ@ae509b8a3f6b775e81eaee1d4d6553c45da5ee6db8ae1a32906b4c21211a6441¢tsËAÚöàÃ ¨trace_id¤Q085­parent_run_idÙ$7e2ead24-14ac-491a-be5d-b098ab7e4203¦run_idÙ$45f82713-58e2-4771-9d0c-6c5115e9603cªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§contextÚ$### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don't have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.

```python
%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence

from langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader

file_path = "<filepath>"
endpoint = "<endpoint>"
key = "<key>"
loader = AzureAIDocumentIntelligenceLoader(
    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"
)

documents = loader.load()
```

## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
based service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from
digital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.

This [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.

### Prerequisite

# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.

This covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a LangChain 
[Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document)
object that we can use downstream.


## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

| Parameter      | Description                                                                                                                                                                                                                                                                                                    |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `model`        | The name or identifier of the specific AI model you want to use (e.g., `"gpt-3.5-turbo"` or `"gpt-4"`).                                                                                                                                                                                                        |

# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.

## Integrations

You can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).

## Interface

Documents loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).

Each DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.

Here's a simple example:

```python
from langchain_community.document_loaders.csv_loader import CSVLoader¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q085®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:35f06782-e60b-d74d-8da5-8e066c14070a­checkpoint_nsÙ-generate:35f06782-e60b-d74d-8da5-8e066c14070a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@5416dfb790e34cdc11ea0cb42b52704f3920eb8696c2af07ec25666d87aa4d22¢tsËAÚöàÊ.¨trace_idÙ$45f82713-58e2-4771-9d0c-6c5115e9603c­parent_run_idÙ$7e2ead24-14ac-491a-be5d-b098ab7e4203¦run_idÙ$45f82713-58e2-4771-9d0c-6c5115e9603cªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ!messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`? \nContext: ### Prerequisite\n\nAn Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don\'t have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.\n\n```python\n%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence\n\nfrom langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader\n\nfile_path = "<filepath>"\nendpoint = "<endpoint>"\nkey = "<key>"\nloader = AzureAIDocumentIntelligenceLoader(\n    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"\n)\n\ndocuments = loader.load()\n```\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning \nbased service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from\ndigital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.\n\nThis [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.\n\n### Prerequisite\n\n# How to load Microsoft Office files\n\nThe [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.\n\nThis covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a LangChain \n[Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document)\nobject that we can use downstream.\n\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n| Parameter      | Description                                                                                                                                                                                                                                                                                                    |\n|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `model`        | The name or identifier of the specific AI model you want to use (e.g., `"gpt-3.5-turbo"` or `"gpt-4"`).                                                                                                                                                                                                        |\n\n# Document loaders\n<span data-heading-keywords="document loader,document loaders"></span>\n\n:::info[Prerequisites]\n\n* [Document loaders API reference](/docs/how_to/#document-loaders)\n:::\n\nDocument loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.\n\n## Integrations\n\nYou can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).\n\n## Interface\n\nDocuments loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).\n\nEach DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.\n\nHere\'s a simple example:\n\n```python\nfrom langchain_community.document_loaders.csv_loader import CSVLoader \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@04f50748ef5e72b95572b70dd020183463c53791b5a2610061a99676ba259197¢tsËAÚöàigÜ¨focus_msÍ
§payload‚¤role©assistant§contentÚTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These are essential for connecting to the Azure AI Document Intelligence resource. Additionally, you will also need to specify the `file_path` and `api_model`.ªfocus_kind¬exec_latency¨query_id¤Q085‰¢idÙ@5700ef20a87654172112a2f2316b44ec27873f886c98ff83af08fc196d5db4bc¢tsËAÚöài{N¨trace_idÙ$7e2ead24-14ac-491a-be5d-b098ab7e4203­parent_run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86¦run_idÙ$7e2ead24-14ac-491a-be5d-b098ab7e4203ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These are essential for connecting to the Azure AI Document Intelligence resource. Additionally, you will also need to specify the `file_path` and `api_model`.¨query_id¤Q085ªfocus_kind¶chain_execution_result‰¢idÙ@39a352962d560537d1e8b2eb3d0a9bb84387842d20f57492058efed3cb733ffa¢tsËAÚöài„Ë¨trace_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86­parent_run_idÀ¦run_idÙ$c09f06ef-f081-43de-acad-b27792ff1c86ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¦answerÚTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These are essential for connecting to the Azure AI Document Intelligence resource. Additionally, you will also need to specify the `file_path` and `api_model`.¨query_id¤Q085ªfocus_kind¶chain_execution_result‹¢idÙ@3969f78249aea1a36355687b24d43dca58152f3af9a296d6a2338da12a04b2ea¢tsËAÚöàiŒÒ¨trace_id¤Q086­parent_run_idÀ¦run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?¨query_id¤Q086§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q086ªfocus_kind¯chain_execution‹¢idÙ@ddf1af024edc990a4b27acc783fd856796c7b204400e7af303fdd955b454d3b7¢tsËAÚöài•¯¨trace_id¤Q086­parent_run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52¦run_idÙ$2352f857-8d15-4ef0-ab34-f9c1460508d1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context¦answer ¨query_id¤Q086¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q086®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:39506804-a381-3996-0bd9-cd2c19d9525eªfocus_kind¯chain_execution‰¢idÙ@c77576c29d6ecce67a6084b0b818f941bf8a75355aa0484eaf579834ab5b17e9¢tsËAÚöà{{¨trace_idÙ$2352f857-8d15-4ef0-ab34-f9c1460508d1­parent_run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52¦run_idÙ$2352f857-8d15-4ef0-ab34-f9c1460508d1ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q086ªfocus_kind¶chain_execution_result‹¢idÙ@063f8919e06c6ec3bac6dcd42cade1e264229c8ee2f48d69769389a887492f14¢tsËAÚöà{"%¨trace_id¤Q086­parent_run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52¦run_idÙ$17ab3c3a-ac1c-4d43-bda2-ac084a0dd13fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q086¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q086®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:bb2c6d60-b7dd-412a-9f23-0d8d32649ba2ªfocus_kind¯chain_execution‹¢idÙ@a57be3b73b1994014563d0fc674f314b6694e53b683c37ffc6ec8e52a0b4320b¢tsËAÚöà{(ö¨trace_id¤Q086­parent_run_idÙ$17ab3c3a-ac1c-4d43-bda2-ac084a0dd13f¦run_idÙ$0fc01af8-2a8a-407e-b14b-0859ea82eab0ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§contextÚ>#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.



### `astream_events`
<span data-heading-keywords="astream_events,stream_events,stream events"></span>

:::tip
Use the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). 

While this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.
:::

The [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.

#### Usage with chat models

When using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM's output incrementally as it's being produced, which is particularly useful in interactive applications or interfaces.

#### Usage with LangGraph

[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.

1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): Use to stream outputs from individual Runnables (e.g., a chat model) as they are generated or stream any workflow created with LangGraph.
2. The async only [astream_events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events): Use this API to get access to custom events and intermediate outputs from LLM  applications built entirely with [LCEL](/docs/concepts/lcel). Note that this API is available, but not needed when working with LangGraph.

:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_log) API. This API is not recommended for new projects it is more complex and less feature-rich than the other streaming APIs.
:::

### `stream()` and `astream()`

The `stream()` method returns an iterator that yields chunks of output synchronously as they are produced. You can use a `for` loop to process each chunk in real-time. For example, when using an LLM, this allows the output to be streamed incrementally as it is generated, reducing the wait time for users.

model = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for event in chain.astream_events({"topic": "parrot"}):
    kind = event["event"]
    if kind == "on_chat_model_stream":
        print(event, end="|", flush=True)
```

You can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!

See [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.

## Writing custom data to the stream

To write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q086®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:bb2c6d60-b7dd-412a-9f23-0d8d32649ba2­checkpoint_nsÙ-generate:bb2c6d60-b7dd-412a-9f23-0d8d32649ba2¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@240b366348de1689bcb852eb3a1c2d3e2b58cccff113d91f63c60f182a6c6826¢tsËAÚöà{/A¨trace_idÙ$0fc01af8-2a8a-407e-b14b-0859ea82eab0­parent_run_idÙ$17ab3c3a-ac1c-4d43-bda2-ac084a0dd13f¦run_idÙ$0fc01af8-2a8a-407e-b14b-0859ea82eab0ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the main benefit of `asam_stream` events over `astream`? \nContext: #### Usage with LCEL\n\nIf you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.\n\n\n\n### `astream_events`\n<span data-heading-keywords="astream_events,stream_events,stream events"></span>\n\n:::tip\nUse the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). \n\nWhile this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.\n:::\n\nThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.\n\n#### Usage with chat models\n\nWhen using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM\'s output incrementally as it\'s being produced, which is particularly useful in interactive applications or interfaces.\n\n#### Usage with LangGraph\n\n[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.\n\n1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): Use to stream outputs from individual Runnables (e.g., a chat model) as they are generated or stream any workflow created with LangGraph.\n2. The async only [astream_events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events): Use this API to get access to custom events and intermediate outputs from LLM  applications built entirely with [LCEL](/docs/concepts/lcel). Note that this API is available, but not needed when working with LangGraph.\n\n:::note\nIn addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_log) API. This API is not recommended for new projects it is more complex and less feature-rich than the other streaming APIs.\n:::\n\n### `stream()` and `astream()`\n\nThe `stream()` method returns an iterator that yields chunks of output synchronously as they are produced. You can use a `for` loop to process each chunk in real-time. For example, when using an LLM, this allows the output to be streamed incrementally as it is generated, reducing the wait time for users.\n\nmodel = ChatAnthropic(model="claude-3-sonnet-20240229")\n\nprompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")\nparser = StrOutputParser()\nchain = prompt | model | parser\n\nasync for event in chain.astream_events({"topic": "parrot"}):\n    kind = event["event"]\n    if kind == "on_chat_model_stream":\n        print(event, end="|", flush=True)\n```\n\nYou can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!\n\nSee [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.\n\n## Writing custom data to the stream\n\nTo write custom data to the stream, you will need to choose one of the following methods based on the component you are working with: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@6f9f6db0653101cf5cb4f48ad85582242031dbf757b5f0b4ae2cb534c8173071¢tsËAÚöàë½4¨focus_msÍŞ§payload‚¤role©assistant§contentÚÜThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing the application's functionality. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.ªfocus_kind¬exec_latency¨query_id¤Q086‰¢idÙ@48503367439ba511171f8631924bf557c3f40b5069d3c76e58c547f1fc011349¢tsËAÚöàëÊÿ¨trace_idÙ$17ab3c3a-ac1c-4d43-bda2-ac084a0dd13f­parent_run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52¦run_idÙ$17ab3c3a-ac1c-4d43-bda2-ac084a0dd13fªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÜThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing the application's functionality. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.¨query_id¤Q086ªfocus_kind¶chain_execution_result‰¢idÙ@431c2f1ee015a0b58d48f8510a8a9ccb9681ce6d14b604af41b0699228afb1bb¢tsËAÚöàëØ¨trace_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52­parent_run_idÀ¦run_idÙ$310c1022-00e8-4a6f-a92c-9f4d637d2c52ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚÜThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing the application's functionality. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.¨query_id¤Q086ªfocus_kind¶chain_execution_result‹¢idÙ@5b6579ba9e8c047328110bdc50985ba43a7e5c84c7739a34664ded671d3cbdfb¢tsËAÚöàìŠ¨trace_id¤Q087­parent_run_idÀ¦run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?¨query_id¤Q087§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q087ªfocus_kind¯chain_execution‹¢idÙ@6b4adf31ea064ee274201f6d1baf4c6c7304603fae36a56f76ccfa215452d4cf¢tsËAÚöàì‘¨trace_id¤Q087­parent_run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772¦run_idÙ$7460ef5c-dc1e-4915-8420-e2798bd7bc19ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context¦answer ¨query_id¤Q087¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q087®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:20d89e7f-cb94-2d10-59c6-5ac8a7b8f5cfªfocus_kind¯chain_execution‰¢idÙ@d1f93b50eca2f657a1e1e371c10007a7cd5e66be932682fe3d1eecbd3367508a¢tsËAÚöá‚x¨trace_idÙ$7460ef5c-dc1e-4915-8420-e2798bd7bc19­parent_run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772¦run_idÙ$7460ef5c-dc1e-4915-8420-e2798bd7bc19ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q087ªfocus_kind¶chain_execution_result‹¢idÙ@9c1f3e7390cce915c735cfe22a21f2dfc9fa4ed6553e083744909537c30b4fe9¢tsËAÚöáq¨trace_id¤Q087­parent_run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772¦run_idÙ$4631f2da-53c8-4c9d-a9d6-6b2089b1b44eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q087¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q087®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:fecf2c65-98fd-1ae4-4ec2-7928c8268069ªfocus_kind¯chain_execution‹¢idÙ@40f87f8ac3cd041212d556c6ece2faa152a32abc5aacb65d3d850d2d2a9dfae5¢tsËAÚöá°q¨trace_id¤Q087­parent_run_idÙ$4631f2da-53c8-4c9d-a9d6-6b2089b1b44e¦run_idÙ$8f9e26d3-d1ec-4432-a50d-64c0f7a5b0eeªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§contextÚÜYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.
* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).

:::

## Best practices

When designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:

These requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples only include expected tool calls and not the actual tool outputs, you can try adding dummy ToolMessages / AIMessages to the end of each example with generic contents to satisfy the API constraints.
In these cases it's especially worth experimenting with inserting your examples as strings versus messages, as having dummy messages can adversely affect certain models.

You can see a case study of how Anthropic and OpenAI respond to different few-shot prompting techniques on two different tool calling benchmarks [here](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/).

- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)
- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q087®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:fecf2c65-98fd-1ae4-4ec2-7928c8268069­checkpoint_nsÙ-generate:fecf2c65-98fd-1ae4-4ec2-7928c8268069¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@ac10c4369ab35d5a9465e0966b2e7bd3d675441e4debc502f899c29bed895be9¢tsËAÚöáÃ;¨trace_idÙ$8f9e26d3-d1ec-4432-a50d-64c0f7a5b0ee­parent_run_idÙ$4631f2da-53c8-4c9d-a9d6-6b2089b1b44e¦run_idÙ$8f9e26d3-d1ec-4432-a50d-64c0f7a5b0eeªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÉmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you specify hidden arguments in a Tool so the model cannot set them? \nContext: You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.\n* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).\n\n:::\n\n## Best practices\n\nWhen designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:\n\nThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples only include expected tool calls and not the actual tool outputs, you can try adding dummy ToolMessages / AIMessages to the end of each example with generic contents to satisfy the API constraints.\nIn these cases it\'s especially worth experimenting with inserting your examples as strings versus messages, as having dummy messages can adversely affect certain models.\n\nYou can see a case study of how Anthropic and OpenAI respond to different few-shot prompting techniques on two different tool calling benchmarks [here](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/).\n\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)\n- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@c08026897fd3060a1e53c61f37745e5af8eb3638dd492b6e3b7b61ff2aa60c4f¢tsËAÚöáo•¨focus_msÍ³§payload‚¤role©assistant§contentÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.ªfocus_kind¬exec_latency¨query_id¤Q087‰¢idÙ@f32be8a2123631afb3afef2088cd2341c1a2cca38117d2858449bafc9668c2a2¢tsËAÚöáo¨ø¨trace_idÙ$4631f2da-53c8-4c9d-a9d6-6b2089b1b44e­parent_run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772¦run_idÙ$4631f2da-53c8-4c9d-a9d6-6b2089b1b44eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.¨query_id¤Q087ªfocus_kind¶chain_execution_result‰¢idÙ@3487b4e23061fff9b4a0223e9614d66b87cf2a5ddf61aa9eb8b6c3ede32852c0¢tsËAÚöáoµ¨trace_idÙ$580aecdc-223a-4573-b64a-f072aa02c772­parent_run_idÀ¦run_idÙ$580aecdc-223a-4573-b64a-f072aa02c772ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.¨query_id¤Q087ªfocus_kind¶chain_execution_result‹¢idÙ@3163f31eaee1b4acbdb04ac905aff239e18b2bff168e7799bd320d39f1ee83e8¢tsËAÚöáoÇï¨trace_id¤Q088­parent_run_idÀ¦run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?¨query_id¤Q088§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q088ªfocus_kind¯chain_execution‹¢idÙ@9ac047a2e0350736e34b7d630699086affe4e5e82a5f1b1ed12e84fa3786ac79¢tsËAÚöáoÚn¨trace_id¤Q088­parent_run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51¦run_idÙ$a607d254-1174-4f58-bdd5-6465cba9c5e6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context¦answer ¨query_id¤Q088¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q088®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e858f5bf-6af1-3bcb-0221-392ba17d2452ªfocus_kind¯chain_execution‰¢idÙ@72622562e08b24e9e4790e29a9e9342c149ce8fde5df0fba5e49bfb538f3f700¢tsËAÚöáŒ‰+¨trace_idÙ$a607d254-1174-4f58-bdd5-6465cba9c5e6­parent_run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51¦run_idÙ$a607d254-1174-4f58-bdd5-6465cba9c5e6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q088ªfocus_kind¶chain_execution_result‹¢idÙ@5445f47909076101a03f6b9b87088b5f18df52326f29a755f5ffab66ee88557a¢tsËAÚöáŒ“.¨trace_id¤Q088­parent_run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51¦run_idÙ$1699d908-9cc5-476a-8a9c-08d8572caac1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q088¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q088®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1f719e30-1047-d3d1-4ab8-c3aae25f53c7ªfocus_kind¯chain_execution‹¢idÙ@c5540c7355bd2957f977298b163bd6bf05c892ab560a8c7958054c88e50991ff¢tsËAÚöáŒ˜ª¨trace_id¤Q088­parent_run_idÙ$1699d908-9cc5-476a-8a9c-08d8572caac1¦run_idÙ$c560c73b-792e-4e77-b028-a45740e2310fªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§contextÚÉ:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't need to actually *store* documents. 
For example, we can be built retrievers on top of search APIs that simply return search results! 
See our retriever integrations with [Amazon Kendra](/docs/integrations/retrievers/amazon_kendra_retriever/) or [Wikipedia Search](/docs/integrations/retrievers/wikipedia/). 

### Relational or graph database

Retrievers can be built on top of relational or graph databases.
In these cases, [query analysis](/docs/concepts/retrieval/) techniques to construct a structured query from natural language is critical.
For example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) retriever to be transformed into a SQL query behind the scenes.

:::info[Further reading]

You can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for databases that typically require structured query languages.
For example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) to be transformed into a SQL query behind the scenes.
Regardless of the underlying retrieval system, all retrievers in LangChain share a common interface. You can use them with the simple `invoke` method:


```python
docs = retriever.invoke(query)
```

:::info[Further reading]

* See our [conceptual guide on retrievers](/docs/concepts/retrievers/).
* See our [how-to guide](/docs/how_to/#retrievers) on working with retrievers.

:::

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/docs/concepts/text_splitters/)

:::

:::danger[Security]
 
Some of the concepts reviewed here utilize models to generate queries (e.g., for SQL or graph databases).
There are inherent risks in doing this. 
Make sure that your database connection permissions are scoped as narrowly as possible for your application's needs. 
This will mitigate, though not eliminate, the risks of building a model-driven system capable of querying databases. 
For more on general security best practices, see our [security guide](/docs/security/).

:::

## Overview 

Retrieval systems are fundamental to many AI applications, efficiently identifying relevant information from large datasets. 
These systems accommodate various data formats:

### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#query-analysis).

- [How to: add examples to the prompt](/docs/how_to/query_few_shot)
- [How to: handle cases where no queries are generated](/docs/how_to/query_no_queries)
- [How to: handle multiple queries](/docs/how_to/query_multiple_queries)
- [How to: handle multiple retrievers](/docs/how_to/query_multiple_retrievers)
- [How to: construct filters](/docs/how_to/query_constructing_filters)
- [How to: deal with high cardinality categorical variables](/docs/how_to/query_high_cardinality)

### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q088®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1f719e30-1047-d3d1-4ab8-c3aae25f53c7­checkpoint_nsÙ-generate:1f719e30-1047-d3d1-4ab8-c3aae25f53c7¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d2b02324983f1728d1aa426c117818d0729fde01c1543a3cc1c78cb7e32ef9f2¢tsËAÚöáŒŸ¨trace_idÙ$c560c73b-792e-4e77-b028-a45740e2310f­parent_run_idÙ$1699d908-9cc5-476a-8a9c-08d8572caac1¦run_idÙ$c560c73b-792e-4e77-b028-a45740e2310fªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÍmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which guide demonstrates building a SQL retriever over a large database? \nContext: :::\n \n## Common types\n\nDespite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.\n\n### Search apis\n\nIt\'s important to note that retrievers don\'t need to actually *store* documents. \nFor example, we can be built retrievers on top of search APIs that simply return search results! \nSee our retriever integrations with [Amazon Kendra](/docs/integrations/retrievers/amazon_kendra_retriever/) or [Wikipedia Search](/docs/integrations/retrievers/wikipedia/). \n\n### Relational or graph database\n\nRetrievers can be built on top of relational or graph databases.\nIn these cases, [query analysis](/docs/concepts/retrieval/) techniques to construct a structured query from natural language is critical.\nFor example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) retriever to be transformed into a SQL query behind the scenes.\n\n:::info[Further reading]\n\nYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for databases that typically require structured query languages.\nFor example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) to be transformed into a SQL query behind the scenes.\nRegardless of the underlying retrieval system, all retrievers in LangChain share a common interface. You can use them with the simple `invoke` method:\n\n\n```python\ndocs = retriever.invoke(query)\n```\n\n:::info[Further reading]\n\n* See our [conceptual guide on retrievers](/docs/concepts/retrievers/).\n* See our [how-to guide](/docs/how_to/#retrievers) on working with retrievers.\n\n:::\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\n# Retrieval\n\n:::info[Prerequisites]\n\n* [Retrievers](/docs/concepts/retrievers/)\n* [Vector stores](/docs/concepts/vectorstores/)\n* [Embeddings](/docs/concepts/embedding_models/)\n* [Text splitters](/docs/concepts/text_splitters/)\n\n:::\n\n:::danger[Security]\n \nSome of the concepts reviewed here utilize models to generate queries (e.g., for SQL or graph databases).\nThere are inherent risks in doing this. \nMake sure that your database connection permissions are scoped as narrowly as possible for your application\'s needs. \nThis will mitigate, though not eliminate, the risks of building a model-driven system capable of querying databases. \nFor more on general security best practices, see our [security guide](/docs/security/).\n\n:::\n\n## Overview \n\nRetrieval systems are fundamental to many AI applications, efficiently identifying relevant information from large datasets. \nThese systems accommodate various data formats:\n\n### Query analysis\n\nQuery Analysis is the task of using an LLM to generate a query to send to a retriever.\nFor a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#query-analysis).\n\n- [How to: add examples to the prompt](/docs/how_to/query_few_shot)\n- [How to: handle cases where no queries are generated](/docs/how_to/query_no_queries)\n- [How to: handle multiple queries](/docs/how_to/query_multiple_queries)\n- [How to: handle multiple retrievers](/docs/how_to/query_multiple_retrievers)\n- [How to: construct filters](/docs/how_to/query_constructing_filters)\n- [How to: deal with high cardinality categorical variables](/docs/how_to/query_high_cardinality)\n\n### Q&A over SQL + CSV\n\nYou can use LLMs to do question answering over tabular data.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/). \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@cbee694cbfca6a1a35f17f71848c6da769965bb6d0b5f39d0710594496787cc5¢tsËAÚöâ¬2¨focus_msÍÀ§payload‚¤role©assistant§contentÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.ªfocus_kind¬exec_latency¨query_id¤Q088‰¢idÙ@885e14c8a0cf3307c94d06c170186d16ba6b330c780e0079b248c3f0117f5e42¢tsËAÚöâ´¨trace_idÙ$1699d908-9cc5-476a-8a9c-08d8572caac1­parent_run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51¦run_idÙ$1699d908-9cc5-476a-8a9c-08d8572caac1ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.¨query_id¤Q088ªfocus_kind¶chain_execution_result‰¢idÙ@9fc79b1578f896a9506f0d7d8f43d52e3cf9af4e1e53a616be3965fbd0ce6f4b¢tsËAÚöâº¨trace_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51­parent_run_idÀ¦run_idÙ$4143f3b3-78f8-4169-908a-88ae11714d51ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.¨query_id¤Q088ªfocus_kind¶chain_execution_result‹¢idÙ@4064e28cf9826793fc08a2e4312b3a0eb9770c7bcf616b84a69bbbd94d1cae4e¢tsËAÚöâ¾©¨trace_id¤Q089­parent_run_idÀ¦run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?¨query_id¤Q089§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q089ªfocus_kind¯chain_execution‹¢idÙ@b955c0b9b56722eafbaa1876bb41f0ae133ebb0e6e723368bc76cbff99c2fe26¢tsËAÚöâÇr¨trace_id¤Q089­parent_run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8c¦run_idÙ$f6f5261f-bbe8-4c8d-8f6f-558365d8d9b2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context¦answer ¨query_id¤Q089¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q089®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7f70cdb6-91bd-324f-959b-0b241b925a41ªfocus_kind¯chain_execution‰¢idÙ@50be27f63fa1074e51caf8411a60c4d77ff31117669d3315dbb9e41c5f1baf6e¢tsËAÚöâ,E¨trace_idÙ$f6f5261f-bbe8-4c8d-8f6f-558365d8d9b2­parent_run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8c¦run_idÙ$f6f5261f-bbe8-4c8d-8f6f-558365d8d9b2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q089ªfocus_kind¶chain_execution_result‹¢idÙ@3e1e41f9bf5c1a45cfef4b3532bb594c0ecdfdb9749db2ca99affc207fac9f73¢tsËAÚöâ=¬¨trace_id¤Q089­parent_run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8c¦run_idÙ$c6f0c2a8-ba61-44b9-bdc6-2d3553a1f106ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q089¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q089®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:70042600-9153-ff1b-8c44-6abf3e304751ªfocus_kind¯chain_execution‹¢idÙ@576e92472913320273c7296e67298416fbf34eb89153eed000432ac3dd2b4fe0¢tsËAÚöâF¨trace_id¤Q089­parent_run_idÙ$c6f0c2a8-ba61-44b9-bdc6-2d3553a1f106¦run_idÙ$1b8be2a8-672d-4ce3-b8d6-8436ee7e8f15ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§contextÚŞ### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

A semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.

However, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.

Please see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.

## Related resources

* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).
* List of supported chat models: [chat model integrations](/docs/integrations/chat/).

### Conceptual guides

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q089®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:70042600-9153-ff1b-8c44-6abf3e304751­checkpoint_nsÙ-generate:70042600-9153-ff1b-8c44-6abf3e304751¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@a910fedd636ec2bdd59620207f710652c2bde9847d74dfe5973dcacd48923cac¢tsËAÚöâN¨trace_idÙ$1b8be2a8-672d-4ce3-b8d6-8436ee7e8f15­parent_run_idÙ$c6f0c2a8-ba61-44b9-bdc6-2d3553a1f106¦run_idÙ$1b8be2a8-672d-4ce3-b8d6-8436ee7e8f15ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¥messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Why is semantic caching unlikely to hit after the first chat turn? \nContext: ### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\nA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it\'s not guaranteed to capture the meaning of the input accurately.\n\nHowever, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.\n\nPlease see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.\n\n## Related resources\n\n* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).\n* List of supported chat models: [chat model integrations](/docs/integrations/chat/).\n\n### Conceptual guides\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@71ba38f7759deb2836e6f4c55e6346b34a65ff14e491a506e5458ef9bd7b8bde¢tsËAÚöâLÎx¨focus_msÍC§payload‚¤role©assistant§contentÚ¨Semantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the chances of a cache hit. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.ªfocus_kind¬exec_latency¨query_id¤Q089‰¢idÙ@43ab05931031db2c7dcd547d3c33d04f80aaad607ac735046d100b8540a101e6¢tsËAÚöâLŞL¨trace_idÙ$c6f0c2a8-ba61-44b9-bdc6-2d3553a1f106­parent_run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8c¦run_idÙ$c6f0c2a8-ba61-44b9-bdc6-2d3553a1f106ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ¨Semantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the chances of a cache hit. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.¨query_id¤Q089ªfocus_kind¶chain_execution_result‰¢idÙ@9bf39e0e28ca3ba61a240ef27108171b91e3cee0c27d3e5232cc8f404ef1b847¢tsËAÚöâLã\¨trace_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8c­parent_run_idÀ¦run_idÙ$8b63a87f-b71a-419d-9556-cc3b2d7f3d8cªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚ¨Semantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the chances of a cache hit. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.¨query_id¤Q089ªfocus_kind¶chain_execution_result‹¢idÙ@81b3bae0dad0f21a08be3c6e0f3ad135109143bee8108967fc216aacea82b73b¢tsËAÚöâLè¯¨trace_id¤Q090­parent_run_idÀ¦run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.¨query_id¤Q090§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q090ªfocus_kind¯chain_execution‹¢idÙ@fbf0a0abadd6d7c7ced3115579ba7e42efd803276b2563773ee40cfc7bf391eb¢tsËAÚöâLö4¨trace_id¤Q090­parent_run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944¦run_idÙ$107152bf-0e25-4e5b-970f-ec2d4ae4921aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context¦answer ¨query_id¤Q090¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q090®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:90aa22df-4331-4b00-071c-d9ac7e8037bdªfocus_kind¯chain_execution‰¢idÙ@d7921c040bfc063fc2a87af42043b5ebedf08e7a6b01c98f58aa82676612eaad¢tsËAÚöâf X¨trace_idÙ$107152bf-0e25-4e5b-970f-ec2d4ae4921a­parent_run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944¦run_idÙ$107152bf-0e25-4e5b-970f-ec2d4ae4921aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¨query_id¤Q090ªfocus_kind¶chain_execution_result‹¢idÙ@d8c80f81fea61ae453033c0fe90de01d777e5642522ed22ee15c1863f9727e52¢tsËAÚöâf)Ğ¨trace_id¤Q090­parent_run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944¦run_idÙ$fc778011-a6c5-4cf5-88d9-a85f974cae92ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answer ¨query_id¤Q090¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q090®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7c713d04-0492-db46-c8fe-397cf2b1d4cbªfocus_kind¯chain_execution‹¢idÙ@449f4f7ceeed756ad05aab5464c7e9a5a51bc906188217710ac94469ffd4981a¢tsËAÚöâf.Ë¨trace_id¤Q090­parent_run_idÙ$fc778011-a6c5-4cf5-88d9-a85f974cae92¦run_idÙ$4f243b6b-2092-425f-84aa-c16cb7e21697ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§contextÚ_:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy, creating split that maintain natural language flow, maintain semantic coherence within split, and adapts to varying levels of text granularity.
LangChain's [`RecursiveCharacterTextSplitter`](/docs/how_to/recursive_text_splitter/) implements this concept:
- The `RecursiveCharacterTextSplitter` attempts to keep larger units (e.g., paragraphs) intact.
- If a unit exceeds the chunk size, it moves to the next level (e.g., sentences).
- This process continues down to the word level if necessary.

Here is example usage:

```python
from langchain_text_splitters import RecursiveCharacterTextSplitter
text_splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=0)
texts = text_splitter.split_text(document)
```

:::info[Further reading]

Example implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter.from_tiktoken_encoder(
    encoding_name="cl100k_base", chunk_size=100, chunk_overlap=0
)
texts = text_splitter.split_text(document)
```

:::info[Further reading]

* See the how-to guide for [token-based](/docs/how_to/split_by_token/) splitting.
* See the how-to guide for [character-based](/docs/how_to/character_text_splitter/) splitting.

:::

### Text-structured based

# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:::

## Overview

Document splitting is often a crucial preprocessing step for many applications.
It involves breaking down large texts into smaller, manageable chunks.
This process offers several benefits, such as ensuring consistent processing of varying document lengths, overcoming input size limitations of models, and improving the quality of text representations used in retrieval systems.
There are several strategies for splitting documents, each with its own advantages.

## Key concepts

![Conceptual Overview](/img/text_splitters.png)

Text splitters split documents into smaller chunks for use in downstream applications.

## Why split documents?

There are several reasons to split documents:

:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, such as HTML, Markdown, or JSON files. 
In these cases, it's beneficial to split the document based on its structure, as it often naturally groups semantically related text.
Key benefits of structure-based splitting:
- Preserves the logical organization of the document
- Maintains context within each chunk
- Can be more effective for downstream tasks like retrieval or summarization

Examples of structure-based splitting:
- **Markdown**: Split based on headers (e.g., #, ##, ###)
- **HTML**: Split using tags
- **JSON**: Split by object or array elements
- **Code**: Split by functions, classes, or logical blocks

:::info[Further reading]

:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).
* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).
* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).

:::

### Semantic meaning based

Unlike the previous methods, semantic-based splitting actually considers the *content* of the text. 
While other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.
There are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.
As an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q090®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7c713d04-0492-db46-c8fe-397cf2b1d4cb­checkpoint_nsÙ-generate:7c713d04-0492-db46-c8fe-397cf2b1d4cb¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@f084451e54474bb9142cf0b91f19e06233f566710a2fcc67d7f5bfd5f830a102¢tsËAÚöâf5¨trace_idÙ$4f243b6b-2092-425f-84aa-c16cb7e21697­parent_run_idÙ$fc778011-a6c5-4cf5-88d9-a85f974cae92¦run_idÙ$4f243b6b-2092-425f-84aa-c16cb7e21697ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚcmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe a use case for `RecursiveCharacterTextSplitter`. \nContext: :::\n\n### Text-structured based\n\nText is naturally organized into hierarchical units such as paragraphs, sentences, and words. \nWe can leverage this inherent structure to inform our splitting strategy, creating split that maintain natural language flow, maintain semantic coherence within split, and adapts to varying levels of text granularity.\nLangChain\'s [`RecursiveCharacterTextSplitter`](/docs/how_to/recursive_text_splitter/) implements this concept:\n- The `RecursiveCharacterTextSplitter` attempts to keep larger units (e.g., paragraphs) intact.\n- If a unit exceeds the chunk size, it moves to the next level (e.g., sentences).\n- This process continues down to the word level if necessary.\n\nHere is example usage:\n\n```python\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=0)\ntexts = text_splitter.split_text(document)\n```\n\n:::info[Further reading]\n\nExample implementation using LangChain\'s `CharacterTextSplitter` with token-based splitting:\n\n```python\nfrom langchain_text_splitters import CharacterTextSplitter\ntext_splitter = CharacterTextSplitter.from_tiktoken_encoder(\n    encoding_name="cl100k_base", chunk_size=100, chunk_overlap=0\n)\ntexts = text_splitter.split_text(document)\n```\n\n:::info[Further reading]\n\n* See the how-to guide for [token-based](/docs/how_to/split_by_token/) splitting.\n* See the how-to guide for [character-based](/docs/how_to/character_text_splitter/) splitting.\n\n:::\n\n### Text-structured based\n\n# Text splitters\n<span data-heading-keywords="text splitter,text splitting"></span>\n\n:::info[Prerequisites]\n\n* [Documents](/docs/concepts/retrievers/#interface)\n* Tokenization(/docs/concepts/tokens)\n:::\n\n## Overview\n\nDocument splitting is often a crucial preprocessing step for many applications.\nIt involves breaking down large texts into smaller, manageable chunks.\nThis process offers several benefits, such as ensuring consistent processing of varying document lengths, overcoming input size limitations of models, and improving the quality of text representations used in retrieval systems.\nThere are several strategies for splitting documents, each with its own advantages.\n\n## Key concepts\n\n![Conceptual Overview](/img/text_splitters.png)\n\nText splitters split documents into smaller chunks for use in downstream applications.\n\n## Why split documents?\n\nThere are several reasons to split documents:\n\n:::info[Further reading]\n\n* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).\n\n:::\n\n### Document-structured based\n\nSome documents have an inherent structure, such as HTML, Markdown, or JSON files. \nIn these cases, it\'s beneficial to split the document based on its structure, as it often naturally groups semantically related text.\nKey benefits of structure-based splitting:\n- Preserves the logical organization of the document\n- Maintains context within each chunk\n- Can be more effective for downstream tasks like retrieval or summarization\n\nExamples of structure-based splitting:\n- **Markdown**: Split based on headers (e.g., #, ##, ###)\n- **HTML**: Split using tags\n- **JSON**: Split by object or array elements\n- **Code**: Split by functions, classes, or logical blocks\n\n:::info[Further reading]\n\n:::info[Further reading]\n\n* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).\n* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).\n* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).\n* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).\n\n:::\n\n### Semantic meaning based\n\nUnlike the previous methods, semantic-based splitting actually considers the *content* of the text. \nWhile other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text\'s semantics.\nThere are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.\nAs an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4e203d6b94f9f83f2628a2a7f5350aa5f35f8fac04a75c98fcb40f54ee965329¢tsËAÚöã?–¨focus_msÍ	…§payload‚¤role©assistant§contentÚûA use case for `RecursiveCharacterTextSplitter` is to preprocess large documents for natural language processing tasks by breaking them into smaller, manageable chunks while preserving the hierarchical structure of the text. This ensures that larger units like paragraphs remain intact, maintaining semantic coherence, which is beneficial for tasks such as retrieval or summarization. For example, it can be used to split a lengthy article into smaller sections without losing the context of each paragraph.ªfocus_kind¬exec_latency¨query_id¤Q090‰¢idÙ@2de32273c05919bb19da9f8af034afe6ed9f453b6186003e9bfa5dd9414759b9¢tsËAÚöãSD¨trace_idÙ$fc778011-a6c5-4cf5-88d9-a85f974cae92­parent_run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944¦run_idÙ$fc778011-a6c5-4cf5-88d9-a85f974cae92ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚûA use case for `RecursiveCharacterTextSplitter` is to preprocess large documents for natural language processing tasks by breaking them into smaller, manageable chunks while preserving the hierarchical structure of the text. This ensures that larger units like paragraphs remain intact, maintaining semantic coherence, which is beneficial for tasks such as retrieval or summarization. For example, it can be used to split a lengthy article into smaller sections without losing the context of each paragraph.¨query_id¤Q090ªfocus_kind¶chain_execution_result‰¢idÙ@2ad8c3b4b05e6e3ff8f8210a2b86722264cfc67062bfcf868133c3cfa7e1b8c4¢tsËAÚöãac¨trace_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944­parent_run_idÀ¦run_idÙ$80eb200a-aca1-46a2-b65f-64ab250b9944ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answerÚûA use case for `RecursiveCharacterTextSplitter` is to preprocess large documents for natural language processing tasks by breaking them into smaller, manageable chunks while preserving the hierarchical structure of the text. This ensures that larger units like paragraphs remain intact, maintaining semantic coherence, which is beneficial for tasks such as retrieval or summarization. For example, it can be used to split a lengthy article into smaller sections without losing the context of each paragraph.¨query_id¤Q090ªfocus_kind¶chain_execution_result‹¢idÙ@bf67da68b0eeb2a5329c052e0e5cee1195067fd51146440f7a48193c75c0ef14¢tsËAÚöãƒ˜¨trace_id¤Q091­parent_run_idÀ¦run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.¨query_id¤Q091§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q091ªfocus_kind¯chain_execution‹¢idÙ@4f8867fc8c11f93337f4e4b383fa1114c69d204da36ee945cefa8a8918bb1f29¢tsËAÚöã–¨trace_id¤Q091­parent_run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845a¦run_idÙ$ef4d8094-67fc-458a-b3ce-e81564b1440bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context¦answer ¨query_id¤Q091¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q091®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f48d09e0-d9c2-d2a8-acb3-03fb480f51d8ªfocus_kind¯chain_execution‰¢idÙ@e2205c2f57a885e9c0143dee329a9db24d449864e6208ae54bc183db5cbd631e¢tsËAÚöãœõ¨trace_idÙ$ef4d8094-67fc-458a-b3ce-e81564b1440b­parent_run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845a¦run_idÙ$ef4d8094-67fc-458a-b3ce-e81564b1440bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q091ªfocus_kind¶chain_execution_result‹¢idÙ@6ad85e17aa7be5871efe8742ca8a0eb14ea443af08eb6f544a22c0670312c8c2¢tsËAÚöã¨˜¨trace_id¤Q091­parent_run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845a¦run_idÙ$827c2cc6-a48a-47cf-b901-23d0bbcd00d7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q091¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q091®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:da08dcde-9801-03dc-34b0-0e3e29f789a4ªfocus_kind¯chain_execution‹¢idÙ@aab155d7eaaa62c823461424859b7d3fd0390b35468f330afcd1c118ae0cf5b6¢tsËAÚöã¯h¨trace_id¤Q091­parent_run_idÙ$827c2cc6-a48a-47cf-b901-23d0bbcd00d7¦run_idÙ$90f91d39-03c9-4f0d-b2cd-29db82f8bfa6ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ3Give two methods to stream output from a ChatModel.§contextÚKThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.

#### Usage with chat models

When using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM's output incrementally as it's being produced, which is particularly useful in interactive applications or interfaces.

#### Usage with LangGraph

[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.

## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).

1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astream** APIs when working with LangGraph. **Important** this is a LangGraph feature, so it is not available when working with pure LCEL. See [how to streaming custom data](https://langchain-ai.github.io/langgraph/how-tos/streaming-content/) for more information.
2. [dispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.dispatch_custom_event.html#) / [adispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.adispatch_custom_event.html) can be used to write custom data that will be surfaced through the **astream_events** API. See [how to dispatch custom callback events](/docs/how_to/callbacks_custom_events/#astream-events-api) for more information.

## "Auto-Streaming" Chat Models

model = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for event in chain.astream_events({"topic": "parrot"}):
    kind = event["event"]
    if kind == "on_chat_model_stream":
        print(event, end="|", flush=True)
```

You can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!

See [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.

## Writing custom data to the stream

To write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:

# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q091®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:da08dcde-9801-03dc-34b0-0e3e29f789a4­checkpoint_nsÙ-generate:da08dcde-9801-03dc-34b0-0e3e29f789a4¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@52556342d6c81c87dbfef86c50e7d52663c8e2c1b281e8104722d856730cda56¢tsËAÚöã¸o¨trace_idÙ$90f91d39-03c9-4f0d-b2cd-29db82f8bfa6­parent_run_idÙ$827c2cc6-a48a-47cf-b901-23d0bbcd00d7¦run_idÙ$90f91d39-03c9-4f0d-b2cd-29db82f8bfa6ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Give two methods to stream output from a ChatModel. \nContext: The [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.\n\n#### Usage with chat models\n\nWhen using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM\'s output incrementally as it\'s being produced, which is particularly useful in interactive applications or interfaces.\n\n#### Usage with LangGraph\n\n[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.\n\n## Streaming APIs\n\nLangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).\n\n1. LangGraph\'s [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astream** APIs when working with LangGraph. **Important** this is a LangGraph feature, so it is not available when working with pure LCEL. See [how to streaming custom data](https://langchain-ai.github.io/langgraph/how-tos/streaming-content/) for more information.\n2. [dispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.dispatch_custom_event.html#) / [adispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.adispatch_custom_event.html) can be used to write custom data that will be surfaced through the **astream_events** API. See [how to dispatch custom callback events](/docs/how_to/callbacks_custom_events/#astream-events-api) for more information.\n\n## "Auto-Streaming" Chat Models\n\nmodel = ChatAnthropic(model="claude-3-sonnet-20240229")\n\nprompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")\nparser = StrOutputParser()\nchain = prompt | model | parser\n\nasync for event in chain.astream_events({"topic": "parrot"}):\n    kind = event["event"]\n    if kind == "on_chat_model_stream":\n        print(event, end="|", flush=True)\n```\n\nYou can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!\n\nSee [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.\n\n## Writing custom data to the stream\n\nTo write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:\n\n# Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@55292559c845fde1f830f1bc54963ffb5f636bacc41f91ff4f253963b1f08196¢tsËAÚöãJ%‰¨focus_msÍ#§payload‚¤role©assistant§contentÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.ªfocus_kind¬exec_latency¨query_id¤Q091‰¢idÙ@0e6647f2d73cdedd6afa1a79a0c759cc2a5ad0b931c55045e82cb3f43a043304¢tsËAÚöãJ5¹¨trace_idÙ$827c2cc6-a48a-47cf-b901-23d0bbcd00d7­parent_run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845a¦run_idÙ$827c2cc6-a48a-47cf-b901-23d0bbcd00d7ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.¨query_id¤Q091ªfocus_kind¶chain_execution_result‰¢idÙ@c86293d1e8f5954dd4cb0d6144db1c77ad60bcc951b33ab8c6c31cec0af6b70f¢tsËAÚöãJ@ò¨trace_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845a­parent_run_idÀ¦run_idÙ$6ec52a70-daef-4885-bba5-6356d4cb845aªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.¨query_id¤Q091ªfocus_kind¶chain_execution_result‹¢idÙ@6baab62c691227de78bdf0f660738ba932b77e3d6bb9f7c6fd8524a0f0f5de6a¢tsËAÚöãJM©¨trace_id¤Q092­parent_run_idÀ¦run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?¨query_id¤Q092§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q092ªfocus_kind¯chain_execution‹¢idÙ@661727da6da04ce05b354a1c4f5d754424951991bb224ce7117de75f14f8cf22¢tsËAÚöãJY!¨trace_id¤Q092­parent_run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41¦run_idÙ$60ca8967-db9d-466d-af7a-b1552f8fa74cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context¦answer ¨query_id¤Q092¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q092®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d614f074-f669-77e2-e337-448cae8e21f8ªfocus_kind¯chain_execution‰¢idÙ@40d19cbd4ed32474fdaa0655756027c480e527e2a9d18155dfcbe0565f5c534c¢tsËAÚöã£ÃÁ¨trace_idÙ$60ca8967-db9d-466d-af7a-b1552f8fa74c­parent_run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41¦run_idÙ$60ca8967-db9d-466d-af7a-b1552f8fa74cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¨query_id¤Q092ªfocus_kind¶chain_execution_result‹¢idÙ@dbae69a27b8c6a2e8bbf3f0ee685051a0863acab19e8bbcee19118e1f2f386e0¢tsËAÚöã£Ì¯¨trace_id¤Q092­parent_run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41¦run_idÙ$eaf77756-c852-431b-9646-96a8b1d712f1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answer ¨query_id¤Q092¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q092®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:92965630-29ac-3dfe-964c-9e432b617534ªfocus_kind¯chain_execution‹¢idÙ@4c5a554dbe3d01e5fb25198d509ffd16f7543ddd318853f51aa8a405cada1cfe¢tsËAÚöã£ĞÀ¨trace_id¤Q092­parent_run_idÙ$eaf77756-c852-431b-9646-96a8b1d712f1¦run_idÙ$0b5a5609-ac95-49ce-bca9-227110ae7bd4ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§contextÚ,- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](/docs/how_to/hybrid)

The particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each word to a list of locations at which it occurs in various documents. 
Using this data structure, it is possible to efficiently match the words in search queries to the documents in which they appear.
[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

#### Vector indexes

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |

:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for context on how to build a retreiver using a graph database and text-to-Cypher.

:::

### Lexical search

As discussed in our conceptual review of [retrieval](/docs/concepts/retrieval/), many search engines are based upon matching words in a query to the words in each document. 
[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).
LangChain has retrievers for many popular lexical search algorithms / engines.

:::info[Further reading]

At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [how-to guide on hybrid search](/docs/how_to/hybrid/) for more details.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q092®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:92965630-29ac-3dfe-964c-9e432b617534­checkpoint_nsÙ-generate:92965630-29ac-3dfe-964c-9e432b617534¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c7d4ade1cfc47b15209e0c732e6262c0819f196297efb17cd2309cb586754fed¢tsËAÚöã£Ö™¨trace_idÙ$0b5a5609-ac95-49ce-bca9-227110ae7bd4­parent_run_idÙ$eaf77756-c852-431b-9646-96a8b1d712f1¦run_idÙ$0b5a5609-ac95-49ce-bca9-227110ae7bd4ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which document teaches you to build a hybrid search retriever combining keyword and vector? \nContext: - [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n- [How to: use hybrid vector and keyword retrieval](/docs/how_to/hybrid)\n\nThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).\nThis types of index contains a list of words and a mapping of each word to a list of locations at which it occurs in various documents. \nUsing this data structure, it is possible to efficiently match the words in search queries to the documents in which they appear.\n[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n#### Vector indexes\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |\n\n:::info[Further reading]\n\n* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.\n* See our [tutorial](/docs/tutorials/graph/) for context on how to build a retreiver using a graph database and text-to-Cypher.\n\n:::\n\n### Lexical search\n\nAs discussed in our conceptual review of [retrieval](/docs/concepts/retrieval/), many search engines are based upon matching words in a query to the words in each document. \n[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).\nLangChain has retrievers for many popular lexical search algorithms / engines.\n\n:::info[Further reading]\n\nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\nSee this [how-to guide on hybrid search](/docs/how_to/hybrid/) for more details. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@3cc89f2fbed0d532c31d467fc4bbe54da68e366fdfc19dc7900494934c6537f2¢tsËAÚöåÉìæ¨focus_msÍ!’§payload‚¤role©assistant§contentÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.ªfocus_kind¬exec_latency¨query_id¤Q092‰¢idÙ@1c45e955d879493a0e9a6dfe43492d7b125f39e5e33de6a7a84d71f683e698f1¢tsËAÚöåÉıß¨trace_idÙ$eaf77756-c852-431b-9646-96a8b1d712f1­parent_run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41¦run_idÙ$eaf77756-c852-431b-9646-96a8b1d712f1ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.¨query_id¤Q092ªfocus_kind¶chain_execution_result‰¢idÙ@1906b4177a54c57110e6dcd1403ece93f1313c66c459a7383cd25b2620557393¢tsËAÚöåÊ	–¨trace_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41­parent_run_idÀ¦run_idÙ$8ab02956-fd95-4430-9e76-994ce2e8eb41ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answerÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.¨query_id¤Q092ªfocus_kind¶chain_execution_result‹¢idÙ@1dd3ed6a5f51668c6c79edabab4effcdbb9d744b30c9c9f6ad1d6c0bf97a5efc¢tsËAÚöåÊ¨trace_id¤Q093­parent_run_idÀ¦run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eacªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?¨query_id¤Q093§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q093ªfocus_kind¯chain_execution‹¢idÙ@ef7b4f4b8cfeb0dcceb69a3bfefa55cd0a8108fb860daa14e864841cd564bd6a¢tsËAÚöåÊ!¨trace_id¤Q093­parent_run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eac¦run_idÙ$2631a28f-0938-4533-83c1-9fb2de4d0dfdªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context¦answer ¨query_id¤Q093¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q093®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3568c01d-4eec-5592-f417-02ae8a0363cfªfocus_kind¯chain_execution‰¢idÙ@8245d4cb9c89e0aed2de47dce8a823214a5290e7429f1d82332eff53faab4368¢tsËAÚöåæcĞ¨trace_idÙ$2631a28f-0938-4533-83c1-9fb2de4d0dfd­parent_run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eac¦run_idÙ$2631a28f-0938-4533-83c1-9fb2de4d0dfdªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¨query_id¤Q093ªfocus_kind¶chain_execution_result‹¢idÙ@f5838c52332766feeb4cd64bc988713c5c54757d89337705ba95daa2a8520f09¢tsËAÚöåæq`¨trace_id¤Q093­parent_run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eac¦run_idÙ$d82a383d-bb0b-4268-be21-5249cf5fb6d3ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¦answer ¨query_id¤Q093¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q093®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e2d484ab-43b8-5314-b89a-c4b8f91c3f83ªfocus_kind¯chain_execution‹¢idÙ@159f5b6e1d5ece9c07dff490392cec9a005cbd5f35a30cb53779d29fc7714396¢tsËAÚöåæwy¨trace_id¤Q093­parent_run_idÙ$d82a383d-bb0b-4268-be21-5249cf5fb6d3¦run_idÙ$aee77dc7-b4a5-4125-afdd-27f98768fed5ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§contextÚ™See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).

Please see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.

## Tool artifacts

## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that we want to make accessible to downstream components in our chain or agent, but that we don't want to expose to the model itself. For example if a tool returns a custom object, a dataframe or an image, we may want to pass some metadata about this output to the model without passing the actual output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.

```python
@tool(response_format="content_and_artifact")
def some_tool(...) -> Tuple[str, Any]:
    """Tool that does something."""
    ...
    return 'Message for chat model', some_artifact 
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working with, there are common types of objects that are typically allowed or recommended for structured output in Python.

The simplest and most common format for structured output is a JSON-like structure, which in Python can be represented as a dictionary (dict) or list (list).
JSON objects (or dicts in Python) are often used directly when the tool requires raw, flexible, and minimal-overhead structured data.

```json
{
  "answer": "The answer to the user's question",
  "followup_question": "A followup question the user could ask"
}
```

As a second example, [Pydantic](https://docs.pydantic.dev/latest/) is particularly useful for defining structured output schemas because it offers type hints and validation.
Here's an example of a Pydantic schema:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q093®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e2d484ab-43b8-5314-b89a-c4b8f91c3f83­checkpoint_nsÙ-generate:e2d484ab-43b8-5314-b89a-c4b8f91c3f83¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3e352365b9d7630fa489831735fbb7884440ea3885f946406e9badb0a5168403¢tsËAÚöåæ¨trace_idÙ$aee77dc7-b4a5-4125-afdd-27f98768fed5­parent_run_idÙ$d82a383d-bb0b-4268-be21-5249cf5fb6d3¦run_idÙ$aee77dc7-b4a5-4125-afdd-27f98768fed5ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the purpose of `annotated` type hints in tool schemas? \nContext: See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\n## Configuring the schema\n\nThe `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description\nor parse the function\'s doc-string to infer the schema).\n\nPlease see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.\n\n## Tool artifacts\n\n## Tool artifacts\n\n**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool\'s execution that we want to make accessible to downstream components in our chain or agent, but that we don\'t want to expose to the model itself. For example if a tool returns a custom object, a dataframe or an image, we may want to pass some metadata about this output to the model without passing the actual output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.\n\n```python\n@tool(response_format="content_and_artifact")\ndef some_tool(...) -> Tuple[str, Any]:\n    """Tool that does something."""\n    ...\n    return \'Message for chat model\', some_artifact \n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\n## Schema definition\n\nThe central concept is that the output structure of model responses needs to be represented in some way. \nWhile types of objects you can use depend on the model you\'re working with, there are common types of objects that are typically allowed or recommended for structured output in Python.\n\nThe simplest and most common format for structured output is a JSON-like structure, which in Python can be represented as a dictionary (dict) or list (list).\nJSON objects (or dicts in Python) are often used directly when the tool requires raw, flexible, and minimal-overhead structured data.\n\n```json\n{\n  "answer": "The answer to the user\'s question",\n  "followup_question": "A followup question the user could ask"\n}\n```\n\nAs a second example, [Pydantic](https://docs.pydantic.dev/latest/) is particularly useful for defining structured output schemas because it offers type hints and validation.\nHere\'s an example of a Pydantic schema: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2fcea393f72f7657305546f8b65c56bb166753d2a686d2cc34c5dc2cae51f450¢tsËAÚöæêh‡¨focus_msÍÜ§payload‚¤role©assistant§contentÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.ªfocus_kind¬exec_latency¨query_id¤Q093‰¢idÙ@6873e83aefc72d37d90547bd8536427e2279f6a4d5f43f704a131f95680819f8¢tsËAÚöæê{•¨trace_idÙ$d82a383d-bb0b-4268-be21-5249cf5fb6d3­parent_run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eac¦run_idÙ$d82a383d-bb0b-4268-be21-5249cf5fb6d3ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.¨query_id¤Q093ªfocus_kind¶chain_execution_result‰¢idÙ@f808b06f53acb7a2e2678caca3563ff406dd4060d86e8e23879119df4dbbde06¢tsËAÚöæê™ò¨trace_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eac­parent_run_idÀ¦run_idÙ$e019fd76-119f-47bc-b8d6-20289cb12eacªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¦answerÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.¨query_id¤Q093ªfocus_kind¶chain_execution_result‹¢idÙ@9226463d8ad1841b6fc268bb26ec2b8cde9232474166c3ab9d785ee309a5ce55¢tsËAÚöæêª¨trace_id¤Q094­parent_run_idÀ¦run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.¨query_id¤Q094§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q094ªfocus_kind¯chain_execution‹¢idÙ@042e268eb07c2d14a6e97d5db5682342e23484e20e71d4ab7de6e967dbafe8c4¢tsËAÚöæêÀÊ¨trace_id¤Q094­parent_run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6¦run_idÙ$cc2cdf8b-dda3-45ac-bb29-da86551b1c4aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.§context¦answer ¨query_id¤Q094¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q094®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:331dd838-0de1-1e32-82a6-b4b1d1a2adecªfocus_kind¯chain_execution‰¢idÙ@ef1129249c5766bd4afe390799ff14d3e34edf949a8e5cb7254bf6939d79f700¢tsËAÚöæúÇâ¨trace_idÙ$cc2cdf8b-dda3-45ac-bb29-da86551b1c4a­parent_run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6¦run_idÙ$cc2cdf8b-dda3-45ac-bb29-da86551b1c4aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q094ªfocus_kind¶chain_execution_result‹¢idÙ@cdb372c891403f5c6e55dd97d6825c4f794ec2cb649bd454d947a5648c56bc29¢tsËAÚöæúÏ5¨trace_id¤Q094­parent_run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6¦run_idÙ$1745cf4d-163a-4fe6-9eaa-1f44ad50bca9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q094¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q094®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3a59f56d-5a72-fab1-af9c-ce4ad433d5f6ªfocus_kind¯chain_execution‹¢idÙ@493c67b2ae6971dbeb0eb4ac6ddd5a289d35a0b2b8ff2202c97c77ec39039f64¢tsËAÚöæúÓ¨trace_id¤Q094­parent_run_idÙ$1745cf4d-163a-4fe6-9eaa-1f44ad50bca9¦run_idÙ$8761f2de-70a8-4754-b417-f438bbeb10a8ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ8Explain why caching chat model responses is challenging.§contextÚ¡### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

A semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.

However, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.

Please see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.

## Related resources

* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).
* List of supported chat models: [chat model integrations](/docs/integrations/chat/).

### Conceptual guides

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q094®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3a59f56d-5a72-fab1-af9c-ce4ad433d5f6­checkpoint_nsÙ-generate:3a59f56d-5a72-fab1-af9c-ce4ad433d5f6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@e2be19a08352c6523aa8109405e9f53b6319dce97c7a950ffbdf1dac2fdbf9bc¢tsËAÚöæúÚ¨trace_idÙ$8761f2de-70a8-4754-b417-f438bbeb10a8­parent_run_idÙ$1745cf4d-163a-4fe6-9eaa-1f44ad50bca9¦run_idÙ$8761f2de-70a8-4754-b417-f438bbeb10a8ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ\messages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain why caching chat model responses is challenging. \nContext: ### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\nA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.\n\nHowever, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.\n\nPlease see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.\n\n## Related resources\n\n* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).\n* List of supported chat models: [chat model integrations](/docs/integrations/chat/).\n\n### Conceptual guides\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n# Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@85cd3ccb96d76049e79e9a0b4e0d20c30cf9a398bfbd7c4d5976382a157aaee7¢tsËAÚöç`Œ½¨focus_msÍ4§payload‚¤role©assistant§contentÚØCaching chat model responses is challenging because exact inputs are unlikely to repeat after the initial interactions in a conversation, making cache hits rare. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.ªfocus_kind¬exec_latency¨query_id¤Q094‰¢idÙ@8cb3ec082517c40198517901940899971faaedc8229f9d0b21a1dbd5166f1825¢tsËAÚöç` õ¨trace_idÙ$1745cf4d-163a-4fe6-9eaa-1f44ad50bca9­parent_run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6¦run_idÙ$1745cf4d-163a-4fe6-9eaa-1f44ad50bca9ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚØCaching chat model responses is challenging because exact inputs are unlikely to repeat after the initial interactions in a conversation, making cache hits rare. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.¨query_id¤Q094ªfocus_kind¶chain_execution_result‰¢idÙ@0aaab6965c01485e7ed3c97c1aeea25d3559d86225404fe876ddcc8cd2595889¢tsËAÚöç`«¸¨trace_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6­parent_run_idÀ¦run_idÙ$28654db2-870b-461b-92f1-74d5b123b5d6ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ8Explain why caching chat model responses is challenging.§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚØCaching chat model responses is challenging because exact inputs are unlikely to repeat after the initial interactions in a conversation, making cache hits rare. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.¨query_id¤Q094ªfocus_kind¶chain_execution_result‹¢idÙ@7705676f3f1a6de864bf9b2b1db2334fde2e22f6d8e890415a86174d935f6c73¢tsËAÚöç`¸w¨trace_id¤Q095­parent_run_idÀ¦run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?¨query_id¤Q095§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q095ªfocus_kind¯chain_execution‹¢idÙ@75e51b044afd496c624f30e4e70340d15f3e4e26e014590d76e521bc7681c084¢tsËAÚöç`ÈT¨trace_id¤Q095­parent_run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384¦run_idÙ$adfa65a6-1c68-43cd-9bd9-1f1d5a5a03a5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context¦answer ¨query_id¤Q095¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q095®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:bf82d0fd-bfeb-ec91-d345-f5cf6dc3b6e4ªfocus_kind¯chain_execution‰¢idÙ@ed4e68711afdec83a8fb4901f43277302046a1568de4649e3784e4539c308dd2¢tsËAÚöç4r¨trace_idÙ$adfa65a6-1c68-43cd-9bd9-1f1d5a5a03a5­parent_run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384¦run_idÙ$adfa65a6-1c68-43cd-9bd9-1f1d5a5a03a5ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q095ªfocus_kind¶chain_execution_result‹¢idÙ@3fa4cede541e07ca6f3919cee5d01ad402b87018136351ae3eaf080ad20afaaf¢tsËAÚöç=l¨trace_id¤Q095­parent_run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384¦run_idÙ$97348986-fd3f-41ba-8560-60bd27137f53ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q095¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q095®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:896d378f-1f52-0173-07ab-09450205a10cªfocus_kind¯chain_execution‹¢idÙ@729e3012ffce9c8d8fda3344df1315955d2079106568e039141500edc6153ee2¢tsËAÚöçCÈ¨trace_id¤Q095­parent_run_idÙ$97348986-fd3f-41ba-8560-60bd27137f53¦run_idÙ$55203b78-df5b-4958-a335-8169fdc171ceªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIWhich two docs together explain trimming long documents before embedding?§contextÚ## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_text_splitter)
- [How to: split HTML](/docs/how_to/split_html)
- [How to: split by character](/docs/how_to/character_text_splitter)
- [How to: split code](/docs/how_to/code_splitter)
- [How to: split Markdown by headers](/docs/how_to/markdown_header_metadata_splitter)
- [How to: recursively split JSON](/docs/how_to/recursive_json_splitter)
- [How to: split text into semantic chunks](/docs/how_to/semantic-chunker)
- [How to: split by tokens](/docs/how_to/split_by_token)

### Embedding models

[Embedding Models](/docs/concepts/embedding_models) take a piece of text and create a numerical representation of it.
See [supported integrations](/docs/integrations/text_embedding/) for details on getting started with embedding models from a specific provider.

- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model limitations**: Many embedding models and language models have maximum input size constraints. Splitting allows us to process documents that would otherwise exceed these limits.
- **Improving representation quality**: For longer documents, the quality of embeddings or other representations may degrade as they try to capture too much information. Splitting can lead to more focused and accurate representations of each section.
- **Enhancing retrieval precision**: In information retrieval systems, splitting can improve the granularity of search results, allowing for more precise matching of queries to relevant document sections.
- **Optimizing computational resources**: Working with smaller chunks of text can be more memory-efficient and allow for better parallelization of processing tasks.

Now, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkviz.up.railway.app/) to visualize different splitting strategies discussed below.
:::

## Approaches

### Length-based

The most intuitive strategy is to split documents based on their length. This simple yet effective approach ensures that each chunk doesn't exceed a specified size limit.
Key benefits of length-based splitting:
- Straightforward implementation
- Consistent chunk sizes
- Easily adaptable to different model requirements

Types of length-based splitting:
- **Token-based**: Splits text based on the number of tokens, which is useful when working with language models.
- **Character-based**: Splits text based on the number of characters, which can be more consistent across different types of text.

| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are best indexed by themselves, but best retrieved all together. | This involves indexing multiple chunks for each document. Then you find the chunks that are most similar in embedding space, but you retrieve the whole parent document and return that (rather than individual chunks). |
| [Multi Vector](/docs/how_to/multi_vector/)                | Vector store + Document Store | Sometimes during indexing | If you are able to extract information from documents that you think is more relevant to index than the text itself.                    | This involves creating multiple vectors for each document. Each vector could be created in a myriad of ways - examples include summaries of the text and hypothetical questions.                                         |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q095®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:896d378f-1f52-0173-07ab-09450205a10c­checkpoint_nsÙ-generate:896d378f-1f52-0173-07ab-09450205a10c¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@66d3c3a517f98335eff03764464dccfa8d1c4698b846a53098f63ae895746f20¢tsËAÚöçN+¨trace_idÙ$55203b78-df5b-4958-a335-8169fdc171ce­parent_run_idÙ$97348986-fd3f-41ba-8560-60bd27137f53¦run_idÙ$55203b78-df5b-4958-a335-8169fdc171ceªevent_type¬chain_output¬event_source¥chain§payload§outputsÚômessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two docs together explain trimming long documents before embedding? \nContext: ## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\n### Text splitters\n\n[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.\n\n- [How to: recursively split text](/docs/how_to/recursive_text_splitter)\n- [How to: split HTML](/docs/how_to/split_html)\n- [How to: split by character](/docs/how_to/character_text_splitter)\n- [How to: split code](/docs/how_to/code_splitter)\n- [How to: split Markdown by headers](/docs/how_to/markdown_header_metadata_splitter)\n- [How to: recursively split JSON](/docs/how_to/recursive_json_splitter)\n- [How to: split text into semantic chunks](/docs/how_to/semantic-chunker)\n- [How to: split by tokens](/docs/how_to/split_by_token)\n\n### Embedding models\n\n[Embedding Models](/docs/concepts/embedding_models) take a piece of text and create a numerical representation of it.\nSee [supported integrations](/docs/integrations/text_embedding/) for details on getting started with embedding models from a specific provider.\n\n- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.\n- **Overcoming model limitations**: Many embedding models and language models have maximum input size constraints. Splitting allows us to process documents that would otherwise exceed these limits.\n- **Improving representation quality**: For longer documents, the quality of embeddings or other representations may degrade as they try to capture too much information. Splitting can lead to more focused and accurate representations of each section.\n- **Enhancing retrieval precision**: In information retrieval systems, splitting can improve the granularity of search results, allowing for more precise matching of queries to relevant document sections.\n- **Optimizing computational resources**: Working with smaller chunks of text can be more memory-efficient and allow for better parallelization of processing tasks.\n\nNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.\n\n:::info[Further reading]\n* See Greg Kamradt's [chunkviz](https://chunkviz.up.railway.app/) to visualize different splitting strategies discussed below.\n:::\n\n## Approaches\n\n### Length-based\n\nThe most intuitive strategy is to split documents based on their length. This simple yet effective approach ensures that each chunk doesn't exceed a specified size limit.\nKey benefits of length-based splitting:\n- Straightforward implementation\n- Consistent chunk sizes\n- Easily adaptable to different model requirements\n\nTypes of length-based splitting:\n- **Token-based**: Splits text based on the number of tokens, which is useful when working with language models.\n- **Character-based**: Splits text based on the number of characters, which can be more consistent across different types of text.\n\n| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are best indexed by themselves, but best retrieved all together. | This involves indexing multiple chunks for each document. Then you find the chunks that are most similar in embedding space, but you retrieve the whole parent document and return that (rather than individual chunks). |\n| [Multi Vector](/docs/how_to/multi_vector/)                | Vector store + Document Store | Sometimes during indexing | If you are able to extract information from documents that you think is more relevant to index than the text itself.                    | This involves creating multiple vectors for each document. Each vector could be created in a myriad of ways - examples include summaries of the text and hypothetical questions.                                         | \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ad18c6612a4ee6f529bed7f25404823ebdba41de31661ea52e494aae00cc52b1¢tsËAÚöçÄ8°¨focus_msÍ*§payload‚¤role©assistant§contentÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.ªfocus_kind¬exec_latency¨query_id¤Q095‰¢idÙ@7f33f0c0cb0bba918b2135b4d81ecd879f7f36156186c1974d06b944dc208119¢tsËAÚöçÄK¨trace_idÙ$97348986-fd3f-41ba-8560-60bd27137f53­parent_run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384¦run_idÙ$97348986-fd3f-41ba-8560-60bd27137f53ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.¨query_id¤Q095ªfocus_kind¶chain_execution_result‰¢idÙ@08c4d539e24d8dfeaabdfc81e9015bf0b789e85d048ec0fa957ffe09b7c5d764¢tsËAÚöçÄYÀ¨trace_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384­parent_run_idÀ¦run_idÙ$b491b75f-aa5d-4ea1-a590-e97f2ceb4384ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.¨query_id¤Q095ªfocus_kind¶chain_execution_result‹¢idÙ@e5716913577438dce4421eab920da8602cc309bb94044e55743ddaa7af52c2a0¢tsËAÚöçÄb–¨trace_id¤Q096­parent_run_idÀ¦run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67efªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?¨query_id¤Q096§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q096ªfocus_kind¯chain_execution‹¢idÙ@0c52041ea8025a9b0365844cc9953ba3df831c0d10676564162d0893141bc247¢tsËAÚöçÄk'¨trace_id¤Q096­parent_run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67ef¦run_idÙ$b06d7fee-d61d-4281-8559-71b6d3683120ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context¦answer ¨query_id¤Q096¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q096®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d938b0a1-4b21-d71c-08f8-836086c3ed22ªfocus_kind¯chain_execution‰¢idÙ@a1b9eb3146e3f10794b5226a150e56e1b2d038f5afc8a6eb7a48baac7f9fee00¢tsËAÚöçã„Œ¨trace_idÙ$b06d7fee-d61d-4281-8559-71b6d3683120­parent_run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67ef¦run_idÙ$b06d7fee-d61d-4281-8559-71b6d3683120ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¨query_id¤Q096ªfocus_kind¶chain_execution_result‹¢idÙ@b03252426befb72ee313e81b5acbf4287a2cd0de91f8c8a580798b169d2263d5¢tsËAÚöçã‘¬¨trace_id¤Q096­parent_run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67ef¦run_idÙ$50efd052-6299-4501-9800-7de1699b3b8eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¦answer ¨query_id¤Q096¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q096®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3256ceae-4166-d53a-bb8b-c67aecd86eacªfocus_kind¯chain_execution‹¢idÙ@1305badc5a6778e49f466bac4bdaa81158af71d393664d8dbbe83f25622746b9¢tsËAÚöçã™-¨trace_id¤Q096­parent_run_idÙ$50efd052-6299-4501-9800-7de1699b3b8e¦run_idÙ$058df1ce-5023-4862-9d25-db7aedf86b58ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§contextÚ### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects](/docs/how_to/output_parser_string)
- [How to: use output parsers to parse an LLM response into structured format](/docs/how_to/output_parser_structured)
- [How to: parse JSON output](/docs/how_to/output_parser_json)
- [How to: parse XML output](/docs/how_to/output_parser_xml)
- [How to: parse YAML output](/docs/how_to/output_parser_yaml)
- [How to: retry when output parsing errors occur](/docs/how_to/output_parser_retry)
- [How to: try to fix errors in output parsing](/docs/how_to/output_parser_fixing)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)

### Document loaders

[Document Loaders](/docs/concepts/document_loaders) are responsible for loading documents from a variety of sources.

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_caching)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: stream a response back](/docs/how_to/streaming_llm)
- [How to: track token usage](/docs/how_to/llm_token_usage_tracking)
- [How to: work with local models](/docs/how_to/local_llms)

### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSON output.
You can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).
Here is an example of how to use JSON mode with OpenAI:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")
ai_msg = model.invoke("Return a JSON object with key 'random_ints' and a value of 10 random ints in [0-99]")
ai_msg
{'random_ints': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}
```

## Structured output method 

There are a few challenges when producing structured output with the above methods: 

(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.

| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputParser)                            |                    | âœ…                       |           | `str` \| `Message` | `Dict[str, str]`     | An output parser that returns structured information. It is less powerful than other output parsers since it only allows for fields to be strings. This can be useful when you are working with smaller LLMs.                                            |

| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…                  | âœ…                       |           | `str` \| `Message` | JSON object          | Returns a JSON object as specified. You can specify a Pydantic model and it will return JSON for that model. Probably the most reliable output parser for getting structured data that does NOT use function calling.                                    |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q096®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3256ceae-4166-d53a-bb8b-c67aecd86eac­checkpoint_nsÙ-generate:3256ceae-4166-d53a-bb8b-c67aecd86eac¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@373eeeb664309f25ddc946e585e1a658e25b47bb82a53f9f56d5dce4a06df4c4¢tsËAÚöçã #¨trace_idÙ$058df1ce-5023-4862-9d25-db7aedf86b58­parent_run_idÙ$50efd052-6299-4501-9800-7de1699b3b8e¦run_idÙ$058df1ce-5023-4862-9d25-db7aedf86b58ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚúmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What class enables you to get structured JSON output directly from LLMS without a parser? \nContext: ### Output parsers\n\n[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.\n\n- [How to: parse text from message objects](/docs/how_to/output_parser_string)\n- [How to: use output parsers to parse an LLM response into structured format](/docs/how_to/output_parser_structured)\n- [How to: parse JSON output](/docs/how_to/output_parser_json)\n- [How to: parse XML output](/docs/how_to/output_parser_xml)\n- [How to: parse YAML output](/docs/how_to/output_parser_yaml)\n- [How to: retry when output parsing errors occur](/docs/how_to/output_parser_retry)\n- [How to: try to fix errors in output parsing](/docs/how_to/output_parser_fixing)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n\n### Document loaders\n\n[Document Loaders](/docs/concepts/document_loaders) are responsible for loading documents from a variety of sources.\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n- [How to: cache model responses](/docs/how_to/llm_caching)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: stream a response back](/docs/how_to/streaming_llm)\n- [How to: track token usage](/docs/how_to/llm_token_usage_tracking)\n- [How to: work with local models](/docs/how_to/local_llms)\n\n### Output parsers\n\n[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.\n\n### JSON mode\n\nIn addition to tool calling, some model providers support a feature called `JSON mode`. \nThis supports JSON schema definition as input and enforces the model to produce a conforming JSON output.\nYou can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).\nHere is an example of how to use JSON mode with OpenAI:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")\nai_msg = model.invoke("Return a JSON object with key \'random_ints\' and a value of 10 random ints in [0-99]")\nai_msg\n{\'random_ints\': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}\n```\n\n## Structured output method \n\nThere are a few challenges when producing structured output with the above methods: \n\n(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.\n\n| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputParser)                            |                    | âœ…                       |           | `str` \\| `Message` | `Dict[str, str]`     | An output parser that returns structured information. It is less powerful than other output parsers since it only allows for fields to be strings. This can be useful when you are working with smaller LLMs.                                            |\n\n| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…                  | âœ…                       |           | `str` \\| `Message` | JSON object          | Returns a JSON object as specified. You can specify a Pydantic model and it will return JSON for that model. Probably the most reliable output parser for getting structured data that does NOT use function calling.                                    | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@598b2c8c4d8ef12f2da76b44a08411a002fefff5596ff30c8952d11ad1b189a0¢tsËAÚöèÏŸ¨focus_msÍ/§payload‚¤role©assistant§contentÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.ªfocus_kind¬exec_latency¨query_id¤Q096‰¢idÙ@d4033629aea6005bcbadc03deccc8f7f70fa662d7f373ba5434b5f87b51f25e5¢tsËAÚöèáz¨trace_idÙ$50efd052-6299-4501-9800-7de1699b3b8e­parent_run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67ef¦run_idÙ$50efd052-6299-4501-9800-7de1699b3b8eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.¨query_id¤Q096ªfocus_kind¶chain_execution_result‰¢idÙ@e7adc45266523c6f5eb05dd43d32498e5ab333d3110c8fc00aec6c29de3e5208¢tsËAÚöèçÍ¨trace_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67ef­parent_run_idÀ¦run_idÙ$2c023a8f-e699-455f-b9d2-186fec8e67efªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¦answerÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.¨query_id¤Q096ªfocus_kind¶chain_execution_result‹¢idÙ@ca8da935dec171b39c1a91251248e3f2c78d8deaf06e82c3b51a072e08aa1252¢tsËAÚöèí¨trace_id¤Q097­parent_run_idÀ¦run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.¨query_id¤Q097§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q097ªfocus_kind¯chain_execution‹¢idÙ@4b4fbfbccd59460409723d37e5c5017fdd0c10d0898e9c07c1ebb2769ffa769d¢tsËAÚöèõÆ¨trace_id¤Q097­parent_run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58¦run_idÙ$fbaa0b53-312d-4c2e-98ee-69952685fb83ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.§context¦answer ¨query_id¤Q097¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q097®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3babe542-b453-91d9-9ea0-b015253c0094ªfocus_kind¯chain_execution‰¢idÙ@c11d71f8bde337d5330c356930cb978c7fc2e51e46f52527913880887c715a4a¢tsËAÚöè+3ø¨trace_idÙ$fbaa0b53-312d-4c2e-98ee-69952685fb83­parent_run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58¦run_idÙ$fbaa0b53-312d-4c2e-98ee-69952685fb83ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¨query_id¤Q097ªfocus_kind¶chain_execution_result‹¢idÙ@fb65e5e63d5898145c6eebc443449bc0e6df252eda82ee5b63593deb3dcebee8¢tsËAÚöè+Pn¨trace_id¤Q097­parent_run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58¦run_idÙ$e779f720-1240-4adb-8f65-4fe527e76d91ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.§context•‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¦answer ¨query_id¤Q097¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q097®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e78ae3af-2376-7600-b07e-1160ab773876ªfocus_kind¯chain_execution‹¢idÙ@9a94fbe64833d36f5cde80298c6499802489f876dfd88355282233ccd88bd129¢tsËAÚöè+Z¨trace_id¤Q097­parent_run_idÙ$e779f720-1240-4adb-8f65-4fe527e76d91¦run_idÙ$a4cabfd6-4f58-4d1f-8652-c3372fa836f7ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ<Name three built in message field keys aside from `content`.§contextÚÇ| Attribute            | Standardized/Raw | Description                                                                                                                                                                                                             |
|----------------------|:-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `content`            | Raw              | Usually a string, but can be a list of content blocks. See [content](#content) for details.                                                                                                                             |

### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary between different chat model providers.

Currently, most chat models support text as the primary content type, with some models also supporting multimodal data. However, support for multimodal data is still limited across most chat model providers.

For more information see:
* [SystemMessage](#systemmessage) -- for content which should be passed to direct the conversation
* [HumanMessage](#humanmessage) -- for content in the input from the user.
* [AIMessage](#aimessage) -- for content in the response from the model.
* [Multimodality](/docs/concepts/multimodality) -- for more information on multimodal content.

### Other Message Data

Depending on the chat model provider, messages can include other data such as:

## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the message (e.g., text, multimodal data).
- Additional metadata: id, name, [token usage](/docs/concepts/tokens) and other model-specific metadata.

### Role

Roles are used to distinguish between different types of messages in a conversation and help the chat model understand how to respond to a given sequence of messages.

# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to represent the input and output of a chat model, as well as any additional context or metadata that may be associated with a conversation.

Each message has a **role** (e.g., "user", "assistant") and **content** (e.g., text, multimodal data) with additional metadata that varies depending on the chat model provider.

LangChain provides a unified message format that can be used across chat models, allowing users to work with different chat models without worrying about the specific details of the message format used by each model provider.

## What is inside a message?

A message typically consists of the following pieces of information:

#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list of dictionaries** -- Each dictionary represents a content block and is associated with a `type`.
    * Used by Anthropic for surfacing agent thought process when doing [tool calling](/docs/concepts/tool_calling).
    * Used by OpenAI for audio outputs. Please see [multi-modal content](/docs/concepts/multimodality) for more information.

:::important
The **content** property is **not** standardized across different chat model providers, mostly because there are
still few examples to generalize from.
:::

### AIMessageChunk

It is common to [stream](/docs/concepts/streaming) responses for the chat model as they are being generated, so the user can see the response in real-time instead of waiting for the entire response to be generated before displaying it.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q097®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e78ae3af-2376-7600-b07e-1160ab773876­checkpoint_nsÙ-generate:e78ae3af-2376-7600-b07e-1160ab773876¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@1c6754e44b249751b7a92f9edc49f2a7831e0071d172b2d42a58835d2069f06d¢tsËAÚöè+h¨trace_idÙ$a4cabfd6-4f58-4d1f-8652-c3372fa836f7­parent_run_idÙ$e779f720-1240-4adb-8f65-4fe527e76d91¦run_idÙ$a4cabfd6-4f58-4d1f-8652-c3372fa836f7ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ§messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name three built in message field keys aside from `content`. \nContext: | Attribute            | Standardized/Raw | Description                                                                                                                                                                                                             |\n|----------------------|:-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `content`            | Raw              | Usually a string, but can be a list of content blocks. See [content](#content) for details.                                                                                                                             |\n\n### Content\n\nThe content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary between different chat model providers.\n\nCurrently, most chat models support text as the primary content type, with some models also supporting multimodal data. However, support for multimodal data is still limited across most chat model providers.\n\nFor more information see:\n* [SystemMessage](#systemmessage) -- for content which should be passed to direct the conversation\n* [HumanMessage](#humanmessage) -- for content in the input from the user.\n* [AIMessage](#aimessage) -- for content in the response from the model.\n* [Multimodality](/docs/concepts/multimodality) -- for more information on multimodal content.\n\n### Other Message Data\n\nDepending on the chat model provider, messages can include other data such as:\n\n## What is inside a message?\n\nA message typically consists of the following pieces of information:\n\n- **Role**: The role of the message (e.g., "user", "assistant").\n- **Content**: The content of the message (e.g., text, multimodal data).\n- Additional metadata: id, name, [token usage](/docs/concepts/tokens) and other model-specific metadata.\n\n### Role\n\nRoles are used to distinguish between different types of messages in a conversation and help the chat model understand how to respond to a given sequence of messages.\n\n# Messages\n\n:::info Prerequisites\n- [Chat Models](/docs/concepts/chat_models)\n:::\n\n## Overview\n\nMessages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to represent the input and output of a chat model, as well as any additional context or metadata that may be associated with a conversation.\n\nEach message has a **role** (e.g., "user", "assistant") and **content** (e.g., text, multimodal data) with additional metadata that varies depending on the chat model provider.\n\nLangChain provides a unified message format that can be used across chat models, allowing users to work with different chat models without worrying about the specific details of the message format used by each model provider.\n\n## What is inside a message?\n\nA message typically consists of the following pieces of information:\n\n#### content\n\nThe **content** property of an `AIMessage` represents the response generated by the chat model.\n\nThe content is either:\n\n- **text** -- the norm for virtually all chat models.\n- A **list of dictionaries** -- Each dictionary represents a content block and is associated with a `type`.\n    * Used by Anthropic for surfacing agent thought process when doing [tool calling](/docs/concepts/tool_calling).\n    * Used by OpenAI for audio outputs. Please see [multi-modal content](/docs/concepts/multimodality) for more information.\n\n:::important\nThe **content** property is **not** standardized across different chat model providers, mostly because there are\nstill few examples to generalize from.\n:::\n\n### AIMessageChunk\n\nIt is common to [stream](/docs/concepts/streaming) responses for the chat model as they are being generated, so the user can see the response in real-time instead of waiting for the entire response to be generated before displaying it. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@af1cc53a806eb4cfff42f97a460c216265ffa251494674193f8a5c1a2a210a1a¢tsËAÚöè\™¨focus_msÍ §payload‚¤role©assistant§contentÙ°Three built-in message field keys aside from `content` are `role`, `id`, and `name`. These keys help distinguish the type of message and provide additional context or metadata.ªfocus_kind¬exec_latency¨query_id¤Q097‰¢idÙ@187dfc210f96e1189ee2e80b09b0d99bd2d992ab4c395f0e25427aa87afc2abd¢tsËAÚöè\óÓ¨trace_idÙ$e779f720-1240-4adb-8f65-4fe527e76d91­parent_run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58¦run_idÙ$e779f720-1240-4adb-8f65-4fe527e76d91ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ°Three built-in message field keys aside from `content` are `role`, `id`, and `name`. These keys help distinguish the type of message and provide additional context or metadata.¨query_id¤Q097ªfocus_kind¶chain_execution_result‰¢idÙ@f251e887846f25cebafe878e71c860f1c450b1688bb52995529b36d3618127db¢tsËAÚöè]'¨trace_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58­parent_run_idÀ¦run_idÙ$8a5fbeff-e3a4-44bb-a7dd-f3d935cbde58ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ<Name three built in message field keys aside from `content`.§context•‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¦answerÙ°Three built-in message field keys aside from `content` are `role`, `id`, and `name`. These keys help distinguish the type of message and provide additional context or metadata.¨query_id¤Q097ªfocus_kind¶chain_execution_result‹¢idÙ@93bb45e9c4cb4a56afae79f490b9be9f32ffee78c49ad31a1205099a3add0cde¢tsËAÚöè],<¨trace_id¤Q098­parent_run_idÀ¦run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?¨query_id¤Q098§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q098ªfocus_kind¯chain_execution‹¢idÙ@393bb9281131808444a35e69b7dd21320b25741aa1e1c57409a6c094b932c61a¢tsËAÚöè]=¨trace_id¤Q098­parent_run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107¦run_idÙ$9fc982a2-c90c-4574-9c00-fb1ce1bc6b3cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context¦answer ¨query_id¤Q098¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q098®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3d743f7d-52ab-f4b3-bd4b-17806482140fªfocus_kind¯chain_execution‰¢idÙ@9b22daed350ba700b751becc1cf935ba1c34d796409526948ac981dc3f79e5f5¢tsËAÚöèhÜ¨trace_idÙ$9fc982a2-c90c-4574-9c00-fb1ce1bc6b3c­parent_run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107¦run_idÙ$9fc982a2-c90c-4574-9c00-fb1ce1bc6b3cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q098ªfocus_kind¶chain_execution_result‹¢idÙ@a038133a46bc8c181ce866f2ab132b4a075db56ebe7ba11503b7adac8c2c12b6¢tsËAÚöèhªC¨trace_id¤Q098­parent_run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107¦run_idÙ$3c337f39-4d65-41bc-8ad0-c642741dfeb5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q098¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q098®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8ed948bc-ff00-64b9-720c-1c8d9de9fe38ªfocus_kind¯chain_execution‹¢idÙ@43757a6e4fe913b38c00a774cd6c0859e804c5c25bd51de05e100ac384850627¢tsËAÚöèh¶¨trace_id¤Q098­parent_run_idÙ$3c337f39-4d65-41bc-8ad0-c642741dfeb5¦run_idÙ$73a2abaf-d44b-4383-a77d-851b6e0ac3b8ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§contextÚœ## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

Please refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.

Runnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.

* invoke: Accepts an input and returns an output.
* batch: Accepts a list of inputs and returns a list of outputs.
* stream: Accepts an input and returns a generator that yields outputs.

The **input type** and **output type** vary by component:

- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline's progress.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q098®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8ed948bc-ff00-64b9-720c-1c8d9de9fe38­checkpoint_nsÙ-generate:8ed948bc-ff00-64b9-720c-1c8d9de9fe38¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@91d0b3e5cc2902fb3a4b5c01ced754f208764f0de85e1a0a5223670386e65d4e¢tsËAÚöèh¾Ë¨trace_idÙ$73a2abaf-d44b-4383-a77d-851b6e0ac3b8­parent_run_idÙ$3c337f39-4d65-41bc-8ad0-c642741dfeb5¦run_idÙ$73a2abaf-d44b-4383-a77d-851b6e0ac3b8ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ’messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the first step when creating a custom Runnable for streaming transformations? \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.\n\n## Input and output types\n\nEvery `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.\n\nRunnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.\n\n* invoke: Accepts an input and returns an output.\n* batch: Accepts a list of inputs and returns a list of outputs.\n* stream: Accepts an input and returns a generator that yields outputs.\n\nThe **input type** and **output type** vary by component:\n\n- **In LCEL Pipelines:**\nStreaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline\'s progress.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@af05b33390fa5189f58a13d97495eeb0b049733efa4c15901500ee0cb573b27f¢tsËAÚöèöWÖ¨focus_msÍ¤§payload‚¤role©assistant§contentÚˆThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be more complex and error-prone. For detailed guidance, refer to the "How to run custom functions" documentation.ªfocus_kind¬exec_latency¨query_id¤Q098‰¢idÙ@3dcd5987128042e0c2aa62dd7e8e3e71fbfc26d257bbfef40f7b78efa484c2af¢tsËAÚöèöj'¨trace_idÙ$3c337f39-4d65-41bc-8ad0-c642741dfeb5­parent_run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107¦run_idÙ$3c337f39-4d65-41bc-8ad0-c642741dfeb5ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚˆThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be more complex and error-prone. For detailed guidance, refer to the "How to run custom functions" documentation.¨query_id¤Q098ªfocus_kind¶chain_execution_result‰¢idÙ@e4636cea2ad2ee1b489c6d19caf13fa1387cc959d19fa995c16f81e6481e3611¢tsËAÚöèör´¨trace_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107­parent_run_idÀ¦run_idÙ$c4d241e2-620c-4d76-afd4-b04bf60c0107ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚˆThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be more complex and error-prone. For detailed guidance, refer to the "How to run custom functions" documentation.¨query_id¤Q098ªfocus_kind¶chain_execution_result‹¢idÙ@eaa3c3e1e65967006decd7f4f177e5ce14393c552082c9139fadeef179e8a23b¢tsËAÚöèöy¯¨trace_id¤Q099­parent_run_idÀ¦run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fbªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?¨query_id¤Q099§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q099ªfocus_kind¯chain_execution‹¢idÙ@9d54733242b7c3bb8fa2ab48096f7aec1aa762ad61ef666b524e9537da11a7fe¢tsËAÚöèöƒˆ¨trace_id¤Q099­parent_run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fb¦run_idÙ$7d5e7826-d36d-4d77-b778-7fd3f13ee1ffªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context¦answer ¨query_id¤Q099¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q099®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:b605d694-8afc-29b8-c7e5-744f0ee51efeªfocus_kind¯chain_execution‰¢idÙ@bbec42920b6f871be389673dff9a7461a91ff3c1c1554607ff7569d349576e17¢tsËAÚöé÷/¨trace_idÙ$7d5e7826-d36d-4d77-b778-7fd3f13ee1ff­parent_run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fb¦run_idÙ$7d5e7826-d36d-4d77-b778-7fd3f13ee1ffªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q099ªfocus_kind¶chain_execution_result‹¢idÙ@370e561384ead503f9b9a5a25901c9affc7f5447f7c6fa9536b84efedffdab28¢tsËAÚöéşv¨trace_id¤Q099­parent_run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fb¦run_idÙ$f218d9a1-587d-4329-9236-231e06dbd516ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q099¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q099®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f2502ffa-0c4b-c3a0-ae6e-e040b7f8c2a5ªfocus_kind¯chain_execution‹¢idÙ@9511108fd7f1aa92f627ee098c0ef083ea27a3d68003f43e76f0fb006084bae2¢tsËAÚöé6¨trace_id¤Q099­parent_run_idÙ$f218d9a1-587d-4329-9236-231e06dbd516¦run_idÙ$d6a5b38b-8bc8-4abd-a7ed-6bad764f27ecªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§contextÚP## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: These are models that are officially supported by LangChain and/or model provider. You can find these models in the `langchain-<provider>` packages.
2. **Community models**: There are models that are mostly contributed and supported by the community. You can find these models in the `langchain-community` package.

LangChain chat models are named with a convention that prefixes "Chat" to their class names (e.g., `ChatOllama`, `ChatAnthropic`, `ChatOpenAI`, etc.).

Please review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.
This diversity can make it challenging for developers to switch between providers or combine components when building applications.
LangChain exposes a standard interface for key components, making it easy to switch between providers.

* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/integrations/chat/) for an up-to-date list of supported models.
* Use either LangChain's [messages](/docs/concepts/messages) format or OpenAI format.
* Standard [tool calling API](/docs/concepts/tool_calling): standard interface for binding tools to models, accessing tool call requests made by models, and sending tool results back to the model.
* Standard API for [structuring outputs](/docs/concepts/structured_outputs/#structured-output-method) via the `with_structured_output` method.
* Provides support for [async programming](/docs/concepts/async), [efficient batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), [a rich streaming API](/docs/concepts/streaming).

## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](/docs/how_to/tool_calling)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: debug your LLM apps](/docs/how_to/debugging/)

## Components

These are the core building blocks you can use when building applications.

### Chat models

[Chat Models](/docs/concepts/chat_models) are newer forms of language models that take messages in and output a message.
See [supported integrations](/docs/integrations/chat/) for details on getting started with chat models from a specific provider.

Please review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suffix in their name typically refer to older models that do not follow the chat model interface and instead use an interface that takes a string as input and returns a string as output.
:::


## Interface

LangChain chat models implement the [BaseChatModel](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) interface. Because `BaseChatModel` also implements the [Runnable Interface](/docs/concepts/runnables), chat models support a [standard streaming interface](/docs/concepts/streaming), [async programming](/docs/concepts/async), optimized [batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), and more. Please see the [Runnable Interface](/docs/concepts/runnables) for more details.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q099®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f2502ffa-0c4b-c3a0-ae6e-e040b7f8c2a5­checkpoint_nsÙ-generate:f2502ffa-0c4b-c3a0-ae6e-e040b7f8c2a5¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@63d14b96fa54d58b5a43f26086fdc9bf38868f1af9d75ee6597ff6086e3bcf27¢tsËAÚöé
å¨trace_idÙ$d6a5b38b-8bc8-4abd-a7ed-6bad764f27ec­parent_run_idÙ$f218d9a1-587d-4329-9236-231e06dbd516¦run_idÙ$d6a5b38b-8bc8-4abd-a7ed-6bad764f27ecªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ6messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How does LangChain differentiate official vs community chat model integrations? \nContext: ## Integrations\n\nLangChain has many chat model integrations that allow you to use a wide variety of models from different providers.\n\nThese integrations are one of two types:\n\n1. **Official models**: These are models that are officially supported by LangChain and/or model provider. You can find these models in the `langchain-<provider>` packages.\n2. **Community models**: There are models that are mostly contributed and supported by the community. You can find these models in the `langchain-community` package.\n\nLangChain chat models are named with a convention that prefixes "Chat" to their class names (e.g., `ChatOllama`, `ChatAnthropic`, `ChatOpenAI`, etc.).\n\nPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.\nThis diversity can make it challenging for developers to switch between providers or combine components when building applications.\nLangChain exposes a standard interface for key components, making it easy to switch between providers.\n\n* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/integrations/chat/) for an up-to-date list of supported models.\n* Use either LangChain\'s [messages](/docs/concepts/messages) format or OpenAI format.\n* Standard [tool calling API](/docs/concepts/tool_calling): standard interface for binding tools to models, accessing tool call requests made by models, and sending tool results back to the model.\n* Standard API for [structuring outputs](/docs/concepts/structured_outputs/#structured-output-method) via the `with_structured_output` method.\n* Provides support for [async programming](/docs/concepts/async), [efficient batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), [a rich streaming API](/docs/concepts/streaming).\n\n## Key features\n\nThis highlights functionality that is core to using LangChain.\n\n- [How to: return structured data from a model](/docs/how_to/structured_output/)\n- [How to: use a model to call tools](/docs/how_to/tool_calling)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: debug your LLM apps](/docs/how_to/debugging/)\n\n## Components\n\nThese are the core building blocks you can use when building applications.\n\n### Chat models\n\n[Chat Models](/docs/concepts/chat_models) are newer forms of language models that take messages in and output a message.\nSee [supported integrations](/docs/integrations/chat/) for details on getting started with chat models from a specific provider.\n\nPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.\n\n:::note\nModels that do **not** include the prefix "Chat" in their name or include "LLM" as a suffix in their name typically refer to older models that do not follow the chat model interface and instead use an interface that takes a string as input and returns a string as output.\n:::\n\n\n## Interface\n\nLangChain chat models implement the [BaseChatModel](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) interface. Because `BaseChatModel` also implements the [Runnable Interface](/docs/concepts/runnables), chat models support a [standard streaming interface](/docs/concepts/streaming), [async programming](/docs/concepts/async), optimized [batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), and more. Please see the [Runnable Interface](/docs/concepts/runnables) for more details. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2d36f13a7b147691e55e23c13d3711a76727a99dd4859c60facc3978c8fe9816¢tsËAÚöé„ÒB¨focus_msÍE§payload‚¤role©assistant§contentÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.ªfocus_kind¬exec_latency¨query_id¤Q099‰¢idÙ@4b279b301079f5227e0b3ca0208e8fce2495c63f50bf690b0365002baaa5ddda¢tsËAÚöé„äç¨trace_idÙ$f218d9a1-587d-4329-9236-231e06dbd516­parent_run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fb¦run_idÙ$f218d9a1-587d-4329-9236-231e06dbd516ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.¨query_id¤Q099ªfocus_kind¶chain_execution_result‰¢idÙ@5541293e1e3ec1b8b599636d38eec9b508ceed8878bacfcefa97275cb6e1f07d¢tsËAÚöé„ïÈ¨trace_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fb­parent_run_idÀ¦run_idÙ$287f09c7-e67e-49d7-882f-b70cf9fa77fbªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.¨query_id¤Q099ªfocus_kind¶chain_execution_result‹¢idÙ@514b2b0befe51a5bc22f09bbc45113afb10db56940d599f7d0564db8d9578b40¢tsËAÚöé„ø@¨trace_id¤Q100­parent_run_idÀ¦run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?¨query_id¤Q100§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q100ªfocus_kind¯chain_execution‹¢idÙ@7f750ffc23a6f4f30ef8bb5ea449364854a38378775c64ae4495aee8f2b731de¢tsËAÚöé…ø¨trace_id¤Q100­parent_run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7¦run_idÙ$c2c286ab-4fcf-46a7-a26a-8bf837f2cc7eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context¦answer ¨query_id¤Q100¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q100®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:004b1ca1-751b-4378-9228-80bcfe9befb8ªfocus_kind¯chain_execution‰¢idÙ@eaeba9acef292bf97d8a76510ba54ee43e5a376b29e0bbc308ccc77229312968¢tsËAÚöé—•¸¨trace_idÙ$c2c286ab-4fcf-46a7-a26a-8bf837f2cc7e­parent_run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7¦run_idÙ$c2c286ab-4fcf-46a7-a26a-8bf837f2cc7eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¨query_id¤Q100ªfocus_kind¶chain_execution_result‹¢idÙ@69b28a84fce9e5a474ea77f4fd6302a005966e4c548829a6d4cb4b096d78e67f¢tsËAÚöé—£¶¨trace_id¤Q100­parent_run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7¦run_idÙ$cf68fcd6-8120-4603-893b-5fc7938e6d3aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answer ¨query_id¤Q100¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q100®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:36e5651b-82bc-2f16-190e-ca1d3d7b1638ªfocus_kind¯chain_execution‹¢idÙ@06fc81f72558958015f8f91c40abe7203cd982c6ae79bb2e014736f0c747098c¢tsËAÚöé—«‚¨trace_id¤Q100­parent_run_idÙ$cf68fcd6-8120-4603-893b-5fc7938e6d3a¦run_idÙ$bdd35283-8e20-469c-aaf7-c34638ad6a74ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§contextÚK### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs/how_to/example_selectors)
- [How to: select examples by length](/docs/how_to/example_selectors_length_based)
- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)
- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)
- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)
- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).

This gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.
Sometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.

**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.

## Related resources

* [Example selector how-to guides](/docs/how_to/#example-selectors)

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |

:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).
* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).
* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).

:::

### Semantic meaning based

Unlike the previous methods, semantic-based splitting actually considers the *content* of the text. 
While other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.
There are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.
As an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q100®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:36e5651b-82bc-2f16-190e-ca1d3d7b1638­checkpoint_nsÙ-generate:36e5651b-82bc-2f16-190e-ca1d3d7b1638¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@f13edd0124b09cc93037c7970a3d20c7d2e369a8d502875486220e70c88fbd78¢tsËAÚöé—´x¨trace_idÙ$bdd35283-8e20-469c-aaf7-c34638ad6a74­parent_run_idÙ$cf68fcd6-8120-4603-893b-5fc7938e6d3a¦run_idÙ$bdd35283-8e20-469c-aaf7-c34638ad6a74ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ6messages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two sources explain creating example selectors based on semantic similarity? \nContext: ### Example selectors\n\n[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.\n\n- [How to: use example selectors](/docs/how_to/example_selectors)\n- [How to: select examples by length](/docs/how_to/example_selectors_length_based)\n- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)\n- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)\n- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)\n- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n# Example selectors\n\n:::note Prerequisites\n\n- [Chat models](/docs/concepts/chat_models/)\n- [Few-shot prompting](/docs/concepts/few_shot_prompting/)\n:::\n\n## Overview\n\nOne common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).\n\nThis gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.\nSometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.\n\n**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.\n\n## Related resources\n\n* [Example selector how-to guides](/docs/how_to/#example-selectors)\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |\n\n:::info[Further reading]\n\n* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).\n* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).\n* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).\n* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).\n\n:::\n\n### Semantic meaning based\n\nUnlike the previous methods, semantic-based splitting actually considers the *content* of the text. \nWhile other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.\nThere are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.\nAs an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences: \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@59f43d9a09c35cb2b3174deed2ea7ed5341fd0fd65d206206cfd09b90cf62a56¢tsËAÚöê­‚¨focus_msÍ§payload‚¤role©assistant§contentÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)ªfocus_kind¬exec_latency¨query_id¤Q100‰¢idÙ@ac6b0d829ba854fb15d378a38fb5f309bd8781af29bab2201ca1ab94445c34a4¢tsËAÚöêÁX¨trace_idÙ$cf68fcd6-8120-4603-893b-5fc7938e6d3a­parent_run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7¦run_idÙ$cf68fcd6-8120-4603-893b-5fc7938e6d3aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)¨query_id¤Q100ªfocus_kind¶chain_execution_result‰¢idÙ@0362ceb8e5da5974f73bcf8e716b3d6fbd901a74d002c9c542e5478c588f08e5¢tsËAÚöêÇç¨trace_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7­parent_run_idÀ¦run_idÙ$b7c18725-3ed4-4fa9-a299-6ab8bc4ea9b7ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answerÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)¨query_id¤Q100ªfocus_kind¶chain_execution_result‹¢idÙ@f020027537d99222f99491e87582f826880bb4113478fab1e22d71939e7fa88a¢tsËAÚöêÌ´¨trace_id¤Q101­parent_run_idÀ¦run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?¨query_id¤Q101§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q101ªfocus_kind¯chain_execution‹¢idÙ@207206a88c784fedf1d76bf403a148add47fa0868e1401bf48adc0622726ab7b¢tsËAÚöêÔ€¨trace_id¤Q101­parent_run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228f¦run_idÙ$fd961407-0cee-46e3-81aa-0c7871ee4b19ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context¦answer ¨query_id¤Q101¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q101®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:fcb1cb3f-a15e-dcc5-b141-7ef37846c541ªfocus_kind¯chain_execution‰¢idÙ@4c2b7688c393705996bc86ecf0ebf966fb3933fe020aaa1ef78e26e7aa7271bf¢tsËAÚöê &J¨trace_idÙ$fd961407-0cee-46e3-81aa-0c7871ee4b19­parent_run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228f¦run_idÙ$fd961407-0cee-46e3-81aa-0c7871ee4b19ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q101ªfocus_kind¶chain_execution_result‹¢idÙ@99eadc404876a4383a317e09aecbbe91207561ea4734925ee4324408be9010e7¢tsËAÚöê .g¨trace_id¤Q101­parent_run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228f¦run_idÙ$046b47c5-e2a9-44fb-a819-97748f8f5b61ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q101¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q101®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:19b3be26-526e-65c8-dbd2-9943a994256fªfocus_kind¯chain_execution‹¢idÙ@8e57a97cf7ad12af7575fb76d59332b6c73ab0787dcb9ca35a7eec25dced5955¢tsËAÚöê 3D¨trace_id¤Q101­parent_run_idÙ$046b47c5-e2a9-44fb-a819-97748f8f5b61¦run_idÙ$e720d8f0-c81b-4d54-aa23-ee1c56ce13feªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§contextÚöIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)  in Python 3.9 and 3.10 which did
not accept a `context` argument.

Propagating the `RunnableConfig` manually is done like so:

```python
async def foo(input, config): # <-- Note the config argument
    return await bar_runnable.ainvoke(input, config=config)
    
foo_runnable = RunnableLambda(foo)
```

:::caution
When using Python 3.10 or lower and writing async code, `RunnableConfig` cannot be propagated
automatically, and you will need to do it manually! This is a common pitfall when
attempting to stream data using `astream_events` and `astream_log` as these methods
rely on proper propagation of [callbacks](/docs/concepts/callbacks) defined inside of `RunnableConfig`.
:::

If you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableGenerator`, or `Tool` that invokes other runnables
and is running `async` in python&lt;=3.10, will have to propagate callbacks to child
objects manually. This is because LangChain cannot automatically propagate
callbacks to child objects in this case.

This is a common reason why you may fail to see events being emitted from custom
runnables or tools.
:::

For specifics on how to use callbacks, see the [relevant how-to guides here](/docs/how_to/#callbacks).

## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html#RunnableConfig)). This argument is a dictionary that contains configuration for the Runnable that will be used
at run time during the execution of the runnable.

A `RunnableConfig` can have any of the following properties defined:

1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnables)  (e.g., `RunnableLambda`) or using the `@tool` decorator:

    ```python
    def foo(input):
        # Note that .invoke() is used directly here
        return bar_runnable.invoke(input)
    foo_runnable = RunnableLambda(foo)
    ```

LangChain will try to propagate `RunnableConfig` automatically for both of the patterns. 

For handling the second pattern, LangChain relies on Python's [contextvars](https://docs.python.org/3/library/contextvars.html).

In Python 3.11 and above, this works out of the box, and you do not need to do anything special to propagate the `RunnableConfig` to the sub-calls.

In Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it.

Passing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'key': 'value'}
      
   }
)
```

### Propagation of RunnableConfig

Many `Runnables` are composed of other Runnables, and it is important that the `RunnableConfig` is propagated to all sub-calls made by the Runnable. This allows providing run time configuration values to the parent Runnable that are inherited by all sub-calls.

If this were not the case, it would be impossible to set and propagate [callbacks](/docs/concepts/callbacks) or other configuration values like `tags` and `metadata` which
are expected to be inherited by all sub-calls.

There are two main patterns by which new `Runnables` are created:

1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q101®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:19b3be26-526e-65c8-dbd2-9943a994256f­checkpoint_nsÙ-generate:19b3be26-526e-65c8-dbd2-9943a994256f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3ab88dea87f562a33159509f8615528b1364fa314b97b2828cc059a9242ef5c6¢tsËAÚöê 9–¨trace_idÙ$e720d8f0-c81b-4d54-aa23-ee1c56ce13fe­parent_run_idÙ$046b47c5-e2a9-44fb-a819-97748f8f5b61¦run_idÙ$e720d8f0-c81b-4d54-aa23-ee1c56ce13feªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the impact of not propagating `RunnableConfig` in Python 3.10 async code? \nContext: In Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. \n\nThis is due to a limitation in [asyncio's tasks](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)  in Python 3.9 and 3.10 which did\nnot accept a `context` argument.\n\nPropagating the `RunnableConfig` manually is done like so:\n\n```python\nasync def foo(input, config): # <-- Note the config argument\n    return await bar_runnable.ainvoke(input, config=config)\n    \nfoo_runnable = RunnableLambda(foo)\n```\n\n:::caution\nWhen using Python 3.10 or lower and writing async code, `RunnableConfig` cannot be propagated\nautomatically, and you will need to do it manually! This is a common pitfall when\nattempting to stream data using `astream_events` and `astream_log` as these methods\nrely on proper propagation of [callbacks](/docs/concepts/callbacks) defined inside of `RunnableConfig`.\n:::\n\nIf you're creating a custom chain or runnable, you need to remember to propagate request time\ncallbacks to any child objects.\n\n:::important Async in Python&lt;=3.10\n\nAny `RunnableLambda`, a `RunnableGenerator`, or `Tool` that invokes other runnables\nand is running `async` in python&lt;=3.10, will have to propagate callbacks to child\nobjects manually. This is because LangChain cannot automatically propagate\ncallbacks to child objects in this case.\n\nThis is a common reason why you may fail to see events being emitted from custom\nrunnables or tools.\n:::\n\nFor specifics on how to use callbacks, see the [relevant how-to guides here](/docs/how_to/#callbacks).\n\n## RunnableConfig\n\nAny of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called\n`RunnableConfig` ([API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html#RunnableConfig)). This argument is a dictionary that contains configuration for the Runnable that will be used\nat run time during the execution of the runnable.\n\nA `RunnableConfig` can have any of the following properties defined:\n\n1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):\n\n    ```python\n    chain = prompt | chat_model | output_parser\n    ```\n\n2. Using a [custom Runnable](#custom-runnables)  (e.g., `RunnableLambda`) or using the `@tool` decorator:\n\n    ```python\n    def foo(input):\n        # Note that .invoke() is used directly here\n        return bar_runnable.invoke(input)\n    foo_runnable = RunnableLambda(foo)\n    ```\n\nLangChain will try to propagate `RunnableConfig` automatically for both of the patterns. \n\nFor handling the second pattern, LangChain relies on Python's [contextvars](https://docs.python.org/3/library/contextvars.html).\n\nIn Python 3.11 and above, this works out of the box, and you do not need to do anything special to propagate the `RunnableConfig` to the sub-calls.\n\nIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it.\n\nPassing `config` to the `invoke` method is done like so:\n\n```python\nsome_runnable.invoke(\n   some_input, \n   config={\n      'run_name': 'my_run', \n      'tags': ['tag1', 'tag2'], \n      'metadata': {'key': 'value'}\n      \n   }\n)\n```\n\n### Propagation of RunnableConfig\n\nMany `Runnables` are composed of other Runnables, and it is important that the `RunnableConfig` is propagated to all sub-calls made by the Runnable. This allows providing run time configuration values to the parent Runnable that are inherited by all sub-calls.\n\nIf this were not the case, it would be impossible to set and propagate [callbacks](/docs/concepts/callbacks) or other configuration values like `tags` and `metadata` which\nare expected to be inherited by all sub-calls.\n\nThere are two main patterns by which new `Runnables` are created:\n\n1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):\n\n    ```python\n    chain = prompt | chat_model | output_parser\n    ``` \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@3a9cdb7537edc7c6b0a0b9cc9eec94973efc4fce9a4304f4d0162199fec80417¢tsËAÚöê k¨focus_msÍÔ§payload‚¤role©assistant§contentÚºNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, events may not be emitted from custom runnables or tools, leading to unexpected behavior.ªfocus_kind¬exec_latency¨query_id¤Q101‰¢idÙ@55b338fb713a351a00a4ac24c90049df158a7bee42f9e12daa54fce87834259a¢tsËAÚöê u¨trace_idÙ$046b47c5-e2a9-44fb-a819-97748f8f5b61­parent_run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228f¦run_idÙ$046b47c5-e2a9-44fb-a819-97748f8f5b61ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚºNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, events may not be emitted from custom runnables or tools, leading to unexpected behavior.¨query_id¤Q101ªfocus_kind¶chain_execution_result‰¢idÙ@855df57627b46c2d6c2a37dda0f86b638de9b776a80244444b77e6a52819e59c¢tsËAÚöê œö¨trace_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228f­parent_run_idÀ¦run_idÙ$5df8e243-abd9-4b94-8cd5-4347833b228fªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚºNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, events may not be emitted from custom runnables or tools, leading to unexpected behavior.¨query_id¤Q101ªfocus_kind¶chain_execution_result‹¢idÙ@116b645183d17e56ffa24b0dbcead3d6c3b0e5ecd499f1b265d2318421b8c3d4¢tsËAÚöê ªL¨trace_id¤Q102­parent_run_idÀ¦run_idÙ$e542639b-1257-4817-94c4-42577f24a696ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.¨query_id¤Q102§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q102ªfocus_kind¯chain_execution‹¢idÙ@5731a292d52ce725781f3c691df4275b84849814d70506cfe86988de92f7bdbe¢tsËAÚöê µò¨trace_id¤Q102­parent_run_idÙ$e542639b-1257-4817-94c4-42577f24a696¦run_idÙ$78d7b551-b06b-4b5a-a44b-dfee8aae6425ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context¦answer ¨query_id¤Q102¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q102®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3bc17674-723a-70a5-bc7d-3f10322b6b4aªfocus_kind¯chain_execution‰¢idÙ@c2ec5bb9fee565b88814160d6ba3783772e45d74f2496900eb7064e4102cf8ba¢tsËAÚöê°™R¨trace_idÙ$78d7b551-b06b-4b5a-a44b-dfee8aae6425­parent_run_idÙ$e542639b-1257-4817-94c4-42577f24a696¦run_idÙ$78d7b551-b06b-4b5a-a44b-dfee8aae6425ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¨query_id¤Q102ªfocus_kind¶chain_execution_result‹¢idÙ@f1524a4dfd000f329cefad16b85a5baf1dc139cef7c6be9f217090f5ba396b75¢tsËAÚöê°£0¨trace_id¤Q102­parent_run_idÙ$e542639b-1257-4817-94c4-42577f24a696¦run_idÙ$3e59fb0e-677c-4fa2-9c59-0be30a6f5321ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¦answer ¨query_id¤Q102¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q102®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c87afa6c-43ac-77ca-dc0a-dcbedac7c58aªfocus_kind¯chain_execution‹¢idÙ@723d0fcf063deb5d96578a7b4dd17b22d6c07406337415f3714107dff28d4291¢tsËAÚöê°¨¨trace_id¤Q102­parent_run_idÙ$3e59fb0e-677c-4fa2-9c59-0be30a6f5321¦run_idÙ$19ad17c3-9794-4707-9c05-6ebce405fe18ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§contextÚ¶You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

The key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schema for the tool's arguments.

The key methods to execute the function associated with the **tool**:

- **invoke**: Invokes the tool with the given arguments.
- **ainvoke**: Invokes the tool with the given arguments, asynchronously. Used for [async programming with Langchain](/docs/concepts/async).

## Create tools using the `@tool` decorator

@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value": "some_value"}})
```

The `config` will not be part of the tool's schema and will be injected at runtime with appropriate values.

:::note
You may need to access the `config` object to manually propagate it to subclass. This happens if you're working with python 3.9 / 3.10 in an [async](/docs/concepts/async) environment and need to manually propagate the `config` object to sub-calls.

Please read [Propagation RunnableConfig](/docs/concepts/runnables/#propagation-of-runnableconfig) for more details to learn how to propagate the `RunnableConfig` down the call chain manually (or upgrade to Python 3.11 where this is no longer an issue).
:::

### InjectedState

## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).

Please see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.

## Tool artifacts¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q102®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c87afa6c-43ac-77ca-dc0a-dcbedac7c58a­checkpoint_nsÙ-generate:c87afa6c-43ac-77ca-dc0a-dcbedac7c58a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@1c7fed1711de5cf699ac9669ea6184b86d35127bb24ebe88e28b24e3a4116ff4¢tsËAÚöê°¯W¨trace_idÙ$19ad17c3-9794-4707-9c05-6ebce405fe18­parent_run_idÙ$3e59fb0e-677c-4fa2-9c59-0be30a6f5321¦run_idÙ$19ad17c3-9794-4707-9c05-6ebce405fe18ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¾messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe the `@tool` option to hide a parameter while still injecting it at runtime. \nContext: You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\nThe key attributes that correspond to the tool\'s **schema**:\n\n- **name**: The name of the tool.\n- **description**: A description of what the tool does.\n- **args**: Property that returns the JSON schema for the tool\'s arguments.\n\nThe key methods to execute the function associated with the **tool**:\n\n- **invoke**: Invokes the tool with the given arguments.\n- **ainvoke**: Invokes the tool with the given arguments, asynchronously. Used for [async programming with Langchain](/docs/concepts/async).\n\n## Create tools using the `@tool` decorator\n\n@tool\nasync def some_func(..., config: RunnableConfig) -> ...:\n    """Tool that does something."""\n    # do something with config\n    ...\n\nawait some_func.ainvoke(..., config={"configurable": {"value": "some_value"}})\n```\n\nThe `config` will not be part of the tool\'s schema and will be injected at runtime with appropriate values.\n\n:::note\nYou may need to access the `config` object to manually propagate it to subclass. This happens if you\'re working with python 3.9 / 3.10 in an [async](/docs/concepts/async) environment and need to manually propagate the `config` object to sub-calls.\n\nPlease read [Propagation RunnableConfig](/docs/concepts/runnables/#propagation-of-runnableconfig) for more details to learn how to propagate the `RunnableConfig` down the call chain manually (or upgrade to Python 3.11 where this is no longer an issue).\n:::\n\n### InjectedState\n\n## Configuring the schema\n\nThe `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description\nor parse the function\'s doc-string to infer the schema).\n\nPlease see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.\n\n## Tool artifacts \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@f9890ef107e4b5cd51537b8c087481f54e949248bb3393ad323dec324d9ffe40¢tsËAÚöë)º¨focus_msÍX§payload‚¤role©assistant§contentÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.ªfocus_kind¬exec_latency¨query_id¤Q102‰¢idÙ@e3ecbfc63572c2732469ec598352c52b238d1cda4b7fc8f80047996f83fcaccf¢tsËAÚöë)#ó¨trace_idÙ$3e59fb0e-677c-4fa2-9c59-0be30a6f5321­parent_run_idÙ$e542639b-1257-4817-94c4-42577f24a696¦run_idÙ$3e59fb0e-677c-4fa2-9c59-0be30a6f5321ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.¨query_id¤Q102ªfocus_kind¶chain_execution_result‰¢idÙ@78717fee32a177c7ba59e64b14e08b77b043a9ee17bdbb8b8f72dd87398ff708¢tsËAÚöë).¨trace_idÙ$e542639b-1257-4817-94c4-42577f24a696­parent_run_idÀ¦run_idÙ$e542639b-1257-4817-94c4-42577f24a696ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¦answerÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.¨query_id¤Q102ªfocus_kind¶chain_execution_result‹¢idÙ@ca7843e0b534d20ea0b53b2ebb55ff8d5590f6dda065f2c8899ba54483b2b760¢tsËAÚöë)7d¨trace_id¤Q103­parent_run_idÀ¦run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?¨query_id¤Q103§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q103ªfocus_kind¯chain_execution‹¢idÙ@34ffbb807e4216d597680cb32715d5bf7847ee9b7433be6b1ab4588da866a78f¢tsËAÚöë)@N¨trace_id¤Q103­parent_run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4¦run_idÙ$b1343916-94d8-456d-8181-d8ef2cb13aa4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context¦answer ¨query_id¤Q103¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q103®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:1f9be470-a23f-bbe8-5879-68219006e484ªfocus_kind¯chain_execution‰¢idÙ@39952dcddd58eb697cda97940e1334c9858d3d4afb66f6c9c95c8f93bff054b6¢tsËAÚöë;Òé¨trace_idÙ$b1343916-94d8-456d-8181-d8ef2cb13aa4­parent_run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4¦run_idÙ$b1343916-94d8-456d-8181-d8ef2cb13aa4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q103ªfocus_kind¶chain_execution_result‹¢idÙ@92922ad28de8927749f0e3796f8cc1bfb094734da42cf589bb7e3624385e37cc¢tsËAÚöë;ïá¨trace_id¤Q103­parent_run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4¦run_idÙ$c044fa38-2152-482e-af3b-ac87db460b36ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q103¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q103®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:fe0bc2af-a172-5753-8661-3badc9317a9eªfocus_kind¯chain_execution‹¢idÙ@026dcd3ed9c874d8c81ffac803b5a06d8584271ba3c2b9c5f5b8146289567f66¢tsËAÚöë;öË¨trace_id¤Q103­parent_run_idÙ$c044fa38-2152-482e-af3b-ac87db460b36¦run_idÙ$9d1b651d-2f2d-43a5-8c81-0ff1fe77cc92ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§contextÚp```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we combine search results from many retrievers? 
This motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).

### Source document retention 

Many retrievers utilize some kind of index to make documents easily searchable.
The process of indexing can include a transformation step (e.g., vectorstores often use document splitting). 
Whatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.

![Retrieval with full docs](/img/retriever_full_docs.png)

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Document` objects given a search query, it is possible to combine multiple retrievers using ensembling.
This is particularly useful when you have multiple retrievers that are good at finding different types of relevant documents.
It is easy to create an [ensemble retriever](/docs/how_to/ensemble_retriever/) that combines multiple retrievers with linear weighted scores:

```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

### Vector store 

[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. 
A vectorstore can be used as a retriever by calling the `as_retriever()` method.

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small chunk size for indexing documents in a vectorstore. 
If you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. 

LangChain has two different retrievers that can be used to address this challenge. 
The [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. 
The [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q103®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:fe0bc2af-a172-5753-8661-3badc9317a9e­checkpoint_nsÙ-generate:fe0bc2af-a172-5753-8661-3badc9317a9e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c8251fdf96c8f79c0f2138b2ca2695328632a65771ae23cb11d51bd1e45680b4¢tsËAÚöë;ı"¨trace_idÙ$9d1b651d-2f2d-43a5-8c81-0ff1fe77cc92­parent_run_idÙ$c044fa38-2152-482e-af3b-ac87db460b36¦run_idÙ$9d1b651d-2f2d-43a5-8c81-0ff1fe77cc92ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ`messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which notebook illustrates using an ensemble retriever strategy? \nContext: ```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\nWhen ensembling, how do we combine search results from many retrievers? \nThis motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).\n\n### Source document retention \n\nMany retrievers utilize some kind of index to make documents easily searchable.\nThe process of indexing can include a transformation step (e.g., vectorstores often use document splitting). \nWhatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.\n\n![Retrieval with full docs](/img/retriever_full_docs.png)\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble \n\nBecause the retriever interface is so simple, returning a list of `Document` objects given a search query, it is possible to combine multiple retrievers using ensembling.\nThis is particularly useful when you have multiple retrievers that are good at finding different types of relevant documents.\nIt is easy to create an [ensemble retriever](/docs/how_to/ensemble_retriever/) that combines multiple retrievers with linear weighted scores:\n\n```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n### Vector store \n\n[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. \nA vectorstore can be used as a retriever by calling the `as_retriever()` method.\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\n![Retrieval with full docs](/img/retriever_full_docs.png)\n\nThis is particularly useful in AI applications, because it ensures no loss in document context for the model.\nFor example, you may use small chunk size for indexing documents in a vectorstore. \nIf you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. \n\nLangChain has two different retrievers that can be used to address this challenge. \nThe [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. \nThe [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@99aeaa9d2362d9e0c6f8b641fbe3f54d38c438c2a35935dacfa3f30b1e54866c¢tsËAÚöë³¼º¨focus_msÍN§payload‚¤role©assistant§contentÚ¼The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers. For further details, you can refer to the documentation on how to create an ensemble retriever.ªfocus_kind¬exec_latency¨query_id¤Q103‰¢idÙ@807499ea85ef0eee4e1cfdbd6c621cc943d5dcb816817d23d6ca0dd4cc78c450¢tsËAÚöë³Ñ¨trace_idÙ$c044fa38-2152-482e-af3b-ac87db460b36­parent_run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4¦run_idÙ$c044fa38-2152-482e-af3b-ac87db460b36ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ¼The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers. For further details, you can refer to the documentation on how to create an ensemble retriever.¨query_id¤Q103ªfocus_kind¶chain_execution_result‰¢idÙ@530af889b9fd68260818fa98ed88a56e1ece075bfdaa1dc1255b1d9f763200a8¢tsËAÚöë³Ö¿¨trace_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4­parent_run_idÀ¦run_idÙ$7ed64fad-396b-4b1b-ba8c-47bec0f014d4ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÚ¼The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers. For further details, you can refer to the documentation on how to create an ensemble retriever.¨query_id¤Q103ªfocus_kind¶chain_execution_result‹¢idÙ@49c8c7e68982e44416a04e02c8f32f512b3831292f9f2737c8bb4b2040423965¢tsËAÚöë³Úğ¨trace_id¤Q104­parent_run_idÀ¦run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).¨query_id¤Q104§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q104ªfocus_kind¯chain_execution‹¢idÙ@1bda4facfc97a072a77521f1b3764135d57810eb1c568e45ea3ff9937b75c1f4¢tsËAÚöë³ã†¨trace_id¤Q104­parent_run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0¦run_idÙ$cab7b5a2-d76b-4c2f-ac43-360754df62dcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context¦answer ¨query_id¤Q104¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q104®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:106de711-290e-1966-21ec-908e5c6811a4ªfocus_kind¯chain_execution‰¢idÙ@5249d0d1455da43679abee6210c4a1e6c6b36774c9d9d90c1400a808aa37e7d8¢tsËAÚöëÀ3”¨trace_idÙ$cab7b5a2-d76b-4c2f-ac43-360754df62dc­parent_run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0¦run_idÙ$cab7b5a2-d76b-4c2f-ac43-360754df62dcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q104ªfocus_kind¶chain_execution_result‹¢idÙ@70fcf065ce955dbb80a7300ad6806ef818b0853dbedd84f54f1a7e80679476af¢tsËAÚöëÀ;¨trace_id¤Q104­parent_run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0¦run_idÙ$1361fafc-7e33-4523-a55d-b2c7fbd66178ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q104¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q104®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e9eaa0df-f329-adde-863c-42158195a7ddªfocus_kind¯chain_execution‹¢idÙ@8b6f6d86e8d55e7b71278e1330085ea0cba1ef0b9e61ae46795bee8077d72f96¢tsËAÚöëÀD¦¨trace_id¤Q104­parent_run_idÙ$1361fafc-7e33-4523-a55d-b2c7fbd66178¦run_idÙ$0f60fbd7-67e0-4a53-8991-6144d3b5a3d4ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§contextÚ¾Other benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is happening at every step.
With LCEL, **all** steps are automatically logged to [LangSmith](https://docs.smith.langchain.com/) for maximum observability and debuggability.
- **Standard API**: Because all chains are built using the Runnable interface, they can be used in the same way as any other Runnable.
- [**Deployable with LangServe**](/docs/concepts/architecture#langserve): Chains built with LCEL can be deployed using for production use.

## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.

This means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(time elapsed until the first chunk of output from a [chat model](/docs/concepts/chat_models) or [llm](/docs/concepts/text_llms) comes out).

## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

While we have seen users run chains with hundreds of steps in production, we generally recommend using LCEL for simpler orchestration tasks. When the application requires complex state management, branching, cycles or multiple agents, we recommend that users take advantage of [LangGraph](/docs/concepts/architecture#langgraph).

In LangGraph, users define graphs that specify the application's flow. This allows users to keep using LCEL within individual nodes when LCEL is needed, while making it easy to define complex orchestration logic that is more readable and maintainable.

Here are some guidelines:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q104®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e9eaa0df-f329-adde-863c-42158195a7dd­checkpoint_nsÙ-generate:e9eaa0df-f329-adde-863c-42158195a7dd¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@80feba4d9b3578362060e94ac1f440549b8ad7c41ceb05d1ff12338116cdbb9a¢tsËAÚöëÀMn¨trace_idÙ$0f60fbd7-67e0-4a53-8991-6144d3b5a3d4­parent_run_idÙ$1361fafc-7e33-4523-a55d-b2c7fbd66178¦run_idÙ$0f60fbd7-67e0-4a53-8991-6144d3b5a3d4ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Give two benefits of the LangChain Expression Language (LCEL). \nContext: Other benefits include:\n\n- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)\nAs your chains get more and more complex, it becomes increasingly important to understand what exactly is happening at every step.\nWith LCEL, **all** steps are automatically logged to [LangSmith](https://docs.smith.langchain.com/) for maximum observability and debuggability.\n- **Standard API**: Because all chains are built using the Runnable interface, they can be used in the same way as any other Runnable.\n- [**Deployable with LangServe**](/docs/concepts/architecture#langserve): Chains built with LCEL can be deployed using for production use.\n\n## Should I use LCEL?\n\nLCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.\n\n# LangChain Expression Language (LCEL)\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n:::\n\nThe **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.\n\nThis means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(time elapsed until the first chunk of output from a [chat model](/docs/concepts/chat_models) or [llm](/docs/concepts/text_llms) comes out).\n\n## Should I use LCEL?\n\nLCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.\n\nWhile we have seen users run chains with hundreds of steps in production, we generally recommend using LCEL for simpler orchestration tasks. When the application requires complex state management, branching, cycles or multiple agents, we recommend that users take advantage of [LangGraph](/docs/concepts/architecture#langgraph).\n\nIn LangGraph, users define graphs that specify the application\'s flow. This allows users to keep using LCEL within individual nodes when LCEL is needed, while making it easy to define complex orchestration logic that is more readable and maintainable.\n\nHere are some guidelines: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@7c095ee52ed8cbd84a460ae498b53fc3975bdc5184ccb5bd78737a4bb0d53878¢tsËAÚöì¯Å¨focus_msÍ²§payload‚¤role©assistant§contentÚ„Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL provides a standard API through the Runnable interface, making it easier to use chains consistently.ªfocus_kind¬exec_latency¨query_id¤Q104‰¢idÙ@15e53d0089bf557c5d9614955325238aa944e3e7f03b7518a6c34e4493881318¢tsËAÚöìÃµ¨trace_idÙ$1361fafc-7e33-4523-a55d-b2c7fbd66178­parent_run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0¦run_idÙ$1361fafc-7e33-4523-a55d-b2c7fbd66178ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ„Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL provides a standard API through the Runnable interface, making it easier to use chains consistently.¨query_id¤Q104ªfocus_kind¶chain_execution_result‰¢idÙ@9e119dc0142fc0bba85f5e2c1b75c8b91bd17e242aade1da9c393fa09adf559e¢tsËAÚöìÊŞ¨trace_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0­parent_run_idÀ¦run_idÙ$a50a3c70-095f-4bac-ba1f-c9d9e5f5b8e0ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚ„Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL provides a standard API through the Runnable interface, making it easier to use chains consistently.¨query_id¤Q104ªfocus_kind¶chain_execution_result‹¢idÙ@0acd8cdb30d33b4da89395e28c6da85115c374f68819fcdaac267f9f491138c2¢tsËAÚöìĞ!¨trace_id¤Q105­parent_run_idÀ¦run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1efªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?¨query_id¤Q105§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q105ªfocus_kind¯chain_execution‹¢idÙ@d3d9e3406803ed8942d540dc7c21628fc50954f7e80e0e80f0eea9c43eb49783¢tsËAÚöìØ¨trace_id¤Q105­parent_run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1ef¦run_idÙ$11824341-802d-450a-9a2a-901980047dfaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context¦answer ¨query_id¤Q105¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q105®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:aeff6860-390a-27bf-6eb5-ccbdb368a74aªfocus_kind¯chain_execution‰¢idÙ@1798079a4d4b262c359a4c5193d804de6c822651fa96ff6bceeffcc7551754b8¢tsËAÚöì.ßÂ¨trace_idÙ$11824341-802d-450a-9a2a-901980047dfa­parent_run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1ef¦run_idÙ$11824341-802d-450a-9a2a-901980047dfaªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q105ªfocus_kind¶chain_execution_result‹¢idÙ@020fa515ed69e6e6ed5244343bdcf2f3df41eb2a20a69253214e59f729c03dc6¢tsËAÚöì.ì¯¨trace_id¤Q105­parent_run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1ef¦run_idÙ$b9dd6539-7693-4c87-9cd1-3ec44dd0a858ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q105¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q105®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d67b852c-733d-23e4-d30b-8764b36fc835ªfocus_kind¯chain_execution‹¢idÙ@c83c290a7a821b0d9c0b59499e1dc90e1fdfb68a6f115009ebd8db6ac41b4e56¢tsËAÚöì.ô9¨trace_id¤Q105­parent_run_idÙ$b9dd6539-7693-4c87-9cd1-3ec44dd0a858¦run_idÙ$4e660ace-b17f-4a07-8fdb-4922ef612872ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§contextÚ©1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                                                                                                                                          |
| `rate_limiter` | An optional [BaseRateLimiter](https://python.langchain.com/api_reference/core/rate_limiters/langchain_core.rate_limiters.BaseRateLimiter.html#langchain_core.rate_limiters.BaseRateLimiter) to space out requests to avoid exceeding rate limits.  See [rate-limiting](#rate-limiting) below for more details. |

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.

Modern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.

The newest generation of chat models offer additional capabilities:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q105®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d67b852c-733d-23e4-d30b-8764b36fc835­checkpoint_nsÙ-generate:d67b852c-733d-23e4-d30b-8764b36fc835¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@f8dfaa419aecf913ebd90907464b6c8db5a15ad6c9afba033a984133ee0fddef¢tsËAÚöì.ı“¨trace_idÙ$4e660ace-b17f-4a07-8fdb-4922ef612872­parent_run_idÙ$b9dd6539-7693-4c87-9cd1-3ec44dd0a858¦run_idÙ$4e660ace-b17f-4a07-8fdb-4922ef612872ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚlmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the main purpose of the `rate_limiter` argument on ChatModels? \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model\'s provider and is necessary for directing your requests.                                                                                                                                                          |\n| `rate_limiter` | An optional [BaseRateLimiter](https://python.langchain.com/api_reference/core/rate_limiters/langchain_core.rate_limiters.BaseRateLimiter.html#langchain_core.rate_limiters.BaseRateLimiter) to space out requests to avoid exceeding rate limits.  See [rate-limiting](#rate-limiting) below for more details. |\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n# Chat models\n\n## Overview\n\nLarge Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.\n\nModern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.\n\nThe newest generation of chat models offer additional capabilities: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@434c1247bc1453edb019fb3bd0134778e5262d7d0df8fa97f9b9dd5b881061ef¢tsËAÚöìÎ0¨focus_msÍ	·§payload‚¤role©assistant§contentÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.ªfocus_kind¬exec_latency¨query_id¤Q105‰¢idÙ@34fb23358a39f5f1f1f475f376cd212a20719be35c3c8a4e0599d37bc225e71f¢tsËAÚöìÎ=Õ¨trace_idÙ$b9dd6539-7693-4c87-9cd1-3ec44dd0a858­parent_run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1ef¦run_idÙ$b9dd6539-7693-4c87-9cd1-3ec44dd0a858ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.¨query_id¤Q105ªfocus_kind¶chain_execution_result‰¢idÙ@37e38cadff8c50b9a92db5bc2a6f1a0fccecd06e7642506339cc959b6dc4ec22¢tsËAÚöìÎT`¨trace_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1ef­parent_run_idÀ¦run_idÙ$ca658869-6fa2-475e-96fd-c8b6da6bd1efªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.¨query_id¤Q105ªfocus_kind¶chain_execution_result‹¢idÙ@654a157fb972344f280591e0992aa6f013ccf3701499fa93144a6a3a86e3e5fd¢tsËAÚöìÎZÉ¨trace_id¤Q106­parent_run_idÀ¦run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?¨query_id¤Q106§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q106ªfocus_kind¯chain_execution‹¢idÙ@2ad7d2e7ca41bec7bd3be9a97d9d4c82c483d29f6075f45aced45092590ad0ad¢tsËAÚöìÎa»¨trace_id¤Q106­parent_run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879¦run_idÙ$7232d4ed-4f3b-4c38-bcef-0658efebdfedªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context¦answer ¨query_id¤Q106¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q106®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:df1ee799-23ec-6970-c0fd-14d5f3f265e1ªfocus_kind¯chain_execution‰¢idÙ@ade2d2a033673c1ff33bdc19796efb0940f4f725fb7659d891578817bebf52bf¢tsËAÚöìâ³)¨trace_idÙ$7232d4ed-4f3b-4c38-bcef-0658efebdfed­parent_run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879¦run_idÙ$7232d4ed-4f3b-4c38-bcef-0658efebdfedªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¨query_id¤Q106ªfocus_kind¶chain_execution_result‹¢idÙ@0700f23d0b580f8952697afb5e83f345a7504fbc83548e050ef0c6538be7b4d4¢tsËAÚöìâ¼¨trace_id¤Q106­parent_run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879¦run_idÙ$e53505fd-f534-4c4e-a2dd-e55e12a4d2e4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¦answer ¨query_id¤Q106¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q106®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9cf52ada-ba6f-9883-5152-d1cd70e931ebªfocus_kind¯chain_execution‹¢idÙ@afb36eb6f880c20063570194ba4ea7014d652312acc4cfc9830fbb15d628e53f¢tsËAÚöìâÁœ¨trace_id¤Q106­parent_run_idÙ$e53505fd-f534-4c4e-a2dd-e55e12a4d2e4¦run_idÙ$d9021167-bad8-4185-ac7b-42ad13243507ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ<How many tokens is 100 English words approximately equal to?§contextÚš## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and how they correspond to text.

According to the OpenAI post, the approximate token counts for English text are as follows:

* 1 token ~= 4 chars in English
* 1 token ~= Â¾ words
* 100 tokens ~= 75 words

# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use to break down input and generate output. In this section, we'll discuss what tokens are and how they are used by language models.

## What is a token?

A **token** is the basic unit that a language model reads, processes, and generates. These units can vary based on how the model provider defines them, but in general, they could represent:

* A whole word (e.g., "apple"),
* A part of a word (e.g., "app"),
* Or other linguistic components such as punctuation or spaces.

The way the model tokenizes the input depends on its **tokenizer algorithm**, which converts the input into tokens. Similarly, the modelâ€™s output comes as a stream of tokens, which is then decoded back into human-readable text.

## How tokens work in language models

Please see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters makes models both more efficient and better at understanding context and grammar. Tokens represent meaningful units, like whole words or parts of words, allowing models to capture language structure more effectively than by processing raw characters. Token-level processing also reduces the number of units the model has to handle, leading to faster computation.

In contrast, character-level processing would require handling a much larger sequence of input, making it harder for the model to learn relationships and context. Tokens enable models to focus on linguistic meaning, making them more accurate and efficient in generating responses.

## How tokens correspond to text

## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, language models focus on **tokens**, which represent meaningful linguistic units. Here's how the process works:

1. **Input Tokenization**: When you provide a model with a prompt (e.g., "LangChain is cool!"), the tokenizer algorithm splits the text into tokens. For example, the sentence could be tokenized into parts like `["Lang", "Chain", " is", " cool", "!"]`. Note that token boundaries donâ€™t always align with word boundaries.
    ![](/img/tokenization.png)

2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, capturing context and meaning from the input.
3. **Output Generation**: The model generates new tokens one by one. These output tokens are then decoded back into human-readable text.

Using tokens instead of raw characters allows the model to focus on linguistically meaningful units, which helps it capture grammar, structure, and context more effectively.

## Tokens donâ€™t have to be text

Although tokens are most commonly used to represent text, they donâ€™t have to be limited to textual data. Tokens can also serve as abstract representations of **multi-modal data**, such as:

- **Images**,
- **Audio**,
- **Video**,
- And other types of data.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q106®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9cf52ada-ba6f-9883-5152-d1cd70e931eb­checkpoint_nsÙ-generate:9cf52ada-ba6f-9883-5152-d1cd70e931eb¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@508d5b2e43374d74951ab4c6b7908af66c88eb6eb93be74762d7c31351d6bed6¢tsËAÚöìâÈ¨trace_idÙ$d9021167-bad8-4185-ac7b-42ad13243507­parent_run_idÙ$e53505fd-f534-4c4e-a2dd-e55e12a4d2e4¦run_idÙ$d9021167-bad8-4185-ac7b-42ad13243507ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚomessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How many tokens is 100 English words approximately equal to? \nContext: ## How tokens correspond to text\n\nPlease see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and how they correspond to text.\n\nAccording to the OpenAI post, the approximate token counts for English text are as follows:\n\n* 1 token ~= 4 chars in English\n* 1 token ~= Â¾ words\n* 100 tokens ~= 75 words\n\n# Tokens\n\nModern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use to break down input and generate output. In this section, we\'ll discuss what tokens are and how they are used by language models.\n\n## What is a token?\n\nA **token** is the basic unit that a language model reads, processes, and generates. These units can vary based on how the model provider defines them, but in general, they could represent:\n\n* A whole word (e.g., "apple"),\n* A part of a word (e.g., "app"),\n* Or other linguistic components such as punctuation or spaces.\n\nThe way the model tokenizes the input depends on its **tokenizer algorithm**, which converts the input into tokens. Similarly, the modelâ€™s output comes as a stream of tokens, which is then decoded back into human-readable text.\n\n## How tokens work in language models\n\nPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.\n\n## Why not use characters?\n\nUsing tokens instead of individual characters makes models both more efficient and better at understanding context and grammar. Tokens represent meaningful units, like whole words or parts of words, allowing models to capture language structure more effectively than by processing raw characters. Token-level processing also reduces the number of units the model has to handle, leading to faster computation.\n\nIn contrast, character-level processing would require handling a much larger sequence of input, making it harder for the model to learn relationships and context. Tokens enable models to focus on linguistic meaning, making them more accurate and efficient in generating responses.\n\n## How tokens correspond to text\n\n## How tokens work in language models\n\nThe reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, language models focus on **tokens**, which represent meaningful linguistic units. Here\'s how the process works:\n\n1. **Input Tokenization**: When you provide a model with a prompt (e.g., "LangChain is cool!"), the tokenizer algorithm splits the text into tokens. For example, the sentence could be tokenized into parts like `["Lang", "Chain", " is", " cool", "!"]`. Note that token boundaries donâ€™t always align with word boundaries.\n    ![](/img/tokenization.png)\n\n2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, capturing context and meaning from the input.\n3. **Output Generation**: The model generates new tokens one by one. These output tokens are then decoded back into human-readable text.\n\nUsing tokens instead of raw characters allows the model to focus on linguistically meaningful units, which helps it capture grammar, structure, and context more effectively.\n\n## Tokens donâ€™t have to be text\n\nAlthough tokens are most commonly used to represent text, they donâ€™t have to be limited to textual data. Tokens can also serve as abstract representations of **multi-modal data**, such as:\n\n- **Images**,\n- **Audio**,\n- **Video**,\n- And other types of data. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@6cfb6d94ed1c0403ee442acceb093036471a654d9a1864920a6129576ba4bbe7¢tsËAÚöíC 
¨focus_msÍè§payload‚¤role©assistant§contentÙÌApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would translate to around 133 tokens.ªfocus_kind¬exec_latency¨query_id¤Q106‰¢idÙ@aefd428fa3eb87085e9b01758dfb9bbcf5bf426537039c922edcd1f1c38c2300¢tsËAÚöíC¶>¨trace_idÙ$e53505fd-f534-4c4e-a2dd-e55e12a4d2e4­parent_run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879¦run_idÙ$e53505fd-f534-4c4e-a2dd-e55e12a4d2e4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÌApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would translate to around 133 tokens.¨query_id¤Q106ªfocus_kind¶chain_execution_result‰¢idÙ@c7334ee9e09d0094316ba2010d10c2192cb3f714ca04835bc2e5de89ce00605e¢tsËAÚöíC¿¾¨trace_idÙ$87062ed7-8473-424e-be94-9e5d255e2879­parent_run_idÀ¦run_idÙ$87062ed7-8473-424e-be94-9e5d255e2879ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¦answerÙÌApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would translate to around 133 tokens.¨query_id¤Q106ªfocus_kind¶chain_execution_result‹¢idÙ@617678a505cbf8ca9ab71f99ac0504b017153db6a1f57f1ae0ea0080632a1a12¢tsËAÚöíCÑ¨trace_id¤Q107­parent_run_idÀ¦run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.¨query_id¤Q107§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q107ªfocus_kind¯chain_execution‹¢idÙ@373af70efc0a42bf47518cf68f2bfc8b4f9e03fe3b47307e0e2fc893b54a1276¢tsËAÚöíCÜM¨trace_id¤Q107­parent_run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830¦run_idÙ$09349cdb-b976-4c13-9f86-64e3b3906c04ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context¦answer ¨query_id¤Q107¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q107®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d9993d48-cb31-9ed5-82c7-4fc63408aa74ªfocus_kind¯chain_execution‰¢idÙ@e0b313f97057b44204fd27167db05aa0ac1662cb3cf5ba9238b32cbf6a758687¢tsËAÚöíVn¹¨trace_idÙ$09349cdb-b976-4c13-9f86-64e3b3906c04­parent_run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830¦run_idÙ$09349cdb-b976-4c13-9f86-64e3b3906c04ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q107ªfocus_kind¶chain_execution_result‹¢idÙ@91ca0efce44cbc5a3ae663b0118e1646d625c64fddc09271a918b4c5985350b5¢tsËAÚöíV}·¨trace_id¤Q107­parent_run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830¦run_idÙ$6dde6e60-cb9d-4764-9a4f-7f0a754f59eeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q107¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q107®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9c23af30-a40e-377d-8004-0603bbdaea8fªfocus_kind¯chain_execution‹¢idÙ@9eed0cc7ebebc706e5d864cbaa2c23d25a884fccd7ea77da6ebedc422ed922f6¢tsËAÚöíV†Â¨trace_id¤Q107­parent_run_idÙ$6dde6e60-cb9d-4764-9a4f-7f0a754f59ee¦run_idÙ$3012f798-b876-4cd4-97eb-bcef7dcdbeeaªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§contextÚ'When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the hood, it'll have `invoke` (or `ainvoke`) use the `stream` (or `astream`) method to generate its output. The result of the invocation will be the same as far as the code that was using `invoke` is concerned; however, while the chat model is being streamed, LangChain will take care of invoking `on_llm_new_token` events in LangChain's [callback system](/docs/concepts/callbacks). These callback events
allow LangGraph `stream`/`astream` and `astream_events` to surface the chat model's output in real-time.

Example:

```python
def node(state):
    ...
    # The code below uses the invoke method, but LangChain will 
    # automatically switch to streaming mode
    # when it detects that the overall 
    # application is being streamed.
    ai_message = model.invoke(state["messages"])
    ...

## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations (e.g., making API calls, reading files) will have an asynchronous counterpart.

In LangChain, async implementations are located in the same classes as their synchronous counterparts, with the asynchronous methods having an "a" prefix. For example, the synchronous `invoke` method has an asynchronous counterpart called `ainvoke`.

Many components of LangChain implement the [Runnable Interface](/docs/concepts/runnables), which includes support for asynchronous execution. This means that you can run Runnables asynchronously using the `await` keyword in Python.

```python
await some_runnable.ainvoke(some_input)
```

```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement the [Runnable Interface](/docs/concepts/runnables) usually still follow the same rule and include the asynchronous version of method in the same class with an "a" prefix.

For example,

```python
await some_vectorstore.aadd_documents(documents)
```

Runnables created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel) can also be run asynchronously as they implement
the full [Runnable Interface](/docs/concepts/runnables).

For more information, please review the [API reference](https://python.langchain.com/api_reference/) for the specific component you are using.

## Delegation to sync methods

The result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```python
result = llm_with_tools.invoke("What is 2 multiplied by 3?")
```

As before, the output `result` will be an `AIMessage`. 
But, if the tool was called, `result` will have a `tool_calls` attribute.
This attribute includes everything needed to execute the tool, including the tool name and input arguments:

```
result.tool_calls
{'name': 'multiply', 'args': {'a': 2, 'b': 3}, 'id': 'xxx', 'type': 'tool_call'}
```

For more details on usage, see our [how-to guides](/docs/how_to/#tools)!

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitly calling the streaming methods. This is particularly useful when you use the non-streaming `invoke` method but still want to stream the entire application, including intermediate results from the chat model.

### How It Works

When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q107®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9c23af30-a40e-377d-8004-0603bbdaea8f­checkpoint_nsÙ-generate:9c23af30-a40e-377d-8004-0603bbdaea8f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@250ac7a5e2df3bc17923d92f1f262751c9eccc53987b5803746294f941acbe09¢tsËAÚöíV“¼¨trace_idÙ$3012f798-b876-4cd4-97eb-bcef7dcdbeea­parent_run_idÙ$6dde6e60-cb9d-4764-9a4f-7f0a754f59ee¦run_idÙ$3012f798-b876-4cd4-97eb-bcef7dcdbeeaªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ!messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain the difference between `invoke` and `ainvoke`. \nContext: When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. \n\nUnder the hood, it\'ll have `invoke` (or `ainvoke`) use the `stream` (or `astream`) method to generate its output. The result of the invocation will be the same as far as the code that was using `invoke` is concerned; however, while the chat model is being streamed, LangChain will take care of invoking `on_llm_new_token` events in LangChain\'s [callback system](/docs/concepts/callbacks). These callback events\nallow LangGraph `stream`/`astream` and `astream_events` to surface the chat model\'s output in real-time.\n\nExample:\n\n```python\ndef node(state):\n    ...\n    # The code below uses the invoke method, but LangChain will \n    # automatically switch to streaming mode\n    # when it detects that the overall \n    # application is being streamed.\n    ai_message = model.invoke(state["messages"])\n    ...\n\n## Langchain asynchronous APIs\n\nMany LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.\n\nTypically, any method that may perform I/O operations (e.g., making API calls, reading files) will have an asynchronous counterpart.\n\nIn LangChain, async implementations are located in the same classes as their synchronous counterparts, with the asynchronous methods having an "a" prefix. For example, the synchronous `invoke` method has an asynchronous counterpart called `ainvoke`.\n\nMany components of LangChain implement the [Runnable Interface](/docs/concepts/runnables), which includes support for asynchronous execution. This means that you can run Runnables asynchronously using the `await` keyword in Python.\n\n```python\nawait some_runnable.ainvoke(some_input)\n```\n\n```python\nawait some_runnable.ainvoke(some_input)\n```\n\nOther components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement the [Runnable Interface](/docs/concepts/runnables) usually still follow the same rule and include the asynchronous version of method in the same class with an "a" prefix.\n\nFor example,\n\n```python\nawait some_vectorstore.aadd_documents(documents)\n```\n\nRunnables created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel) can also be run asynchronously as they implement\nthe full [Runnable Interface](/docs/concepts/runnables).\n\nFor more information, please review the [API reference](https://python.langchain.com/api_reference/) for the specific component you are using.\n\n## Delegation to sync methods\n\nThe result would be an `AIMessage` containing the model\'s response in natural language (e.g., "Hello!").\nHowever, if we pass an input *relevant to the tool*, the model should choose to call it:\n\n```python\nresult = llm_with_tools.invoke("What is 2 multiplied by 3?")\n```\n\nAs before, the output `result` will be an `AIMessage`. \nBut, if the tool was called, `result` will have a `tool_calls` attribute.\nThis attribute includes everything needed to execute the tool, including the tool name and input arguments:\n\n```\nresult.tool_calls\n{\'name\': \'multiply\', \'args\': {\'a\': 2, \'b\': 3}, \'id\': \'xxx\', \'type\': \'tool_call\'}\n```\n\nFor more details on usage, see our [how-to guides](/docs/how_to/#tools)!\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n## "Auto-Streaming" Chat Models\n\nLangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitly calling the streaming methods. This is particularly useful when you use the non-streaming `invoke` method but still want to stream the entire application, including intermediate results from the chat model.\n\n### How It Works\n\nWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@f11075c37316b3a81bf9384f92cc799907142554d17ede4059a26cfe097c3e02¢tsËAÚöíÂšI¨focus_msÍ—§payload‚¤role©assistant§contentÚThe `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, the main difference lies in their execution style: synchronous for `invoke` and asynchronous for `ainvoke`.ªfocus_kind¬exec_latency¨query_id¤Q107‰¢idÙ@161978ce95a8f7f620c79b550d5e4a18a2634712039bf0b19604e0801eacf6f4¢tsËAÚöíÂ«Ş¨trace_idÙ$6dde6e60-cb9d-4764-9a4f-7f0a754f59ee­parent_run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830¦run_idÙ$6dde6e60-cb9d-4764-9a4f-7f0a754f59eeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, the main difference lies in their execution style: synchronous for `invoke` and asynchronous for `ainvoke`.¨query_id¤Q107ªfocus_kind¶chain_execution_result‰¢idÙ@d6445914f5b1cd85c0a8953e6f35c35b399ed9cb47a3a487804f54385a854d90¢tsËAÚöíÂ´»¨trace_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830­parent_run_idÀ¦run_idÙ$ce76889d-83dc-469a-a7ed-20af92b0c830ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚThe `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, the main difference lies in their execution style: synchronous for `invoke` and asynchronous for `ainvoke`.¨query_id¤Q107ªfocus_kind¶chain_execution_result‹¢idÙ@980fe3c74951c2f026aa2486d038524e59fe63b369374177e04c7c237e678933¢tsËAÚöíÂ¾b¨trace_id¤Q108­parent_run_idÀ¦run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?¨query_id¤Q108§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q108ªfocus_kind¯chain_execution‹¢idÙ@27bfc3a70ce62088484ef82769feac7f4b21fe10ffe93575ddc46232ef2be55e¢tsËAÚöíÂÉ°¨trace_id¤Q108­parent_run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aa¦run_idÙ$bb040ea0-3c18-4799-b789-332b4e2a3367ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context¦answer ¨query_id¤Q108¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q108®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f494b9c2-5f24-f316-09a6-b268c3fab10aªfocus_kind¯chain_execution‰¢idÙ@f90e53b6b7ecbc7ca8d05d88a33d9afdd3baa649bc135bea002fa978cd72b404¢tsËAÚöíÎ4¨trace_idÙ$bb040ea0-3c18-4799-b789-332b4e2a3367­parent_run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aa¦run_idÙ$bb040ea0-3c18-4799-b789-332b4e2a3367ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q108ªfocus_kind¶chain_execution_result‹¢idÙ@8a6a113745dfbff1bceef10d777436cc805532a9f53449df1bb4a81db4603fa4¢tsËAÚöíÎ;¨trace_id¤Q108­parent_run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aa¦run_idÙ$536a4871-2c6e-48dd-8826-d35ac27ae12cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q108¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q108®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9c87d369-fb45-c946-d4a9-70d7600c7343ªfocus_kind¯chain_execution‹¢idÙ@b87ef8be51b3ab213efac666fccf570282682006fc36ef2c3caa723ebf1e5b24¢tsËAÚöíÎ@>¨trace_id¤Q108­parent_run_idÙ$536a4871-2c6e-48dd-8826-d35ac27ae12c¦run_idÙ$7c4c2b99-44fe-4ac3-90ad-bb43e8697e37ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§contextÚè<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.

### Setting max concurrency

If using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.


:::tip
If you're trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q108®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9c87d369-fb45-c946-d4a9-70d7600c7343­checkpoint_nsÙ-generate:9c87d369-fb45-c946-d4a9-70d7600c7343¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@50e2f4cc9702b8f8e376cb3fec00756615225fb160d9482764093437342b40ab¢tsËAÚöíÎFÔ¨trace_idÙ$7c4c2b99-44fe-4ac3-90ad-bb43e8697e37­parent_run_idÙ$536a4871-2c6e-48dd-8826-d35ac27ae12c¦run_idÙ$7c4c2b99-44fe-4ac3-90ad-bb43e8697e37ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚßmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does `batch_as_completed` return with each result to help match inputs? \nContext: <a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\nThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nSome Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.\n\n### Setting max concurrency\n\nIf using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.\n\n\n:::tip\nIf you\'re trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@fde7638954169dca7ce5cbd654aaf9dc32caa02b7e06fa27bb0218b4359e8e37¢tsËAÚöîã¨focus_msÍÛ§payload‚¤role©assistant§contentÙû`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original input. This allows users to identify which input corresponds to each result, even if the results arrive out of order.ªfocus_kind¬exec_latency¨query_id¤Q108‰¢idÙ@a9abe07382395439a2397dfb5188546f1a140ea07e50cda134c6d46b851522fc¢tsËAÚöîğª¨trace_idÙ$536a4871-2c6e-48dd-8826-d35ac27ae12c­parent_run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aa¦run_idÙ$536a4871-2c6e-48dd-8826-d35ac27ae12cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙû`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original input. This allows users to identify which input corresponds to each result, even if the results arrive out of order.¨query_id¤Q108ªfocus_kind¶chain_execution_result‰¢idÙ@947f62622c0d1b0a3ce57863f688e8b2247128f1e2ee24a324e047219a1e088b¢tsËAÚöîûa¨trace_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aa­parent_run_idÀ¦run_idÙ$859e848f-ef17-4779-be7a-5d8ae41f01aaªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÙû`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original input. This allows users to identify which input corresponds to each result, even if the results arrive out of order.¨query_id¤Q108ªfocus_kind¶chain_execution_result‹¢idÙ@5d2ce9d28216d6ad8dc60251b3a137cc854883103d2cca89c3695065d671ac80¢tsËAÚöî¨trace_id¤Q109­parent_run_idÀ¦run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?¨query_id¤Q109§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q109ªfocus_kind¯chain_execution‹¢idÙ@1793ec456dfcce613f726b7ecff97426f51886216ac3f87ba102e05f28addda0¢tsËAÚöî(¨trace_id¤Q109­parent_run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03¦run_idÙ$9fab3e81-b80a-4917-b65e-f91386d86497ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context¦answer ¨query_id¤Q109¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q109®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3be619da-13f0-d09e-b6cb-14f5ab5a33a4ªfocus_kind¯chain_execution‰¢idÙ@fe77621b59f5417adc1e5be2d981a83c4824f9e171d87dc6ea529d421845cc1d¢tsËAÚöî-²¨trace_idÙ$9fab3e81-b80a-4917-b65e-f91386d86497­parent_run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03¦run_idÙ$9fab3e81-b80a-4917-b65e-f91386d86497ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¨query_id¤Q109ªfocus_kind¶chain_execution_result‹¢idÙ@b39a50e54582781556942496065e93943b61260174f3a888fb4e65e69cf400ac¢tsËAÚöî-Š½¨trace_id¤Q109­parent_run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03¦run_idÙ$0aafaca1-f46f-400e-b026-90d2f8a6f61eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answer ¨query_id¤Q109¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q109®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:58685b13-4a56-3a17-79b1-3ed429f33c8fªfocus_kind¯chain_execution‹¢idÙ@5a14ea0311d1aa9444893f29f3da9073d9f99f70280cc9c39e00073fea4be870¢tsËAÚöî-¨trace_id¤Q109­parent_run_idÙ$0aafaca1-f46f-400e-b026-90d2f8a6f61e¦run_idÙ$3dbe8d95-9c4f-4b88-a370-74003145bf8dªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§contextÚHThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabItem value="chroma" label="Chroma" default>

This walkthrough uses the `chroma` vector database, which runs on your local machine as a library.

```bash
pip install langchain-chroma
```

```python
from langchain_chroma import Chroma

db = Chroma.from_documents(documents, OpenAIEmbeddings())
```

  </TabItem>
  <TabItem value="faiss" label="FAISS">

This walkthrough uses the `FAISS` vector database, which makes use of the Facebook AI Similarity Search (FAISS) library.

```bash
pip install faiss-cpu
```

```python
from langchain_community.vectorstores import FAISS

db = FAISS.from_documents(documents, OpenAIEmbeddings())
```

  </TabItem>
  <TabItem value="lance" label="Lance">

:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## Conclusion

LangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:
- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.
- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).

:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with embeddings.
* See Pinecone's [blog post](https://www.pinecone.io/learn/vector-similarity/) on similarity metrics.
* See OpenAI's [FAQ](https://platform.openai.com/docs/guides/embeddings/faq) on what similarity metric to use with OpenAI embeddings.

:::

### Similarity search

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q109®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:58685b13-4a56-3a17-79b1-3ed429f33c8f­checkpoint_nsÙ-generate:58685b13-4a56-3a17-79b1-3ed429f33c8f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@55f18eefad0248e26c33c915ee2f0916838abff41754b782f624da91e4cc9827¢tsËAÚöî-™g¨trace_idÙ$3dbe8d95-9c4f-4b88-a370-74003145bf8d­parent_run_idÙ$0aafaca1-f46f-400e-b026-90d2f8a6f61e¦run_idÙ$3dbe8d95-9c4f-4b88-a370-74003145bf8dªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ"messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Why might you choose Chroma over FAISS for prototyping? \nContext: There are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.\n\n\n<Tabs>\n  <TabItem value="chroma" label="Chroma" default>\n\nThis walkthrough uses the `chroma` vector database, which runs on your local machine as a library.\n\n```bash\npip install langchain-chroma\n```\n\n```python\nfrom langchain_chroma import Chroma\n\ndb = Chroma.from_documents(documents, OpenAIEmbeddings())\n```\n\n  </TabItem>\n  <TabItem value="faiss" label="FAISS">\n\nThis walkthrough uses the `FAISS` vector database, which makes use of the Facebook AI Similarity Search (FAISS) library.\n\n```bash\npip install faiss-cpu\n```\n\n```python\nfrom langchain_community.vectorstores import FAISS\n\ndb = FAISS.from_documents(documents, OpenAIEmbeddings())\n```\n\n  </TabItem>\n  <TabItem value="lance" label="Lance">\n\n:::info[Further reading]\n\nSee our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.\n\n:::\n\n## Conclusion\n\nLangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:\n- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.\n- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).\n\n:::info[Further reading]\n\n* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with embeddings.\n* See Pinecone\'s [blog post](https://www.pinecone.io/learn/vector-similarity/) on similarity metrics.\n* See OpenAI\'s [FAQ](https://platform.openai.com/docs/guides/embeddings/faq) on what similarity metric to use with OpenAI embeddings.\n\n:::\n\n### Similarity search\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@07e2b83cdc47db22f50a3e3cec84ceff6b6be10d3718afc56454ddb2120a0d86¢tsËAÚöîä£¨focus_msÍé§payload‚¤role©assistant§contentÚfYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing.ªfocus_kind¬exec_latency¨query_id¤Q109‰¢idÙ@e84d9437064b40eb299379e361697b0636bde0b43d93e0e2ba755ded1190c096¢tsËAÚöîö¶¨trace_idÙ$0aafaca1-f46f-400e-b026-90d2f8a6f61e­parent_run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03¦run_idÙ$0aafaca1-f46f-400e-b026-90d2f8a6f61eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚfYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing.¨query_id¤Q109ªfocus_kind¶chain_execution_result‰¢idÙ@578d46686f02ac1a38c3f7ed2ac0dad2f2605d3461b22d26e7ed0adccc4f0f0f¢tsËAÚöîÿ;¨trace_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03­parent_run_idÀ¦run_idÙ$5775e505-e79f-40ec-a7b4-065b1d5f5c03ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answerÚfYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing.¨query_id¤Q109ªfocus_kind¶chain_execution_result