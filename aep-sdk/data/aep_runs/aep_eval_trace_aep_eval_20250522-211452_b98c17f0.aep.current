‰¢idÙ@f26129136de5ee46fb6846882c03e0b94187c79f3a49ed5c0ca63ecb0f2633c1¢tsËAÚó ’-¨trace_idÙ$78a46042-7ebf-499c-a6ea-a0c9ad4e510a­parent_run_idÙ$ca008e13-8ee6-4238-8258-65967c5b6c37¦run_idÙ$78a46042-7ebf-499c-a6ea-a0c9ad4e510aªevent_type¬chain_output¬event_source¥chain§payload§outputsÚAmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name two ChatModel parameters that help avoid exceeding rate limits. \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\nSome important things to note:\n\n- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can\'t be supported on these.\n- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they\'re not enforced on models in `langchain-community`.\n\nChat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.\n\n## Tool calling\n\nChat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please\nsee the [tool calling](/docs/concepts/tool_calling) guide for more information.\n\nMany of the key methods of chat models operate on [messages](/docs/concepts/messages) as input and return messages as output.\n\nChat models offer a standard set of parameters that can be used to configure the model. These parameters are typically used to control the behavior of the model, such as the temperature of the output, the maximum number of tokens in the response, and the maximum time to wait for a response. Please see the [standard parameters](#standard-parameters) section for more details.\n\n:::note\nIn documentation, we will often use the terms "LLM" and "Chat Model" interchangeably. This is because most modern LLMs are exposed to users via a chat model interface. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@d7a2388cb5dadfb038857d65275b12ac5c013e34eced956749da6e8dc38a8b63¢tsËAÚó éÎò¨focus_msÍ?§payload‚¤role©assistant§contentÙÓTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after hitting a rate limit error.ªfocus_kind¬exec_latency¨query_id¤Q056‰¢idÙ@bae8bc369f502fd0cc0a84a2e7a2e6c6f7c138902041cd666e32206caf562f29¢tsËAÚó éİº¨trace_idÙ$ca008e13-8ee6-4238-8258-65967c5b6c37­parent_run_idÙ$c665a74e-4bdb-42fa-8eea-baf15b13b924¦run_idÙ$ca008e13-8ee6-4238-8258-65967c5b6c37ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÓTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after hitting a rate limit error.¨query_id¤Q056ªfocus_kind¶chain_execution_result‰¢idÙ@30329a9d4a4b3bf7f7c0343204e081e02dceca5cb59d985f162d729e412f2196¢tsËAÚó éçO¨trace_idÙ$c665a74e-4bdb-42fa-8eea-baf15b13b924­parent_run_idÀ¦run_idÙ$c665a74e-4bdb-42fa-8eea-baf15b13b924ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙDName two ChatModel parameters that help avoid exceeding rate limits.§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËMany of the key methods of chat models operate on [messages](/docs/concepts/messages) as input and return messages as output.

Chat models offer a standard set of parameters that can be used to config...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÙÓTwo ChatModel parameters that help avoid exceeding rate limits are `rate_limiter`, which controls the rate of requests, and `max_retries`, which determines the number of retries after hitting a rate limit error.¨query_id¤Q056ªfocus_kind¶chain_execution_result‹¢idÙ@55ffff5701b1fdb10cc09738c1ff5035cbe5e5ed3599df756ebf374abb2836c1¢tsËAÚó éîš¨trace_id¤Q057­parent_run_idÀ¦run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?¨query_id¤Q057§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q057ªfocus_kind¯chain_execution‹¢idÙ@9fd795f0ea2a4447f068fb7ec209415f7bb961536bcfd2dfd591e07746f359ab¢tsËAÚó é÷#¨trace_id¤Q057­parent_run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989e¦run_idÙ$cb9ee815-fe95-4aaa-bcf2-2ecc7fa997ddªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context¦answer ¨query_id¤Q057¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q057®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:db087e3d-1e6e-c73b-99b7-25dc579777f8ªfocus_kind¯chain_execution‰¢idÙ@773a2a5b835bbfe8e98bb155ed71b8f0fd3257f5ff09f380ddc7debca50d8102¢tsËAÚó şxF¨trace_idÙ$cb9ee815-fe95-4aaa-bcf2-2ecc7fa997dd­parent_run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989e¦run_idÙ$cb9ee815-fe95-4aaa-bcf2-2ecc7fa997ddªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q057ªfocus_kind¶chain_execution_result‹¢idÙ@1d0c64bc9d18178cc366ecf85312dec0792213715d268760703ddb11986ce4d4¢tsËAÚó ş‰¨trace_id¤Q057­parent_run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989e¦run_idÙ$8700e197-2a1a-4d00-915f-0fd961bf27b6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q057¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q057®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1d1f5126-7536-b9f3-48d6-7ed55b86db73ªfocus_kind¯chain_execution‹¢idÙ@9ba654bf0200b6b8bad385d348811bad0a1fcb9e9b36cd24e6587a44d272d372¢tsËAÚó ş‡¨trace_id¤Q057­parent_run_idÙ$8700e197-2a1a-4d00-915f-0fd961bf27b6¦run_idÙ$b9a615f0-51f2-4c11-b65b-f4b559f24f10ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ4How do you specify a custom UUID for a Runnable run?§contextÚN:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnecessary for most users.
:::

You may need to set a custom `run_id` for a given run, in case you want 
to reference it later or correlate it with other systems.

The `run_id` MUST be a valid UUID string and **unique** for each run. It is used to identify
the parent run, sub-class will get their own unique run ids automatically.

To set a custom `run_id`, you can pass it as a key-value pair in the `config` dictionary when invoking the Runnable:

```python
import uuid

run_id = uuid.uuid4()

some_runnable.invoke(
   some_input, 
   config={
      'run_id': run_id
   }
)

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.
* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.

See the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.

### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.

The `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.

The `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.

Using these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can
filter and search on.

The attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q057®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1d1f5126-7536-b9f3-48d6-7ed55b86db73­checkpoint_nsÙ-generate:1d1f5126-7536-b9f3-48d6-7ed55b86db73¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3722fbff1ae1637f25eeffe9d1fed05d3a268e7ace0fe93e682da13aef3971ba¢tsËAÚó ş‘É¨trace_idÙ$b9a615f0-51f2-4c11-b65b-f4b559f24f10­parent_run_idÙ$8700e197-2a1a-4d00-915f-0fd961bf27b6¦run_idÙ$b9a615f0-51f2-4c11-b65b-f4b559f24f10ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ>messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you specify a custom UUID for a Runnable run? \nContext: :::note Related\n* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n:::\n\n### Setting run id\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nYou may need to set a custom `run_id` for a given run, in case you want \nto reference it later or correlate it with other systems.\n\nThe `run_id` MUST be a valid UUID string and **unique** for each run. It is used to identify\nthe parent run, sub-class will get their own unique run ids automatically.\n\nTo set a custom `run_id`, you can pass it as a key-value pair in the `config` dictionary when invoking the Runnable:\n\n```python\nimport uuid\n\nrun_id = uuid.uuid4()\n\nsome_runnable.invoke(\n   some_input, \n   config={\n      \'run_id\': run_id\n   }\n)\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.\n* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.\n\nSee the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.\n\n### Setting custom run name, tags, and metadata\n\nThe `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.\n\nThe `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.\n\nThe `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.\n\nUsing these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can\nfilter and search on.\n\nThe attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@e6c462bca5257fd59b57dc0e55a2b420b436a756adfa902f7d0af0eded1791fb¢tsËAÚó!”Y¸¨focus_msÍ	$§payload‚¤role©assistant§contentÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.ªfocus_kind¬exec_latency¨query_id¤Q057‰¢idÙ@101198ad58116fed3b34ebbf04257cd393537b2ecdfd14d9e983f01d53867f39¢tsËAÚó!”k¨trace_idÙ$8700e197-2a1a-4d00-915f-0fd961bf27b6­parent_run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989e¦run_idÙ$8700e197-2a1a-4d00-915f-0fd961bf27b6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.¨query_id¤Q057ªfocus_kind¶chain_execution_result‰¢idÙ@c03436b146221cd17a6f758445947636957d637384588e6db294b5a1c0b9790a¢tsËAÚó!”w¦¨trace_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989e­parent_run_idÀ¦run_idÙ$0edee574-5d7d-4d2f-8287-b1f0cd46989eªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ4How do you specify a custom UUID for a Runnable run?§context•‚´page_content_summaryÙË:::note Related
* [How-to trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
:::

### Setting run id

:::note
This is an advanced feature that is unnece...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚrTo specify a custom UUID for a Runnable run, you need to pass it as a key-value pair in the `config` dictionary when invoking the Runnable. The `run_id` must be a valid UUID string and unique for each run. For example, you can generate a UUID using `uuid.uuid4()` and include it in the invocation like this: `some_runnable.invoke(some_input, config={'run_id': run_id})`.¨query_id¤Q057ªfocus_kind¶chain_execution_result‹¢idÙ@4e1f7572ef0cd2c27d50660f263e442227954c86a6d75abcd7a9447173c332bd¢tsËAÚó!”‡ä¨trace_id¤Q058­parent_run_idÀ¦run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.¨query_id¤Q058§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q058ªfocus_kind¯chain_execution‹¢idÙ@379615497c165d9ccc7b5e1e7da33c26e04191068caeb814a4edfed407ed4099¢tsËAÚó!”•´¨trace_id¤Q058­parent_run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140¦run_idÙ$e2095b5d-006f-4427-aaa1-54c2dbf56a87ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context¦answer ¨query_id¤Q058¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q058®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:81885b4d-4637-4f73-4251-f7808dfc9056ªfocus_kind¯chain_execution‰¢idÙ@4a611e73a74420d826520da5b9b1632f588993009781af0f1564419da8046129¢tsËAÚó!§;-¨trace_idÙ$e2095b5d-006f-4427-aaa1-54c2dbf56a87­parent_run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140¦run_idÙ$e2095b5d-006f-4427-aaa1-54c2dbf56a87ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q058ªfocus_kind¶chain_execution_result‹¢idÙ@1047e79bbf55c95c0c93d906757bb71f93e5f489a04835040cd1bc375c44dd6f¢tsËAÚó!§C9¨trace_id¤Q058­parent_run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140¦run_idÙ$e0aea0c7-abb1-497b-b11f-3b1361649f7bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q058¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q058®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:367060eb-029c-a5b5-1fab-d6affdb41f39ªfocus_kind¯chain_execution‹¢idÙ@90f1496df4ff8ebf27a48d092b70de3e6904a2ebb5de23d397e097ed1db15983¢tsËAÚó!§I8¨trace_id¤Q058­parent_run_idÙ$e0aea0c7-abb1-497b-b11f-3b1361649f7b¦run_idÙ$55464d77-f87d-4115-acb5-86256dab5d97ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§contextÚÁ<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.
- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q058®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:367060eb-029c-a5b5-1fab-d6affdb41f39­checkpoint_nsÙ-generate:367060eb-029c-a5b5-1fab-d6affdb41f39¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@f6d97f2158a5e80541b584518cf6d59dfd996f9e8cd670c100672dc92c7f5931¢tsËAÚó!§Wq¨trace_idÙ$55464d77-f87d-4115-acb5-86256dab5d97­parent_run_idÙ$e0aea0c7-abb1-497b-b11f-3b1361649f7b¦run_idÙ$55464d77-f87d-4115-acb5-86256dab5d97ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¤messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Compare `batch` and `batch_as_completed` when processing multiple inputs. \nContext: <a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\nThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.\n- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@012aeee8beef5c36f09c12fb27c3686bdd3f0f4b9f04b4420a6facc97e865963¢tsËAÚó"+¤<¨focus_msÍ§payload‚¤role©assistant§contentÚìThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. Additionally, users can control the maximum number of parallel calls with the `max_concurrency` attribute.ªfocus_kind¬exec_latency¨query_id¤Q058‰¢idÙ@93bbcee80e7e5fe8170583fd4f994e32e8549a0eee41305d47c65b65263ee375¢tsËAÚó"+¯³¨trace_idÙ$e0aea0c7-abb1-497b-b11f-3b1361649f7b­parent_run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140¦run_idÙ$e0aea0c7-abb1-497b-b11f-3b1361649f7bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚìThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. Additionally, users can control the maximum number of parallel calls with the `max_concurrency` attribute.¨query_id¤Q058ªfocus_kind¶chain_execution_result‰¢idÙ@5e725221da1b328f7167eedd96675ef3299f11e4fa1d63032bdd036227b83ba4¢tsËAÚó"+ºs¨trace_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140­parent_run_idÀ¦run_idÙ$9ff207df-effc-4e91-ab8e-22cc250cf140ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙICompare `batch` and `batch_as_completed` when processing multiple inputs.§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚìThe `batch` method processes multiple inputs in parallel and returns results in the same order as the inputs, while `batch_as_completed` also processes inputs in parallel but returns results as they complete, which may be out of order. Both methods improve performance by allowing parallel execution, but the choice between them depends on whether maintaining input order is important. Additionally, users can control the maximum number of parallel calls with the `max_concurrency` attribute.¨query_id¤Q058ªfocus_kind¶chain_execution_result‹¢idÙ@138d3301908a97c821a33372e802275d83ea4684da19ff44155885bff4f82736¢tsËAÚó"+ÄÓ¨trace_id¤Q059­parent_run_idÀ¦run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?¨query_id¤Q059§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q059ªfocus_kind¯chain_execution‹¢idÙ@ffd7f33b93d6841f359449286406894c590247fc58721a954d80f3c4c7f0d32a¢tsËAÚó"+ÍÄ¨trace_id¤Q059­parent_run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85¦run_idÙ$64d5ee36-b463-43f1-99ff-588e8b90334bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context¦answer ¨query_id¤Q059¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q059®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7207bd04-7332-a685-b0a7-dfe13a185a11ªfocus_kind¯chain_execution‰¢idÙ@653233c1eff4a5dbd3e8b292d10da2ed7c6453488b43546e5dd7610c01127816¢tsËAÚó"<ÛM¨trace_idÙ$64d5ee36-b463-43f1-99ff-588e8b90334b­parent_run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85¦run_idÙ$64d5ee36-b463-43f1-99ff-588e8b90334bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q059ªfocus_kind¶chain_execution_result‹¢idÙ@9cf2676080e6252a596dad3e0d577e94721e259b3c7be1f1b6b9ef3b8f9100ca¢tsËAÚó"<ã¨trace_id¤Q059­parent_run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85¦run_idÙ$d91ab64c-eb34-484d-b158-42c393d0e35bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q059¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q059®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:857693e5-de7f-9691-f2e7-e36a54f3fc1aªfocus_kind¯chain_execution‹¢idÙ@c500f2df130f6e1d4cf6c60bbaedf57fee5d7d94ee5cb8b007c4156a766aab60¢tsËAÚó"<ç¸¨trace_id¤Q059­parent_run_idÙ$d91ab64c-eb34-484d-b158-42c393d0e35b¦run_idÙ$67495aa2-1b66-4988-818e-d60255aafe8bªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§contextÚ£## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally started as a single open source package, it has evolved into a company and a whole ecosystem.
This page will talk about the LangChain ecosystem as a whole.
Most of the components within the LangChain ecosystem can be used by themselves - so if you feel particularly drawn to certain components but not others, that is totally fine! Pick and choose whichever components you like best for your own use case!

## Features

There are several primary needs that LangChain aims to address:

### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: write a custom document loader](/docs/how_to/document_loader_custom)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)
- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)
- [How to: define a custom tool](/docs/how_to/custom_tools)
- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.
This diversity can make it challenging for developers to switch between providers or combine components when building applications.
LangChain exposes a standard interface for key components, making it easy to switch between providers.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q059®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:857693e5-de7f-9691-f2e7-e36a54f3fc1a­checkpoint_nsÙ-generate:857693e5-de7f-9691-f2e7-e36a54f3fc1a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c5b3fb1cec21edb2f8bd19594d86fdde6e15eaafeccd69042cf39e20c9f5514d¢tsËAÚó"<ğ»¨trace_idÙ$67495aa2-1b66-4988-818e-d60255aafe8b­parent_run_idÙ$d91ab64c-eb34-484d-b158-42c393d0e35b¦run_idÙ$67495aa2-1b66-4988-818e-d60255aafe8bªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ”messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How can LangChain assist with evaluating generated answers automatically? \nContext: ## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n# Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n# Why LangChain?\n\nThe goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.\nWhile LangChain originally started as a single open source package, it has evolved into a company and a whole ecosystem.\nThis page will talk about the LangChain ecosystem as a whole.\nMost of the components within the LangChain ecosystem can be used by themselves - so if you feel particularly drawn to certain components but not others, that is totally fine! Pick and choose whichever components you like best for your own use case!\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n### Custom\n\nAll of LangChain components can easily be extended to support your own versions.\n\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: write a custom document loader](/docs/how_to/document_loader_custom)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)\n- [How to: define a custom tool](/docs/how_to/custom_tools)\n- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.\nThis diversity can make it challenging for developers to switch between providers or combine components when building applications.\nLangChain exposes a standard interface for key components, making it easy to switch between providers. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@33b75951ed134b2f8ab12b96ed5df6709e3d986904a82c83e1f623e081407b59¢tsËAÚó"®"¨focus_msÍè§payload‚¤role©assistant§contentÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.ªfocus_kind¬exec_latency¨query_id¤Q059‰¢idÙ@736055c5a4d14ff321deca04e44d4248db9f7645e5157ab8164e7fb0def6bb3f¢tsËAÚó"®3Ï¨trace_idÙ$d91ab64c-eb34-484d-b158-42c393d0e35b­parent_run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85¦run_idÙ$d91ab64c-eb34-484d-b158-42c393d0e35bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.¨query_id¤Q059ªfocus_kind¶chain_execution_result‰¢idÙ@6a714d6984c541f7ee0a8fb4d52f90f2a7150098ca0ebba0fd453a0b37cbc006¢tsËAÚó"®AÍ¨trace_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85­parent_run_idÀ¦run_idÙ$83cf5b98-2b62-4b10-ad82-7c65a6ad2c85ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIHow can LangChain assist with evaluating generated answers automatically?§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË# Why LangChain?

The goal of `langchain` the Python package and LangChain the company is to make it as easy as possible for developers to build applications that reason.
While LangChain originally st...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÚØLangChain, through its integration with LangSmith, assists in evaluating generated answers by providing an evaluation framework that allows developers to define metrics and test their applications against curated datasets. It also enables tracking of results over time and supports automated evaluations as part of continuous integration processes. This systematic approach ensures that the performance and effectiveness of LLM applications meet desired quality standards.¨query_id¤Q059ªfocus_kind¶chain_execution_result‹¢idÙ@5814c3cca31e6450a827167d6325e06dbfc60f61e7997224c8897e94da9e2276¢tsËAÚó"®J¨trace_id¤Q060­parent_run_idÀ¦run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.¨query_id¤Q060§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q060ªfocus_kind¯chain_execution‹¢idÙ@5ad3c95e5934bb85dd620269d2c1700eda24a724769114736eea5d6ca66c16c1¢tsËAÚó"®S¬¨trace_id¤Q060­parent_run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834¦run_idÙ$91560df7-a669-49b4-8564-7c93713e88aaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context¦answer ¨query_id¤Q060¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q060®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:051c33d4-ddf1-31d6-6d98-815c697df0edªfocus_kind¯chain_execution‰¢idÙ@34828bf26669d2ca32e32088bfc3798cfef25eb6bef64a1ee6693bd2389fb587¢tsËAÚó"Á÷ô¨trace_idÙ$91560df7-a669-49b4-8564-7c93713e88aa­parent_run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834¦run_idÙ$91560df7-a669-49b4-8564-7c93713e88aaªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q060ªfocus_kind¶chain_execution_result‹¢idÙ@d417c0478e7d903ebb79406cd8be92dc95d5be0ad6eed61074154ef144f178e0¢tsËAÚó"Â‰¨trace_id¤Q060­parent_run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834¦run_idÙ$10f56f6c-12a2-4790-9adf-eac2fdd18685ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q060¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q060®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:a70f4e24-f108-3659-6559-043565df06e8ªfocus_kind¯chain_execution‹¢idÙ@b4da1347370dcc87881b16ea15ebff1b94a896e28b6de2abe285c09651d57882¢tsËAÚó"ÂÃ¨trace_id¤Q060­parent_run_idÙ$10f56f6c-12a2-4790-9adf-eac2fdd18685¦run_idÙ$ca4b7d91-0a9f-4bd6-a78a-2873372bfbafªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§contextÚ
# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.

To learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).

### Tracing
<span data-heading-keywords="trace,tracing"></span>

Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)

You can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).

## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.

:::

## Observability and evaluation

The pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. 
Developers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. 
High quality tracing and evaluations can help you rapidly answer these types of questions with confidence.
[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.
See our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.

:::info[Further reading]

:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## Conclusion

LangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:
- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.
- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q060®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:a70f4e24-f108-3659-6559-043565df06e8­checkpoint_nsÙ-generate:a70f4e24-f108-3659-6559-043565df06e8¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@931a877176de1ccfd02947df126d11f7326bdb966afc46f1fa9992bb4b7ee2ba¢tsËAÚó"Âì¨trace_idÙ$ca4b7d91-0a9f-4bd6-a78a-2873372bfbaf­parent_run_idÙ$10f56f6c-12a2-4790-9adf-eac2fdd18685¦run_idÙ$ca4b7d91-0a9f-4bd6-a78a-2873372bfbafªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÿmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Provide two metrics supported by LangChain\'s built in evaluation module. \nContext: # Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n### Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluating performance is a vital part of building LLM-powered applications.\nLangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.\n\nTo learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).\n\n### Tracing\n<span data-heading-keywords="trace,tracing"></span>\n\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\n- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n\nYou can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).\n\n## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n:::info[Further reading]\n\nHave a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.\n\n:::\n\n## Observability and evaluation\n\nThe pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. \nDevelopers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. \nHigh quality tracing and evaluations can help you rapidly answer these types of questions with confidence.\n[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.\nSee our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.\n\n:::info[Further reading]\n\n:::info[Further reading]\n\nSee our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.\n\n:::\n\n## Conclusion\n\nLangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:\n- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.\n- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/). \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@a9a7236ce5db7feb7c3d5b4d0a363327ca7f9b684fff2e0b5b010a5b5b58f556¢tsËAÚó"ø3­¨focus_msÍM§payload‚¤role©assistant§contentÙ®LangChain's built-in evaluation module supports metrics such as accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications.ªfocus_kind¬exec_latency¨query_id¤Q060‰¢idÙ@f42d6de808b83775ad61035c1a580fd6d5db249307e30f0f0e2552956436608b¢tsËAÚó"øD…¨trace_idÙ$10f56f6c-12a2-4790-9adf-eac2fdd18685­parent_run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834¦run_idÙ$10f56f6c-12a2-4790-9adf-eac2fdd18685ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ®LangChain's built-in evaluation module supports metrics such as accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications.¨query_id¤Q060ªfocus_kind¶chain_execution_result‰¢idÙ@342b29adb5b58db294a142fb0ab6491870e29a6712989c61f7c4d82f6d0f01ce¢tsËAÚó"øNË¨trace_idÙ$3eccdec6-141a-4e0b-9182-198747a26834­parent_run_idÀ¦run_idÙ$3eccdec6-141a-4e0b-9182-198747a26834ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙHProvide two metrics supported by LangChain's built in evaluation module.§context•‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÙ®LangChain's built-in evaluation module supports metrics such as accuracy and latency. These metrics help assess the performance and effectiveness of LLM-powered applications.¨query_id¤Q060ªfocus_kind¶chain_execution_result‹¢idÙ@7d652591b38488fe89c14083201c3ac2e228ba14b02c1307a1cf3553431ed6a3¢tsËAÚó"øZ)¨trace_id¤Q061­parent_run_idÀ¦run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?¨query_id¤Q061§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q061ªfocus_kind¯chain_execution‹¢idÙ@38df0087f325effeb2c7b7bc4973a2a3731b63d2f406ff67e5771f30b27a7247¢tsËAÚó"øbw¨trace_id¤Q061­parent_run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699a¦run_idÙ$2ab49d24-bded-4a8a-bd62-2aeeca29c523ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context¦answer ¨query_id¤Q061¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q061®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:892eb4b3-867e-d291-8b78-5bf031f7abdcªfocus_kind¯chain_execution‰¢idÙ@dc983d7ec4316ae181205c5a1aa0c243f13a1abf78ff4d99d9819ff82c795df4¢tsËAÚó#
ğ²¨trace_idÙ$2ab49d24-bded-4a8a-bd62-2aeeca29c523­parent_run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699a¦run_idÙ$2ab49d24-bded-4a8a-bd62-2aeeca29c523ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q061ªfocus_kind¶chain_execution_result‹¢idÙ@abb66b58183d2ca88d58a239dcebe473d7904b0f92c18ad6728e3255cfd0468b¢tsËAÚó#
÷+¨trace_id¤Q061­parent_run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699a¦run_idÙ$2a31e622-91ba-443f-bde4-87a36e60dcbdªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q061¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q061®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8b8d35a2-3f54-245f-55f4-6e70df7e3e5fªfocus_kind¯chain_execution‹¢idÙ@d8f57edbf6532397a7082917268193cb8f53c652b8442c3a4c4f01e969d63b4e¢tsËAÚó#
ûã¨trace_id¤Q061­parent_run_idÙ$2a31e622-91ba-443f-bde4-87a36e60dcbd¦run_idÙ$41ff9bb1-2266-4932-bc4a-7cea6a7d0b95ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§contextÚÃ# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.

This means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloading, you can use the `.pipe` method instead. This is equivalent to the `|` operator.

```python
chain = runnable1.pipe(runnable2)
```

### Coercion

LCEL applies automatic type coercion to make it easier to compose chains.

If you do not understand the type coercion, you can always use the `RunnableSequence` and `RunnableParallel` classes directly.

This will make the code more verbose, but it will also make it more explicit.

#### Dictionary to RunnableParallel

Inside an LCEL expression, a dictionary is automatically converted to a `RunnableParallel`.

For example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q061®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8b8d35a2-3f54-245f-55f4-6e70df7e3e5f­checkpoint_nsÙ-generate:8b8d35a2-3f54-245f-55f4-6e70df7e3e5f¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3bf603ca697857c1ebc5c6a7df26db581e79bc4dd220c65daca6b6a5d5c9d7b7¢tsËAÚó#¤¨trace_idÙ$41ff9bb1-2266-4932-bc4a-7cea6a7d0b95­parent_run_idÙ$2a31e622-91ba-443f-bde4-87a36e60dcbd¦run_idÙ$41ff9bb1-2266-4932-bc4a-7cea6a7d0b95ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚĞmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which LangChain concept allows combining multiple Runnables with the `|` operator? \nContext: # LangChain Expression Language (LCEL)\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n:::\n\nThe **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.\n\nThis means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n```python\nchain = runnable1 | runnable2\n```\n\nis Equivalent to:\n\n```python\nchain = RunnableSequence([runnable1, runnable2])\n```\n\n### The `.pipe` method\n\nIf you have moral qualms with operator overloading, you can use the `.pipe` method instead. This is equivalent to the `|` operator.\n\n```python\nchain = runnable1.pipe(runnable2)\n```\n\n### Coercion\n\nLCEL applies automatic type coercion to make it easier to compose chains.\n\nIf you do not understand the type coercion, you can always use the `RunnableSequence` and `RunnableParallel` classes directly.\n\nThis will make the code more verbose, but it will also make it more explicit.\n\n#### Dictionary to RunnableParallel\n\nInside an LCEL expression, a dictionary is automatically converted to a `RunnableParallel`.\n\nFor example, the following code:\n\n```python\nmapping = {\n    "key1": runnable1,\n    "key2": runnable2,\n}\n\nchain = mapping | runnable3\n```\n\nIt gets automatically converted to the following:\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@d3dcc9f96a22b607c22f6f3f1c0130039b01490d4aabae84139471a4ce3d8e0e¢tsËAÚó#Z¨focus_msÍÙ§payload‚¤role©assistant§contentÚ>The LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. Runnables created using LCEL are often referred to as "chains."ªfocus_kind¬exec_latency¨query_id¤Q061‰¢idÙ@5eaac55920a67a423451c09f3829dc8158f7a1032ea3f3e75a5f8a09fef6eb6d¢tsËAÚó#ZŸ¦¨trace_idÙ$2a31e622-91ba-443f-bde4-87a36e60dcbd­parent_run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699a¦run_idÙ$2a31e622-91ba-443f-bde4-87a36e60dcbdªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ>The LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. Runnables created using LCEL are often referred to as "chains."¨query_id¤Q061ªfocus_kind¶chain_execution_result‰¢idÙ@b470afe214b71266ea71e288e37767bad6610ac696f23f2c55656e5145e13895¢tsËAÚó#Z©e¨trace_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699a­parent_run_idÀ¦run_idÙ$850dc5a1-84fd-4cdc-8998-c2399f60699aªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙRWhich LangChain concept allows combining multiple Runnables with the `|` operator?§context•‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË```python
chain = runnable1 | runnable2
```

is Equivalent to:

```python
chain = RunnableSequence([runnable1, runnable2])
```

### The `.pipe` method

If you have moral qualms with operator overloadi...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚ>The LangChain concept that allows combining multiple Runnables with the `|` operator is the LangChain Expression Language (LCEL). This approach enables the creation of chains by describing what should happen rather than how, optimizing runtime execution. Runnables created using LCEL are often referred to as "chains."¨query_id¤Q061ªfocus_kind¶chain_execution_result‹¢idÙ@7269d8c635362d10aa41155cec73d6a0d61d7ab739e4f5eb9316639be0e3b2b4¢tsËAÚó#Z±Ñ¨trace_id¤Q062­parent_run_idÀ¦run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.¨query_id¤Q062§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q062ªfocus_kind¯chain_execution‹¢idÙ@59ab5f61fadaef086ec3868a61116e62cffb59cf36398c1169b25b36e07e2c5c¢tsËAÚó#Z¼Œ¨trace_id¤Q062­parent_run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7¦run_idÙ$e40ec66a-0f0a-450f-8068-ca998b64d141ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context¦answer ¨query_id¤Q062¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q062®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:cfb933fe-c3b5-13aa-dc7a-e0729dc333d1ªfocus_kind¯chain_execution‰¢idÙ@6f17857fef6665020fe0e07b556bf8114ecbcaddf1b2e4da0bdb20b9a383840a¢tsËAÚó#f5Å¨trace_idÙ$e40ec66a-0f0a-450f-8068-ca998b64d141­parent_run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7¦run_idÙ$e40ec66a-0f0a-450f-8068-ca998b64d141ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q062ªfocus_kind¶chain_execution_result‹¢idÙ@a35ecf3d9bbe9509d1d9af009bd51c64b3688c94673e6f203aaf9925616d78bc¢tsËAÚó#fC¨trace_id¤Q062­parent_run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7¦run_idÙ$1198250a-978f-4e09-93aa-1c287afd2b13ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q062¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q062®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:91a53c8f-bdb4-f852-e729-c36d1e4b51deªfocus_kind¯chain_execution‹¢idÙ@cb6dcb465638e838e3a6ac5341070a57c18bf250efd7ae1d81b5e8438279095c¢tsËAÚó#fKÂ¨trace_id¤Q062­parent_run_idÙ$1198250a-978f-4e09-93aa-1c287afd2b13¦run_idÙ$eae6d6fc-3b44-4885-8490-84f864f897f2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§contextÚİ# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may need to stream **custom data** that goes beyond the information provided by the pipeline or workflow structure. This custom information is injected within a specific step in the workflow, whether that step is a tool or a LangGraph node. For example, you could stream updates about what a tool is doing in real-time or the progress through a LangGraph node. This granular data, which is emitted directly from within the step, provides more detailed insights into the execution of the workflow and is especially useful in complex processes where more visibility is needed.

## Streaming APIs

In this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM applications

In applications involving LLMs, several types of data can be streamed to improve user experience by reducing perceived latency and increasing transparency. These include:

### 1. Streaming LLM outputs

The most common and critical data to stream is the output generated by the LLM itself. LLMs often take time to generate full responses, and by streaming the output in real-time, users can see partial results as they are produced. This provides immediate feedback and helps reduce the wait time for users.

### 2. Streaming pipeline or workflow progress

Beyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

Beyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

- **In LangGraph Workflows:**
With [LangGraph](/docs/concepts/architecture#langgraph), workflows are composed of nodes and edges that represent various steps. Streaming here involves tracking changes to the **graph state** as individual **nodes** request updates. This allows for more granular monitoring of which node in the workflow is currently active, giving real-time updates about the status of the workflow as it progresses through different stages.

```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/) is an extremely common use case. 
Providers support different approaches for this, including [JSON mode or tool calling](https://platform.openai.com/docs/guides/structured-outputs), with different APIs.
LangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to produce structured outputs using the `with_structured_output()` method:

```python
# Define schema
schema = ...
# Bind schema to model
model_with_structure = model.with_structured_output(schema)
```

### Example: retrievers¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q062®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:91a53c8f-bdb4-f852-e729-c36d1e4b51de­checkpoint_nsÙ-generate:91a53c8f-bdb4-f852-e729-c36d1e4b51de¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@6704224b5a2e12edb91379759d8345caac45aa1a76825aeb029acff4d3c6a0e5¢tsËAÚó#fTT¨trace_idÙ$eae6d6fc-3b44-4885-8490-84f864f897f2­parent_run_idÙ$1198250a-978f-4e09-93aa-1c287afd2b13¦run_idÙ$eae6d6fc-3b44-4885-8490-84f864f897f2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how to set up tool streaming so that tool results are incrementally passed back to the model. \nContext: # Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\nIn some cases, you may need to stream **custom data** that goes beyond the information provided by the pipeline or workflow structure. This custom information is injected within a specific step in the workflow, whether that step is a tool or a LangGraph node. For example, you could stream updates about what a tool is doing in real-time or the progress through a LangGraph node. This granular data, which is emitted directly from within the step, provides more detailed insights into the execution of the workflow and is especially useful in complex processes where more visibility is needed.\n\n## Streaming APIs\n\nIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.\n\n## What to stream in LLM applications\n\nIn applications involving LLMs, several types of data can be streamed to improve user experience by reducing perceived latency and increasing transparency. These include:\n\n### 1. Streaming LLM outputs\n\nThe most common and critical data to stream is the output generated by the LLM itself. LLMs often take time to generate full responses, and by streaming the output in real-time, users can see partial results as they are produced. This provides immediate feedback and helps reduce the wait time for users.\n\n### 2. Streaming pipeline or workflow progress\n\nBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:\n\nBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:\n\n- **In LangGraph Workflows:**\nWith [LangGraph](/docs/concepts/architecture#langgraph), workflows are composed of nodes and edges that represent various steps. Streaming here involves tracking changes to the **graph state** as individual **nodes** request updates. This allows for more granular monitoring of which node in the workflow is currently active, giving real-time updates about the status of the workflow as it progresses through different stages.\n\n```python\n# Tool creation\ntools = [my_tool]\n# Tool binding\nmodel_with_tools = model.bind_tools(tools)\n```\n\nSimilarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/) is an extremely common use case. \nProviders support different approaches for this, including [JSON mode or tool calling](https://platform.openai.com/docs/guides/structured-outputs), with different APIs.\nLangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to produce structured outputs using the `with_structured_output()` method:\n\n```python\n# Define schema\nschema = ...\n# Bind schema to model\nmodel_with_structure = model.with_structured_output(schema)\n```\n\n### Example: retrievers \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4801632b2c669b92529d96dc72758a06338fdd47b4f0409b4808258dd2a59376¢tsËAÚó#»A1¨focus_msÍ.§payload‚¤role©assistant§contentÚ™To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your application is designed to handle and display these incremental outputs to enhance user experience.ªfocus_kind¬exec_latency¨query_id¤Q062‰¢idÙ@5da3f510e61dda8c791dbf91c4defa18067e6a108b7a2dcb5810552f001948e3¢tsËAÚó#»Mf¨trace_idÙ$1198250a-978f-4e09-93aa-1c287afd2b13­parent_run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7¦run_idÙ$1198250a-978f-4e09-93aa-1c287afd2b13ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ™To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your application is designed to handle and display these incremental outputs to enhance user experience.¨query_id¤Q062ªfocus_kind¶chain_execution_result‰¢idÙ@6ff2500faba6721eeb060f39839db1ab90798a2ef98e802f1f4cb679ee955338¢tsËAÚó#»Rq¨trace_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7­parent_run_idÀ¦run_idÙ$d1cae0b1-1f48-4606-ab2b-0c3bbdf182d7ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙeExplain how to set up tool streaming so that tool results are incrementally passed back to the model.§context•‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

In some cases, you may...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËIn this guide, we'll discuss streaming in LLM applications and explore how LangChain's streaming APIs facilitate real-time output from various components in your application.

## What to stream in LLM...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍBeyond just streaming LLM output, itâ€™s useful to stream progress through more complex workflows or pipelines, giving users a sense of how the application is progressing overall. This could include:

-...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

Similarly, getting models to produce [structured outputs](/docs/concepts/structured_outputs/)...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÚ™To set up tool streaming for incrementally passing results back to the model, first create your tools and bind them to the model using the `model.bind_tools(tools)` method. This allows the model to utilize the tools during execution, enabling it to receive intermediate results. Additionally, ensure that your application is designed to handle and display these incremental outputs to enhance user experience.¨query_id¤Q062ªfocus_kind¶chain_execution_result‹¢idÙ@d97fa7ae7088221ee0137366427a75c9b4703cfb2850da7415f2911285235693¢tsËAÚó#»XO¨trace_id¤Q063­parent_run_idÀ¦run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?¨query_id¤Q063§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q063ªfocus_kind¯chain_execution‹¢idÙ@15515d65db9b4aa82fa1051c519ffc841d396244cf3a9f8294113c0116736625¢tsËAÚó#»`Ç¨trace_id¤Q063­parent_run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5¦run_idÙ$25e1da5d-4e13-41c8-9cf5-24e669c7230aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context¦answer ¨query_id¤Q063¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q063®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:4f1c8d22-7b60-6ad5-18ca-1d77b57bf040ªfocus_kind¯chain_execution‰¢idÙ@02299e93917b0fbc949a959816c846a1ee852bbad45f6b9d193bc814b06b3235¢tsËAÚó#Ğ‚Ø¨trace_idÙ$25e1da5d-4e13-41c8-9cf5-24e669c7230a­parent_run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5¦run_idÙ$25e1da5d-4e13-41c8-9cf5-24e669c7230aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q063ªfocus_kind¶chain_execution_result‹¢idÙ@4bd351cf3cda7a809067ae400ae177b27481f4b790fcef50bf3ba369d5e646ee¢tsËAÚó#Ğ”Ş¨trace_id¤Q063­parent_run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5¦run_idÙ$ca9a7c6e-dc9e-40a4-b9ca-38bacb6a3f1fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q063¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q063®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:0b3daeda-f9c3-aa14-a14e-dfe61bcf37b9ªfocus_kind¯chain_execution‹¢idÙ@0cd91798784966993699c488658781b5bb81c1b6c0e673a06046986dd4d39206¢tsËAÚó#Ğ¼¨trace_id¤Q063­parent_run_idÙ$ca9a7c6e-dc9e-40a4-b9ca-38bacb6a3f1f¦run_idÙ$2741ee25-a4ac-4712-9572-3b64209cbd97ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§contextÚÈ## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q063®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:0b3daeda-f9c3-aa14-a14e-dfe61bcf37b9­checkpoint_nsÙ-generate:0b3daeda-f9c3-aa14-a14e-dfe61bcf37b9¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@fa41a23a356d7efb722c7c736f3c63034e82aa4546ab6ebb68964939a225a7f8¢tsËAÚó#ĞË¼¨trace_idÙ$2741ee25-a4ac-4712-9572-3b64209cbd97­parent_run_idÙ$ca9a7c6e-dc9e-40a4-b9ca-38bacb6a3f1f¦run_idÙ$2741ee25-a4ac-4712-9572-3b64209cbd97ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ·messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the benefit of using `RunnableLambda` over subclassing a Runnable? \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span> \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@bf6f22e3481ad6f07eed2cc5802b8e5bafe502ec9349bc3c2b7afc473f44a3f1¢tsËAÚó$]ª&¨focus_msÍ˜§payload‚¤role©assistant§contentÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.ªfocus_kind¬exec_latency¨query_id¤Q063‰¢idÙ@a1c669d0c69091fefb7f294ddf6e25cd6abe0384b90919c0f81be546bcd84a69¢tsËAÚó$]Êâ¨trace_idÙ$ca9a7c6e-dc9e-40a4-b9ca-38bacb6a3f1f­parent_run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5¦run_idÙ$ca9a7c6e-dc9e-40a4-b9ca-38bacb6a3f1fªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.¨query_id¤Q063ªfocus_kind¶chain_execution_result‰¢idÙ@abc0ca6c87fdf1e227392fe9839c67f2cc128376b32d07ce6ecd4dad27963d55¢tsËAÚó$]Ò¨trace_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5­parent_run_idÀ¦run_idÙ$c741c827-39ec-44a6-921e-200428bdd5c5ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙJWhat is the benefit of using `RunnableLambda` over subclassing a Runnable?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚThe benefit of using `RunnableLambda` over subclassing a Runnable is that it simplifies the creation of custom Runnables for straightforward transformations without the complexity and potential errors associated with subclassing. `RunnableLambda` is specifically designed for simple use cases, making it easier to implement and maintain. In contrast, subclassing can be more complex and error-prone.¨query_id¤Q063ªfocus_kind¶chain_execution_result‹¢idÙ@f59f63bf16724073bbc5c8873d664a0ef865be6e843104f6161fe651cc0cd8f4¢tsËAÚó$]×Ğ¨trace_id¤Q064­parent_run_idÀ¦run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?¨query_id¤Q064§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q064ªfocus_kind¯chain_execution‹¢idÙ@39e16e4a65b805225efd5e58b1bf3d4546b3b2b4c9ac5f2d345749d405522b89¢tsËAÚó$]ß¨trace_id¤Q064­parent_run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6¦run_idÙ$c754e2d8-abc3-4955-a041-6a8ad885839dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context¦answer ¨query_id¤Q064¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q064®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:b92c812d-05df-6f9c-61d3-c1d77c334410ªfocus_kind¯chain_execution‰¢idÙ@4c1ce5df267520db35fdc7ebbe91fe73f51838345280b2cbcd0e2f9122aac677¢tsËAÚó$mâ&¨trace_idÙ$c754e2d8-abc3-4955-a041-6a8ad885839d­parent_run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6¦run_idÙ$c754e2d8-abc3-4955-a041-6a8ad885839dªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q064ªfocus_kind¶chain_execution_result‹¢idÙ@72994362468c68849964f24cc9ec85af8f6562a148226dc5edfd8ca6c9eee046¢tsËAÚó$mê-¨trace_id¤Q064­parent_run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6¦run_idÙ$de6b6632-a9e8-4507-ad30-a50861ba2edeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q064¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q064®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:93206774-94c0-51f4-73cb-b1f0bc8b0ec9ªfocus_kind¯chain_execution‹¢idÙ@98ec620cc728464dbb5b8581a3b50468543ca44d4d6c24e0c8276b9caed70023¢tsËAÚó$mïA¨trace_id¤Q064­parent_run_idÙ$de6b6632-a9e8-4507-ad30-a50861ba2ede¦run_idÙ$d8b0c982-17df-4799-bce4-82e7ce3c6111ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§contextÚ@### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: write a custom document loader](/docs/how_to/document_loader_custom)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)
- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)
- [How to: define a custom tool](/docs/how_to/custom_tools)
- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data.
For a high-level tutorial on RAG, check out [this guide](/docs/tutorials/rag/).

- [How to: add chat history](/docs/how_to/qa_chat_history_how_to/)
- [How to: stream](/docs/how_to/qa_streaming/)
- [How to: return sources](/docs/how_to/qa_sources/)
- [How to: return citations](/docs/how_to/qa_citations/)
- [How to: do per-user retrieval](/docs/how_to/qa_per_user/)


### Extraction

Extraction is when you use LLMs to extract structured information from unstructured text.
For a high level tutorial on extraction, check out [this guide](/docs/tutorials/extraction/).

| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a question. | Rewrite the user question with multiple phrasings, retrieve documents for each rewritten question, return the unique documents for all queries.                                                                                                                                        |
| [Decomposition](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb) | When a question can be broken down into smaller subproblems.                                    | Decompose a question into a set of subproblems / questions, which can either be solved sequentially (use the answer from first + retrieval to answer the second) or in parallel (consolidate each answer into final answer).                                                           |

- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semantic search](/docs/tutorials/retrievers): Build a semantic search engine over a PDF with [document loaders](/docs/concepts/document_loaders), [embedding models](/docs/concepts/embedding_models/), and [vector stores](/docs/concepts/vectorstores/).
- [Classification](/docs/tutorials/classification): Classify text into categories or labels using [chat models](/docs/concepts/chat_models) with [structured outputs](/docs/concepts/structured_outputs/).
- [Extraction](/docs/tutorials/extraction): Extract structured data from text and other unstructured media using [chat models](/docs/concepts/chat_models) and [few-shot examples](/docs/concepts/few_shot_prompting/).

Refer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve results](/docs/how_to/sql_prompting)
- [How to: do query validation](/docs/how_to/sql_query_checking)
- [How to: deal with large databases](/docs/how_to/sql_large_db)
- [How to: deal with CSV files](/docs/how_to/sql_csv)

### Q&A over graph databases

You can use an LLM to do question answering over graph databases.
For a high-level tutorial, check out [this guide](/docs/tutorials/graph/).

- [How to: add a semantic layer over the database](/docs/how_to/graph_semantic)
- [How to: construct knowledge graphs](/docs/how_to/graph_constructing)

### Summarization

LLMs can summarize and otherwise distill desired information from text, including
large volumes of text. For a high-level tutorial, check out [this guide](/docs/tutorials/summarization).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q064®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:93206774-94c0-51f4-73cb-b1f0bc8b0ec9­checkpoint_nsÙ-generate:93206774-94c0-51f4-73cb-b1f0bc8b0ec9¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d1a78ebbe59ea0a328dbdf434b5c1d9b7111f445678cedb145b4e2bdbc310c28¢tsËAÚó$mö¨trace_idÙ$d8b0c982-17df-4799-bce4-82e7ce3c6111­parent_run_idÙ$de6b6632-a9e8-4507-ad30-a50861ba2ede¦run_idÙ$d8b0c982-17df-4799-bce4-82e7ce3c6111ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚTmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two documents together explain how to build a streaming question answering chain with citations? \nContext: ### Custom\n\nAll of LangChain components can easily be extended to support your own versions.\n\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: create a custom embeddings class](/docs/how_to/custom_embeddings)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: write a custom document loader](/docs/how_to/document_loader_custom)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n- [How to: create custom callback handlers](/docs/how_to/custom_callbacks)\n- [How to: define a custom tool](/docs/how_to/custom_tools)\n- [How to: dispatch custom callback events](/docs/how_to/callbacks_custom_events)\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\n### Serialization\n- [How to: save and load LangChain objects](/docs/how_to/serialization)\n\n## Use cases\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG\n\nRetrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data.\nFor a high-level tutorial on RAG, check out [this guide](/docs/tutorials/rag/).\n\n- [How to: add chat history](/docs/how_to/qa_chat_history_how_to/)\n- [How to: stream](/docs/how_to/qa_streaming/)\n- [How to: return sources](/docs/how_to/qa_sources/)\n- [How to: return citations](/docs/how_to/qa_citations/)\n- [How to: do per-user retrieval](/docs/how_to/qa_per_user/)\n\n\n### Extraction\n\nExtraction is when you use LLMs to extract structured information from unstructured text.\nFor a high level tutorial on extraction, check out [this guide](/docs/tutorials/extraction/).\n\n| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a question. | Rewrite the user question with multiple phrasings, retrieve documents for each rewritten question, return the unique documents for all queries.                                                                                                                                        |\n| [Decomposition](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb) | When a question can be broken down into smaller subproblems.                                    | Decompose a question into a set of subproblems / questions, which can either be solved sequentially (use the answer from first + retrieval to answer the second) or in parallel (consolidate each answer into final answer).                                                           |\n\n- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).\n- [Semantic search](/docs/tutorials/retrievers): Build a semantic search engine over a PDF with [document loaders](/docs/concepts/document_loaders), [embedding models](/docs/concepts/embedding_models/), and [vector stores](/docs/concepts/vectorstores/).\n- [Classification](/docs/tutorials/classification): Classify text into categories or labels using [chat models](/docs/concepts/chat_models) with [structured outputs](/docs/concepts/structured_outputs/).\n- [Extraction](/docs/tutorials/extraction): Extract structured data from text and other unstructured media using [chat models](/docs/concepts/chat_models) and [few-shot examples](/docs/concepts/few_shot_prompting/).\n\nRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.\n\n## Orchestration\n\n### Q&A over SQL + CSV\n\nYou can use LLMs to do question answering over tabular data.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).\n\n- [How to: use prompting to improve results](/docs/how_to/sql_prompting)\n- [How to: do query validation](/docs/how_to/sql_query_checking)\n- [How to: deal with large databases](/docs/how_to/sql_large_db)\n- [How to: deal with CSV files](/docs/how_to/sql_csv)\n\n### Q&A over graph databases\n\nYou can use an LLM to do question answering over graph databases.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/graph/).\n\n- [How to: add a semantic layer over the database](/docs/how_to/graph_semantic)\n- [How to: construct knowledge graphs](/docs/how_to/graph_constructing)\n\n### Summarization\n\nLLMs can summarize and otherwise distill desired information from text, including\nlarge volumes of text. For a high-level tutorial, check out [this guide](/docs/tutorials/summarization). \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4899bfde8e3f3ae67ab57f8e6b08a1a299348df0b0d189e30c9618bf8a5f8fdc¢tsËAÚó$Á«¨focus_msÍ§payload‚¤role©assistant§contentÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.ªfocus_kind¬exec_latency¨query_id¤Q064‰¢idÙ@4e96cdd7a5f011493b8c166a63f95ea05ee55f19e1c1e4edc92942a4906b4e31¢tsËAÚó$Áğ¨trace_idÙ$de6b6632-a9e8-4507-ad30-a50861ba2ede­parent_run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6¦run_idÙ$de6b6632-a9e8-4507-ad30-a50861ba2edeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.¨query_id¤Q064ªfocus_kind¶chain_execution_result‰¢idÙ@742e20a0a6516599d29eaf6aa50cdaf6a93df0528b2f5c8b88f07cbd026ba109¢tsËAÚó$Á	¨trace_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6­parent_run_idÀ¦run_idÙ$7b6328f0-aa5e-444e-a1f8-db1b4fa8d2c6ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙfWhich two documents together explain how to build a streaming question answering chain with citations?§context•‚´page_content_summaryÙË### Custom

All of LangChain components can easily be extended to support your own versions.

- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: create a custom LL...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### Serialization
- [How to: save and load LangChain objects](/docs/how_to/serialization)

## Use cases

These guides cover use-case specific details.

### Q&A with RAG

Retrieval Augmented Generation...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË| [Multi-query](/docs/how_to/MultiQueryRetriever/)                                                          | When you want to ensure high recall in retrieval by providing multiple phrasings of a ques...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [Chat models and prompts](/docs/tutorials/llm_chain): Build a simple LLM application with [prompt templates](/docs/concepts/prompt_templates) and [chat models](/docs/concepts/chat_models).
- [Semant...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).

- [How to: use prompting to improve re...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚ%The two documents that explain how to build a streaming question answering chain with citations are "How to: stream" and "How to: return citations." These guides provide specific instructions for implementing streaming capabilities and managing citation outputs in a question answering system.¨query_id¤Q064ªfocus_kind¶chain_execution_result‹¢idÙ@24b1cfd4cd9afeb9b5ef342cd25fff037f5e57cca706e2318bea9388cbf6aa22¢tsËAÚó$Á¨trace_id¤Q065­parent_run_idÀ¦run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15efªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?¨query_id¤Q065§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q065ªfocus_kind¯chain_execution‹¢idÙ@2db7bb30057a8a4e0b995acdbf603748f24c840a4cf3e80ac16bba4a63f7925d¢tsËAÚó$Á&æ¨trace_id¤Q065­parent_run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15ef¦run_idÙ$09d5712c-d173-4be7-bb77-f34ceb4783b8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context¦answer ¨query_id¤Q065¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q065®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:8e18ea01-cb97-fb76-3de9-780941c4987eªfocus_kind¯chain_execution‰¢idÙ@0ddfe17086966884fa3f63ce8374d0a1fec9c548429626fd325a71f4c96daa92¢tsËAÚó$Õí¨trace_idÙ$09d5712c-d173-4be7-bb77-f34ceb4783b8­parent_run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15ef¦run_idÙ$09d5712c-d173-4be7-bb77-f34ceb4783b8ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¨query_id¤Q065ªfocus_kind¶chain_execution_result‹¢idÙ@f365f87a9c96bc688b6727a424e8709e10f8b7c1b2a4e59e42caac4c1f141dc6¢tsËAÚó$Õˆ¨trace_id¤Q065­parent_run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15ef¦run_idÙ$ed0b7919-0646-4ff3-aa95-3cc16c10fc2cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answer ¨query_id¤Q065¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q065®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1fc0fda5-2aad-eb69-7da5-783f7a48879eªfocus_kind¯chain_execution‹¢idÙ@8fdcc7eb6a7a481a25fd195f35ebb26c4b334a3ce573c3f0d88520674ffdd05b¢tsËAÚó$Õ¹¨trace_id¤Q065­parent_run_idÙ$ed0b7919-0646-4ff3-aa95-3cc16c10fc2c¦run_idÙ$1faddb20-24aa-458e-9b5a-f20557bb9a9eªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ7How do you measure BLEU score in LangChain evaluations?§contextÚ»:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Each embedding is essentially a set of coordinates, often in a high-dimensional space. 
In this space, the position of each point (embedding) reflects the meaning of its corresponding text.
Just as similar words might be close to each other in a thesaurus, similar concepts end up close to each other in this embedding space. 
This allows for intuitive comparisons between different pieces of text.
By reducing text to these numerical representations, we can use simple mathematical operations to quickly measure how alike two pieces of text are, regardless of their original length or structure.
Some common similarity metrics include:

## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing the model's responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.
This process is vital for building reliable applications.

![](/img/langsmith_evaluate.png)

[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:

- It makes it easier to create and curate datasets via its tracing and annotation features
- It provides an evaluation framework that helps you define metrics and run your app against your dataset
- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code

To learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).

### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.

To learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).

### Tracing
<span data-heading-keywords="trace,tracing"></span>

Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)
- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)

You can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).

:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.

:::

## Observability and evaluation

The pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. 
Developers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. 
High quality tracing and evaluations can help you rapidly answer these types of questions with confidence.
[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.
See our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.

:::info[Further reading]¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q065®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1fc0fda5-2aad-eb69-7da5-783f7a48879e­checkpoint_nsÙ-generate:1fc0fda5-2aad-eb69-7da5-783f7a48879e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@103a1a6c41f724f81ec54d593aca348be1ec8865a7bf4c8becbb418b7c9889bf¢tsËAÚó$Õ ¨trace_idÙ$1faddb20-24aa-458e-9b5a-f20557bb9a9e­parent_run_idÙ$ed0b7919-0646-4ff3-aa95-3cc16c10fc2c¦run_idÙ$1faddb20-24aa-458e-9b5a-f20557bb9a9eªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¡messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you measure BLEU score in LangChain evaluations? \nContext: :::\n\n### Integrations\n\nLangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.\n\n## Measure similarity\n\nEach embedding is essentially a set of coordinates, often in a high-dimensional space. \nIn this space, the position of each point (embedding) reflects the meaning of its corresponding text.\nJust as similar words might be close to each other in a thesaurus, similar concepts end up close to each other in this embedding space. \nThis allows for intuitive comparisons between different pieces of text.\nBy reducing text to these numerical representations, we can use simple mathematical operations to quickly measure how alike two pieces of text are, regardless of their original length or structure.\nSome common similarity metrics include:\n\n## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n# Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.\nIt involves testing the model\'s responses against a set of predefined criteria or benchmarks to ensure it meets the desired quality standards and fulfills the intended purpose.\nThis process is vital for building reliable applications.\n\n![](/img/langsmith_evaluate.png)\n\n[LangSmith](https://docs.smith.langchain.com/) helps with this process in a few ways:\n\n- It makes it easier to create and curate datasets via its tracing and annotation features\n- It provides an evaluation framework that helps you define metrics and run your app against your dataset\n- It allows you to track results over time and automatically run your evaluators on a schedule or as part of CI/Code\n\nTo learn more, check out [this LangSmith guide](https://docs.smith.langchain.com/concepts/evaluation).\n\n### Evaluation\n<span data-heading-keywords="evaluation,evaluate"></span>\n\nEvaluating performance is a vital part of building LLM-powered applications.\nLangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.\n\nTo learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).\n\n### Tracing\n<span data-heading-keywords="trace,tracing"></span>\n\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\n- [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n- [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n\nYou can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing).\n\n:::info[Further reading]\n\nHave a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build complex applications.\n\n:::\n\n## Observability and evaluation\n\nThe pace of AI application development is often rate-limited by high-quality evaluations because there is a paradox of choice. \nDevelopers often wonder how to engineer their prompt or which LLM best balances accuracy, latency, and cost. \nHigh quality tracing and evaluations can help you rapidly answer these types of questions with confidence.\n[LangSmith](https://docs.smith.langchain.com/) is our platform that supports observability and evaluation for AI applications.\nSee our conceptual guides on [evaluations](https://docs.smith.langchain.com/concepts/evaluation) and [tracing](https://docs.smith.langchain.com/concepts/tracing) for more details.\n\n:::info[Further reading] \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4e714f82e2cf6769056880626a0cb8332dc32566a7ff93a491d77d7db8962d3e¢tsËAÚó%N®æ¨focus_msÍk§payload‚¤role©assistant§contentÚThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know how to measure BLEU score in LangChain evaluations.ªfocus_kind¬exec_latency¨query_id¤Q065‰¢idÙ@622aacdfff0132b1f730ccfa9a20b3ff24bbda5d29e7e96c2a48d56269a8e81c¢tsËAÚó%N·¨trace_idÙ$ed0b7919-0646-4ff3-aa95-3cc16c10fc2c­parent_run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15ef¦run_idÙ$ed0b7919-0646-4ff3-aa95-3cc16c10fc2cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know how to measure BLEU score in LangChain evaluations.¨query_id¤Q065ªfocus_kind¶chain_execution_result‰¢idÙ@20b0beaddd6c21215be4bfd4fcacb6d8537cf3c4ce123f745cc27bd65e4279b6¢tsËAÚó%N¾¨trace_idÙ$e115a93c-ebc1-4b68-befa-e416edea15ef­parent_run_idÀ¦run_idÙ$e115a93c-ebc1-4b68-befa-e416edea15efªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ7How do you measure BLEU score in LangChain evaluations?§context•‚´page_content_summaryÙË:::

### Integrations

LangChain offers many embedding model integrations which you can find [on the embedding models](/docs/integrations/text_embedding/) integrations page.

## Measure similarity

Ea...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË# Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluation is the process of assessing the performance and effectiveness of your LLM-powered applications.
It involves testing t...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/evaluation.mdx‚´page_content_summaryÙË### Evaluation
<span data-heading-keywords="evaluation,evaluate"></span>

Evaluating performance is a vital part of building LLM-powered applications.
LangSmith helps with every step of the process fr...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË:::info[Further reading]

Have a look at our free course, [Introduction to LangGraph](https://academy.langchain.com/courses/intro-to-langgraph), to learn more about how to use LangGraph to build compl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx¦answerÚThe provided context does not specify how to measure the BLEU score in LangChain evaluations. It discusses evaluation processes and tools like LangSmith but does not mention BLEU specifically. Therefore, I don't know how to measure BLEU score in LangChain evaluations.¨query_id¤Q065ªfocus_kind¶chain_execution_result‹¢idÙ@9a43f4e31e663a74450777452ce8b665abaa43f3f1cb42a62d4a28479fd3d31f¢tsËAÚó%NÆ¬¨trace_id¤Q066­parent_run_idÀ¦run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?¨query_id¤Q066§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q066ªfocus_kind¯chain_execution‹¢idÙ@28760b7cb562773044c5d63264ed04987db420a5bc718590967a90e52d02897c¢tsËAÚó%NĞx¨trace_id¤Q066­parent_run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21d¦run_idÙ$42422ac4-8e86-40ae-95c7-7c94e56fa18bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context¦answer ¨query_id¤Q066¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q066®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:81c84e0a-5626-4dff-2c33-4b6a068be61aªfocus_kind¯chain_execution‰¢idÙ@7aedfd5a0efbfc22719491ee0022de28671e2fc3562e0800732abf3c2978df5b¢tsËAÚó%e5U¨trace_idÙ$42422ac4-8e86-40ae-95c7-7c94e56fa18b­parent_run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21d¦run_idÙ$42422ac4-8e86-40ae-95c7-7c94e56fa18bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q066ªfocus_kind¶chain_execution_result‹¢idÙ@edef6f844fc6e5ab8d1ed0d5e91f5563fe1f3dcb2f259bf959e8d1d0cfb537c6¢tsËAÚó%e>2¨trace_id¤Q066­parent_run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21d¦run_idÙ$3d0ada2e-774a-40fc-93f0-ab8b489a1ba9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q066¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q066®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2e9ad18c-b64a-2315-e593-54a0957b9756ªfocus_kind¯chain_execution‹¢idÙ@f9695bb73ea9304d616ead8d3ed59446fc6ec388d3c7d13ea3884c0d2585c632¢tsËAÚó%eBê¨trace_id¤Q066­parent_run_idÙ$3d0ada2e-774a-40fc-93f0-ab8b489a1ba9¦run_idÙ$a6a2d056-f2aa-435e-806e-f47bafb143d0ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§contextÚïThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often involves a combination of two patterns of alternating messages:

1. The **user** and the **assistant** representing a back-and-forth conversation.
2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.

## Managing chat history

Since chat models have a maximum limit on input size, it's important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.
    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.
- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.

:::tip
Understanding correct conversation structure is essential for being able to properly implement
[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.
:::

## Related resources

## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q066®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2e9ad18c-b64a-2315-e593-54a0957b9756­checkpoint_nsÙ-generate:2e9ad18c-b64a-2315-e593-54a0957b9756¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@fd4698a56f34f32cece16040efb778a39df367a7c52dd2dcd61af46c0115b385¢tsËAÚó%eHù¨trace_idÙ$a6a2d056-f2aa-435e-806e-f47bafb143d0­parent_run_idÙ$3d0ada2e-774a-40fc-93f0-ab8b489a1ba9¦run_idÙ$a6a2d056-f2aa-435e-806e-f47bafb143d0ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚËmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does the `ConversationBufferWindowMemory` keep in memory? \nContext: The **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.\n\nA full conversation often involves a combination of two patterns of alternating messages:\n\n1. The **user** and the **assistant** representing a back-and-forth conversation.\n2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.\n\n## Managing chat history\n\nSince chat models have a maximum limit on input size, it\'s important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n- The conversation should follow one of these structures:\n    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.\n    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.\n- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.\n\n:::tip\nUnderstanding correct conversation structure is essential for being able to properly implement\n[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.\n:::\n\n## Related resources\n\n## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\n### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@843ecda9acdb344644a5e92b5a87af4ca1346dacc0e1a3e202e75f12c5f8ca23¢tsËAÚó%¿¦‡¨focus_msÍƒ§payload‚¤role©assistant§contentÚcThe `ConversationBufferWindowMemory` keeps a record of the conversation history, including messages exchanged between the user and the assistant. It manages this history to ensure the conversation structure is preserved while adhering to the model's context window limitations. This allows the assistant to maintain context and continuity in the dialogue.ªfocus_kind¬exec_latency¨query_id¤Q066‰¢idÙ@1d9fdab24c0a8d4044ce49fc1516fc5e36e9ebac5889287ea84769bebbbc0aa2¢tsËAÚó%¿½¨trace_idÙ$3d0ada2e-774a-40fc-93f0-ab8b489a1ba9­parent_run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21d¦run_idÙ$3d0ada2e-774a-40fc-93f0-ab8b489a1ba9ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚcThe `ConversationBufferWindowMemory` keeps a record of the conversation history, including messages exchanged between the user and the assistant. It manages this history to ensure the conversation structure is preserved while adhering to the model's context window limitations. This allows the assistant to maintain context and continuity in the dialogue.¨query_id¤Q066ªfocus_kind¶chain_execution_result‰¢idÙ@a3cbc1590c4992d84bd63d89882559fc3e0a569517d8c4fdf63a7dec810bdc4b¢tsËAÚó%¿È›¨trace_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21d­parent_run_idÀ¦run_idÙ$efa3c128-ec57-43b2-b014-1783bb38a21dªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>What does the `ConversationBufferWindowMemory` keep in memory?§context•‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚcThe `ConversationBufferWindowMemory` keeps a record of the conversation history, including messages exchanged between the user and the assistant. It manages this history to ensure the conversation structure is preserved while adhering to the model's context window limitations. This allows the assistant to maintain context and continuity in the dialogue.¨query_id¤Q066ªfocus_kind¶chain_execution_result‹¢idÙ@f5d6161bd16238daee45228ce193e4cab79ec1dde5199c0b2f86cccb0f919c83¢tsËAÚó%¿ÛM¨trace_id¤Q067­parent_run_idÀ¦run_idÙ$049241db-394d-4073-9552-4f7209f807e8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.¨query_id¤Q067§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q067ªfocus_kind¯chain_execution‹¢idÙ@0948dd9a3f13bf9aecfe48156014ea121f2220a8e0188d6be0635ec0beccd20f¢tsËAÚó%¿òc¨trace_id¤Q067­parent_run_idÙ$049241db-394d-4073-9552-4f7209f807e8¦run_idÙ$c17a6e73-2be3-43ee-982f-02070ad44818ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context¦answer ¨query_id¤Q067¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q067®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3af6ab41-d7fd-3adf-df39-a87526168a44ªfocus_kind¯chain_execution‰¢idÙ@92808f4569a381f0fb17c83f186ad4a72432f268e67d593d8a12ba5458fd13a9¢tsËAÚó%ÌEI¨trace_idÙ$c17a6e73-2be3-43ee-982f-02070ad44818­parent_run_idÙ$049241db-394d-4073-9552-4f7209f807e8¦run_idÙ$c17a6e73-2be3-43ee-982f-02070ad44818ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¨query_id¤Q067ªfocus_kind¶chain_execution_result‹¢idÙ@04de2229cb105aa370ec296c45c78919c467075ce8b9293edb1e6bad550ab7d1¢tsËAÚó%ÌV\¨trace_id¤Q067­parent_run_idÙ$049241db-394d-4073-9552-4f7209f807e8¦run_idÙ$bfce353e-ccff-469c-a60e-32d07257d832ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¦answer ¨query_id¤Q067¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q067®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2576dc14-a31a-52bd-ba1a-f299fcc907c1ªfocus_kind¯chain_execution‹¢idÙ@6897348589838e64b102c7d5ea9b4275742b35c5d2b04d5f352f507d3dc15aa3¢tsËAÚó%Ìd™¨trace_id¤Q067­parent_run_idÙ$bfce353e-ccff-469c-a60e-32d07257d832¦run_idÙ$d33c0505-2f63-47fd-ab18-609064bf472bªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§contextÚì# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.

## Integrations

You can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).

## Interface

Documents loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).

Each DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.

Here's a simple example:

```python
from langchain_community.document_loaders.csv_loader import CSVLoader

## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
based service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from
digital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.

This [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.

### Prerequisite

# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attributeâ€“value pairs and arrays (or other serializable values).

[JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.

LangChain implements a [JSONLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.json_loader.JSONLoader.html) 
to convert JSON and JSONL data into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) 
objects. It uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_(programming_language)) to parse the JSON files, allowing for the extraction of specific fields into the content 
and metadata of the LangChain Document.

### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don't have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.

```python
%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence

from langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader

file_path = "<filepath>"
endpoint = "<endpoint>"
key = "<key>"
loader = AzureAIDocumentIntelligenceLoader(
    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"
)

documents = loader.load()
```

It uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load JSON and JSONL data into the content of a LangChain `Document`;
- How to load JSON and JSONL data into metadata associated with a `Document`.


```python
#!pip install jq
```


```python
from langchain_community.document_loaders import JSONLoader
```


```python
import json
from pathlib import Path
from pprint import pprint


file_path='./example_data/facebook_chat.json'
data = json.loads(Path(file_path).read_text())
```¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q067®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2576dc14-a31a-52bd-ba1a-f299fcc907c1­checkpoint_nsÙ-generate:2576dc14-a31a-52bd-ba1a-f299fcc907c1¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d47abada0a5e8752d5694c99bc82303c939ef243f0691a248eac598eb02affa6¢tsËAÚó%ÌxÄ¨trace_idÙ$d33c0505-2f63-47fd-ab18-609064bf472b­parent_run_idÙ$bfce353e-ccff-469c-a60e-32d07257d832¦run_idÙ$d33c0505-2f63-47fd-ab18-609064bf472bªevent_type¬chain_output¬event_source¥chain§payload§outputsÚêmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name a loader designed specifically for PDF files in LangChain. \nContext: # Document loaders\n<span data-heading-keywords="document loader,document loaders"></span>\n\n:::info[Prerequisites]\n\n* [Document loaders API reference](/docs/how_to/#document-loaders)\n:::\n\nDocument loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.\n\n## Integrations\n\nYou can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).\n\n## Interface\n\nDocuments loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).\n\nEach DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.\n\nHere\'s a simple example:\n\n```python\nfrom langchain_community.document_loaders.csv_loader import CSVLoader\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning \nbased service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from\ndigital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.\n\nThis [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.\n\n### Prerequisite\n\n# How to load JSON\n\n[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attributeâ€“value pairs and arrays (or other serializable values).\n\n[JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.\n\nLangChain implements a [JSONLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.json_loader.JSONLoader.html) \nto convert JSON and JSONL data into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) \nobjects. It uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_(programming_language)) to parse the JSON files, allowing for the extraction of specific fields into the content \nand metadata of the LangChain Document.\n\n### Prerequisite\n\nAn Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don\'t have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.\n\n```python\n%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence\n\nfrom langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader\n\nfile_path = "<filepath>"\nendpoint = "<endpoint>"\nkey = "<key>"\nloader = AzureAIDocumentIntelligenceLoader(\n    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"\n)\n\ndocuments = loader.load()\n```\n\nIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.\n\nHere we will demonstrate: \n\n- How to load JSON and JSONL data into the content of a LangChain `Document`;\n- How to load JSON and JSONL data into metadata associated with a `Document`.\n\n\n```python\n#!pip install jq\n```\n\n\n```python\nfrom langchain_community.document_loaders import JSONLoader\n```\n\n\n```python\nimport json\nfrom pathlib import Path\nfrom pprint import pprint\n\n\nfile_path=\'./example_data/facebook_chat.json\'\ndata = json.loads(Path(file_path).read_text())\n``` \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@08b5e6597331e7cec07a3e3cdb6a4472d9caf0563ac973774c508f19622bca28¢tsËAÚó&"y¨focus_msÍ§payload‚¤role©assistant§contentÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.ªfocus_kind¬exec_latency¨query_id¤Q067‰¢idÙ@0a1f9d0ab5baa9ac0882f6455d78f4c96a878a3268f53e4f9115173e430024e5¢tsËAÚó&3Ó¨trace_idÙ$bfce353e-ccff-469c-a60e-32d07257d832­parent_run_idÙ$049241db-394d-4073-9552-4f7209f807e8¦run_idÙ$bfce353e-ccff-469c-a60e-32d07257d832ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.¨query_id¤Q067ªfocus_kind¶chain_execution_result‰¢idÙ@d6c0c3f6bddac7e2d2ada69b4eeb1ed74e8122c12b240825cdf8539154780ba9¢tsËAÚó&>\¨trace_idÙ$049241db-394d-4073-9552-4f7209f807e8­parent_run_idÀ¦run_idÙ$049241db-394d-4073-9552-4f7209f807e8ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ?Name a loader designed specifically for PDF files in LangChain.§context•‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load JSON

[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and trans...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙËIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.

Here we will demonstrate: 

- How to load...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_json.mdx¦answerÚThe loader designed specifically for PDF files in LangChain is the `AzureAIDocumentIntelligenceLoader`. This loader utilizes Azure's Document Intelligence service to extract text and structure from PDF documents. It can return content in various formats, including markdown.¨query_id¤Q067ªfocus_kind¶chain_execution_result‹¢idÙ@7873ef9642d60c20da6a9cabbd78e86e173a09b81f6dded3b6a4dd19250b84ef¢tsËAÚó&G,¨trace_id¤Q068­parent_run_idÀ¦run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?¨query_id¤Q068§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q068ªfocus_kind¯chain_execution‹¢idÙ@5c02164fd55d92b1e486b907a19a00c79f2289fd81174b863fcb1256b7966229¢tsËAÚó&O#¨trace_id¤Q068­parent_run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31¦run_idÙ$93b986d0-78a5-4291-b93d-32db8e6aa0afªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context¦answer ¨query_id¤Q068¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q068®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:afab9ef6-6896-f2fd-4ef5-7c7aafbfd88dªfocus_kind¯chain_execution‰¢idÙ@f5b44d64867eff87f43dd73771393f6b11c2d829d6754aee1b5eb9688151da99¢tsËAÚó&"i¨trace_idÙ$93b986d0-78a5-4291-b93d-32db8e6aa0af­parent_run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31¦run_idÙ$93b986d0-78a5-4291-b93d-32db8e6aa0afªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q068ªfocus_kind¶chain_execution_result‹¢idÙ@efee841d9b534a1d6166a001aa61abb64774c20c42ed4104046fedc221fb69d2¢tsËAÚó&"y¨trace_id¤Q068­parent_run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31¦run_idÙ$9a3555e8-8637-46dd-a4ff-18ad84c7d2b7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q068¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q068®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1a843311-1c9a-066d-122a-cd12f459c1c6ªfocus_kind¯chain_execution‹¢idÙ@7725ba6f2c957a326f9ea7d4598a9970167c2923d859961c752a4469909aabe4¢tsËAÚó&"ÿÿ¨trace_id¤Q068­parent_run_idÙ$9a3555e8-8637-46dd-a4ff-18ad84c7d2b7¦run_idÙ$6cfbc9a1-ae00-489a-84f6-7b3c960dcbcdªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§contextÚPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in making applications based on LLMs feel responsive to end-users.

Runnables expose the following three streaming APIs:

1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): yields the output a Runnable as it is generated.
2. The async `astream_events`: a more advanced streaming API that allows streaming intermediate steps and final output
3. The **legacy** async `astream_log`: a legacy streaming API that streams intermediate steps and final output

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Related Resources
* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).
:::

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

Please refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.

Runnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.

* invoke: Accepts an input and returns an output.
* batch: Accepts a list of inputs and returns a list of outputs.
* stream: Accepts an input and returns a generator that yields outputs.

The **input type** and **output type** vary by component:

Please review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides for specific examples of streaming in LangChain:
* [LangGraph conceptual guide on streaming](https://langchain-ai.github.io/langgraph/concepts/streaming/)
* [LangGraph streaming how-to guides](https://langchain-ai.github.io/langgraph/how-tos/#streaming)
* [How to stream runnables](/docs/how_to/streaming/): This how-to guide goes over common streaming patterns with LangChain components (e.g., chat models) and with [LCEL](/docs/concepts/lcel).
* [How to stream chat models](/docs/how_to/chat_streaming/)
* [How to stream tool calls](/docs/how_to/tool_streaming/)

For writing custom data to the stream, please see the following resources:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q068®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1a843311-1c9a-066d-122a-cd12f459c1c6­checkpoint_nsÙ-generate:1a843311-1c9a-066d-122a-cd12f459c1c6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3cf23f626d4666a7f4bd198023b2d5bcfbf592509fc1e3b4a1729c7d982e4632¢tsËAÚó&#×¨trace_idÙ$6cfbc9a1-ae00-489a-84f6-7b3c960dcbcd­parent_run_idÙ$9a3555e8-8637-46dd-a4ff-18ad84c7d2b7¦run_idÙ$6cfbc9a1-ae00-489a-84f6-7b3c960dcbcdªevent_type¬chain_output¬event_source¥chain§payload§outputsÚrmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which concept guide covers the standard streaming APIs exposed by Runnables? \nContext: Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\nStreaming is critical in making applications based on LLMs feel responsive to end-users.\n\nRunnables expose the following three streaming APIs:\n\n1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): yields the output a Runnable as it is generated.\n2. The async `astream_events`: a more advanced streaming API that allows streaming intermediate steps and final output\n3. The **legacy** async `astream_log`: a legacy streaming API that streams intermediate steps and final output\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n:::info Related Resources\n* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).\n:::\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.\n\n## Input and output types\n\nEvery `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.\n\nRunnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.\n\n* invoke: Accepts an input and returns an output.\n* batch: Accepts a list of inputs and returns a list of outputs.\n* stream: Accepts an input and returns a generator that yields outputs.\n\nThe **input type** and **output type** vary by component:\n\nPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.\n\n## Related Resources\n\nPlease see the following how-to guides for specific examples of streaming in LangChain:\n* [LangGraph conceptual guide on streaming](https://langchain-ai.github.io/langgraph/concepts/streaming/)\n* [LangGraph streaming how-to guides](https://langchain-ai.github.io/langgraph/how-tos/#streaming)\n* [How to stream runnables](/docs/how_to/streaming/): This how-to guide goes over common streaming patterns with LangChain components (e.g., chat models) and with [LCEL](/docs/concepts/lcel).\n* [How to stream chat models](/docs/how_to/chat_streaming/)\n* [How to stream tool calls](/docs/how_to/tool_streaming/)\n\nFor writing custom data to the stream, please see the following resources: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@a2e4e801cabb346643657afe2b32b4ae92e3370737a0a7f4aa346c1164fa65b5¢tsËAÚó&ŒS˜¨focus_msÍk§payload‚¤role©assistant§contentÚ@The concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, refer to the [Async Programming with LangChain](/docs/concepts/async) guide.ªfocus_kind¬exec_latency¨query_id¤Q068‰¢idÙ@91767b5749dae19df8a6e662d54d1987b4e7c1982e27e4f83abfdcd5d2d925ed¢tsËAÚó&ŒkD¨trace_idÙ$9a3555e8-8637-46dd-a4ff-18ad84c7d2b7­parent_run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31¦run_idÙ$9a3555e8-8637-46dd-a4ff-18ad84c7d2b7ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ@The concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, refer to the [Async Programming with LangChain](/docs/concepts/async) guide.¨query_id¤Q068ªfocus_kind¶chain_execution_result‰¢idÙ@2045b114a929eaedcef946797295650eebb8b0c8ccbfe128c8c83f6b98649098¢tsËAÚó&Œ}^¨trace_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31­parent_run_idÀ¦run_idÙ$7059f09e-ace5-472c-bcdd-1be7085f0f31ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙLWhich concept guide covers the standard streaming APIs exposed by Runnables?§context•‚´page_content_summaryÙËPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

Streaming is critical in ma...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease review the [async programming in LangChain guide](/docs/concepts/async) for more information on writing async code with LangChain.

## Related Resources

Please see the following how-to guides ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚ@The concept guide that covers the standard streaming APIs exposed by Runnables is the [Streaming Conceptual Guide](/docs/concepts/streaming). This guide provides details on how to stream in LangChain. For more information on async programming, refer to the [Async Programming with LangChain](/docs/concepts/async) guide.¨query_id¤Q068ªfocus_kind¶chain_execution_result‹¢idÙ@9485460814ecc0a7d0ff67237faaf2d63b34999d5ae1d0f7bc5164af447434a1¢tsËAÚó&Œ’*¨trace_id¤Q069­parent_run_idÀ¦run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?¨query_id¤Q069§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q069ªfocus_kind¯chain_execution‹¢idÙ@41e5048314d16aa7233de816be90a892558847122267caba6cf8c1930b6f6c65¢tsËAÚó&Œ§ô¨trace_id¤Q069­parent_run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3¦run_idÙ$ee1512d2-22db-42d6-aff0-9b6a22de0cf4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context¦answer ¨query_id¤Q069¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q069®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f79de20e-da0d-9dce-d72e-544cf4698a53ªfocus_kind¯chain_execution‰¢idÙ@fd3a84f836561570db4fb1d31d629cf4ea8950d3e1f11f18a3df527c909c1796¢tsËAÚó&¥¥‡¨trace_idÙ$ee1512d2-22db-42d6-aff0-9b6a22de0cf4­parent_run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3¦run_idÙ$ee1512d2-22db-42d6-aff0-9b6a22de0cf4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q069ªfocus_kind¶chain_execution_result‹¢idÙ@a049c0859c2d2b11469f1b4a78ba5390c8a8c3b62de305bc859b3db79f0d0dc6¢tsËAÚó&¥º„¨trace_id¤Q069­parent_run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3¦run_idÙ$d1cef915-9910-40a0-a39f-9e26d7c9afc6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q069¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q069®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:46668bbd-3cd1-3d2a-2a7b-95554f067485ªfocus_kind¯chain_execution‹¢idÙ@50a05f550544a9781cfb4330d8363a17a922b21cb87c18ad6eacd5b5c15f75f3¢tsËAÚó&¥Á{¨trace_id¤Q069­parent_run_idÙ$d1cef915-9910-40a0-a39f-9e26d7c9afc6¦run_idÙ$32824bd0-63d7-4308-a512-bf0190fa1b89ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ:What is the advantage of using `LangServe` with Runnables?§contextÚw# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Related Resources
* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).
:::

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q069®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:46668bbd-3cd1-3d2a-2a7b-95554f067485­checkpoint_nsÙ-generate:46668bbd-3cd1-3d2a-2a7b-95554f067485¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@b3aa8024df51c83331baccc45ad3f4f4e94ba5edf2213f92195e654840a47590¢tsËAÚó&¥È¨trace_idÙ$32824bd0-63d7-4308-a512-bf0190fa1b89­parent_run_idÙ$d1cef915-9910-40a0-a39f-9e26d7c9afc6¦run_idÙ$32824bd0-63d7-4308-a512-bf0190fa1b89ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚPmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the advantage of using `LangServe` with Runnables? \nContext: # Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\n:::info Related Resources\n* The ["Runnable" Interface API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) provides a detailed overview of the Runnable interface and its methods.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel).\n:::\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@123ca23133f591925714dd1fbca573ea653d44699f236505f39a0bf7e6ce0213¢tsËAÚó'C‚„¨focus_msÍ	 §payload‚¤role©assistant§contentÚÁThe advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models at runtime. This flexibility simplifies the process of adjusting settings, such as temperature in chat models, without needing to modify the underlying code. Additionally, it enhances the ability to compose complex chains using the LangChain Expression Language (LCEL).ªfocus_kind¬exec_latency¨query_id¤Q069‰¢idÙ@79e67746f0d062ac7f1b086cfb81ed7af55db3f0533d8390a8448c7b1438a36f¢tsËAÚó'C”y¨trace_idÙ$d1cef915-9910-40a0-a39f-9e26d7c9afc6­parent_run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3¦run_idÙ$d1cef915-9910-40a0-a39f-9e26d7c9afc6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÁThe advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models at runtime. This flexibility simplifies the process of adjusting settings, such as temperature in chat models, without needing to modify the underlying code. Additionally, it enhances the ability to compose complex chains using the LangChain Expression Language (LCEL).¨query_id¤Q069ªfocus_kind¶chain_execution_result‰¢idÙ@6dc6db298ea2747cb90e77a898e6ef86f36aa4271fd8d2776f26c9dd0543460c¢tsËAÚó'C^¨trace_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3­parent_run_idÀ¦run_idÙ$de66b3f7-9137-482e-916f-81a0d5e23df3ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ:What is the advantage of using `LangServe` with Runnables?§context•‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

:::info Relate...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚÁThe advantage of using `LangServe` with Runnables is that it allows for the deployment of configurable Runnables, enabling users to experiment with different parameters and models at runtime. This flexibility simplifies the process of adjusting settings, such as temperature in chat models, without needing to modify the underlying code. Additionally, it enhances the ability to compose complex chains using the LangChain Expression Language (LCEL).¨query_id¤Q069ªfocus_kind¶chain_execution_result‹¢idÙ@d3f25d376140ac789a97a5e8bceaf08b2dd23d6f742f9882abc5e17600f910e9¢tsËAÚó'C«œ¨trace_id¤Q070­parent_run_idÀ¦run_idÙ$8d35e115-92f5-400d-8671-e93104a4899aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.¨query_id¤Q070§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q070ªfocus_kind¯chain_execution‹¢idÙ@8f4b2692cdbd1a8436e9a224ef1e850983b9dbcdb0e3837ab094dc222b023517¢tsËAÚó'C·J¨trace_id¤Q070­parent_run_idÙ$8d35e115-92f5-400d-8671-e93104a4899a¦run_idÙ$47383b3f-fcc5-4db7-a76f-67b26c149ce9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context¦answer ¨query_id¤Q070¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q070®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:82351ab7-c758-6595-bc4c-10e14667a417ªfocus_kind¯chain_execution‰¢idÙ@383342da575f54ad9fd65024b228eb8cafe77075e2bafce227390eddfbd00eed¢tsËAÚó'U²ò¨trace_idÙ$47383b3f-fcc5-4db7-a76f-67b26c149ce9­parent_run_idÙ$8d35e115-92f5-400d-8671-e93104a4899a¦run_idÙ$47383b3f-fcc5-4db7-a76f-67b26c149ce9ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q070ªfocus_kind¶chain_execution_result‹¢idÙ@5d0999ea05e8305c54ac32da68469af3373a35e3b92e4728af6864dd8d9dd778¢tsËAÚó'U¿w¨trace_id¤Q070­parent_run_idÙ$8d35e115-92f5-400d-8671-e93104a4899a¦run_idÙ$395a5346-2931-492b-b414-741dcd579ebeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q070¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q070®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:42658088-a6da-f557-2108-731d2fab6c61ªfocus_kind¯chain_execution‹¢idÙ@fefb1d784583a0d07d222b678a52829aed5450c1ee17e07bd433de3420b6c07a¢tsËAÚó'UÈK¨trace_id¤Q070­parent_run_idÙ$395a5346-2931-492b-b414-741dcd579ebe¦run_idÙ$2b66c117-be00-460a-8b3c-edb49082e03aªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ1Explain how ChatModels support multimodal inputs.§contextÚC:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specific formats
2. Adhering to a cross-provider standard (see [how-to guides](/docs/how_to/#multimodal) for detail)

### How to use multimodal models

* Use the [chat model integration table](/docs/integrations/chat/) to identify which models support multimodality.
* Reference the [relevant how-to guides](/docs/how_to/#multimodal) for specific examples of how to use multimodal models.

### What kind of multimodality is supported?

#### Inputs

# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various components, allowing models and systems to handle and process a mix of these data types seamlessly.

- **Chat Models**: These could, in theory, accept and generate multimodal inputs and outputs, handling a variety of data types like text, images, audio, and video.
- **Embedding Models**: Embedding Models can represent multimodal content, embedding various forms of dataâ€”such as text, images, and audioâ€”into vector spaces.
- **Vector Stores**: Vector stores could search over embeddings that represent multimodal data, enabling retrieval across different types of information.

## Multimodality in chat models

:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the model provider. For instance,
[OpenAI](/docs/integrations/chat/openai/),
[Anthropic](/docs/integrations/chat/anthropic/), and
[Google Gemini](/docs/integrations/chat/google_generative_ai/)
support documents like PDFs as inputs.

The gist of passing multimodal inputs to a chat model is to use content blocks that
specify a type and corresponding data. For example, to pass an image to a chat model
as URL:

```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {
            "type": "image",
            "source_type": "url",
            "url": "https://...",
        },
    ],
)
response = model.invoke([message])
```

We can also pass the image as in-line data:

# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.

Modern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.

The newest generation of chat models offer additional capabilities:

#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

However, a chat model can easily interact with multimodal data by invoking tools with references (e.g., a URL) to the multimodal data, rather than the data itself. For example, any model capable of [tool calling](/docs/concepts/tool_calling) can be equipped with tools to download and process images, audio, or video.

## Multimodality in embedding models

:::info Prerequisites
* [Embedding Models](/docs/concepts/embedding_models)
:::

**Embeddings** are vector representations of data used for tasks like similarity search and retrieval.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q070®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:42658088-a6da-f557-2108-731d2fab6c61­checkpoint_nsÙ-generate:42658088-a6da-f557-2108-731d2fab6c61¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@46047c7dd143a61aaa89886481b7d49627de08931bdb1f5634d6ce8944d75d1d¢tsËAÚó'UÓ³¨trace_idÙ$2b66c117-be00-460a-8b3c-edb49082e03a­parent_run_idÙ$395a5346-2931-492b-b414-741dcd579ebe¦run_idÙ$2b66c117-be00-460a-8b3c-edb49082e03aªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ1messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how ChatModels support multimodal inputs. \nContext: :::info Pre-requisites\n* [Chat models](/docs/concepts/chat_models)\n* [Messages](/docs/concepts/messages)\n:::\n \nLangChain supports multimodal data as input to chat models:\n\n1. Following provider-specific formats\n2. Adhering to a cross-provider standard (see [how-to guides](/docs/how_to/#multimodal) for detail)\n\n### How to use multimodal models\n\n* Use the [chat model integration table](/docs/integrations/chat/) to identify which models support multimodality.\n* Reference the [relevant how-to guides](/docs/how_to/#multimodal) for specific examples of how to use multimodal models.\n\n### What kind of multimodality is supported?\n\n#### Inputs\n\n# Multimodality\n\n## Overview\n\n**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various components, allowing models and systems to handle and process a mix of these data types seamlessly.\n\n- **Chat Models**: These could, in theory, accept and generate multimodal inputs and outputs, handling a variety of data types like text, images, audio, and video.\n- **Embedding Models**: Embedding Models can represent multimodal content, embedding various forms of dataâ€”such as text, images, and audioâ€”into vector spaces.\n- **Vector Stores**: Vector stores could search over embeddings that represent multimodal data, enabling retrieval across different types of information.\n\n## Multimodality in chat models\n\n:::info Pre-requisites\n* [Chat models](/docs/concepts/chat_models)\n* [Messages](/docs/concepts/messages)\n:::\n \nLangChain supports multimodal data as input to chat models:\n\n### What kind of multimodality is supported?\n\n#### Inputs\n\nSome models can accept multimodal inputs, such as images, audio, video, or files.\nThe types of multimodal inputs supported depend on the model provider. For instance,\n[OpenAI](/docs/integrations/chat/openai/),\n[Anthropic](/docs/integrations/chat/anthropic/), and\n[Google Gemini](/docs/integrations/chat/google_generative_ai/)\nsupport documents like PDFs as inputs.\n\nThe gist of passing multimodal inputs to a chat model is to use content blocks that\nspecify a type and corresponding data. For example, to pass an image to a chat model\nas URL:\n\n```python\nfrom langchain_core.messages import HumanMessage\n\nmessage = HumanMessage(\n    content=[\n        {"type": "text", "text": "Describe the weather in this image:"},\n        {\n            "type": "image",\n            "source_type": "url",\n            "url": "https://...",\n        },\n    ],\n)\nresponse = model.invoke([message])\n```\n\nWe can also pass the image as in-line data:\n\n# Chat models\n\n## Overview\n\nLarge Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.\n\nModern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.\n\nThe newest generation of chat models offer additional capabilities:\n\n#### Tools\n\nCurrently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.\n\nHowever, a chat model can easily interact with multimodal data by invoking tools with references (e.g., a URL) to the multimodal data, rather than the data itself. For example, any model capable of [tool calling](/docs/concepts/tool_calling) can be equipped with tools to download and process images, audio, or video.\n\n## Multimodality in embedding models\n\n:::info Prerequisites\n* [Embedding Models](/docs/concepts/embedding_models)\n:::\n\n**Embeddings** are vector representations of data used for tasks like similarity search and retrieval. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@7429d2380bf35ccefa54d63341272585217e14ca97165f70e737dd79cf8f086d¢tsËAÚó'¹D1¨focus_msÍ§payload‚¤role©assistant§contentÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.ªfocus_kind¬exec_latency¨query_id¤Q070‰¢idÙ@cc8bfb96597f0c427603fb87483af510e703cb14e5860add6a9374067a7210d7¢tsËAÚó'¹ˆD¨trace_idÙ$395a5346-2931-492b-b414-741dcd579ebe­parent_run_idÙ$8d35e115-92f5-400d-8671-e93104a4899a¦run_idÙ$395a5346-2931-492b-b414-741dcd579ebeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.¨query_id¤Q070ªfocus_kind¶chain_execution_result‰¢idÙ@1ab38c431961d787d2c722be043501ffc61d6df838ec10c6e6de9bfb6005e5ed¢tsËAÚó'¹“B¨trace_idÙ$8d35e115-92f5-400d-8671-e93104a4899a­parent_run_idÀ¦run_idÙ$8d35e115-92f5-400d-8671-e93104a4899aªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ1Explain how ChatModels support multimodal inputs.§context•‚´page_content_summaryÙË:::info Pre-requisites
* [Chat models](/docs/concepts/chat_models)
* [Messages](/docs/concepts/messages)
:::
 
LangChain supports multimodal data as input to chat models:

1. Following provider-specif...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Multimodality

## Overview

**Multimodality** refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. Multimodality can appear in various compo...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË### What kind of multimodality is supported?

#### Inputs

Some models can accept multimodal inputs, such as images, audio, video, or files.
The types of multimodal inputs supported depend on the mode...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË#### Tools

Currently, no chat model is designed to work **directly** with multimodal data in a [tool call request](/docs/concepts/tool_calling) or [ToolMessage](/docs/concepts/tool_calling) result.

...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÚ{Chat models support multimodal inputs by accepting various data types such as text, images, audio, and video, depending on the model provider. Users can pass these inputs using content blocks that specify the type and corresponding data, like URLs for images. For specific implementation details, users can refer to the integration tables and how-to guides provided by LangChain.¨query_id¤Q070ªfocus_kind¶chain_execution_result‹¢idÙ@f8a8f612e208598b0a7dfffb7885b68a938a2ae0efbf6a6ea17e010499ffd33b¢tsËAÚó'¹œx¨trace_id¤Q071­parent_run_idÀ¦run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?¨query_id¤Q071§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q071ªfocus_kind¯chain_execution‹¢idÙ@eb88d83a04d10f5e7abf998c9b2c541ffa21547fcca947543759c121b2fb3b2d¢tsËAÚó'¹¨“¨trace_id¤Q071­parent_run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6¦run_idÙ$227e17f6-53d8-456f-878f-d270f9875ae6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context¦answer ¨query_id¤Q071¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q071®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:fde245c6-f7d2-9645-2710-90001de5ec9aªfocus_kind¯chain_execution‰¢idÙ@342a47108f70fa4e91a8681d18b06b4c4e3baffa816532aca810bf3b254e96ba¢tsËAÚó'ËQ¨¨trace_idÙ$227e17f6-53d8-456f-878f-d270f9875ae6­parent_run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6¦run_idÙ$227e17f6-53d8-456f-878f-d270f9875ae6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¨query_id¤Q071ªfocus_kind¶chain_execution_result‹¢idÙ@801724f765323254e6adecec2e675f26592aae9ea991c504b792520175ce2109¢tsËAÚó'Ë\á¨trace_id¤Q071­parent_run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6¦run_idÙ$891f951b-ef68-4fec-9669-fd04629ebfabªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¦answer ¨query_id¤Q071¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q071®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f594bdeb-741d-9308-8af2-dd205b7d92a0ªfocus_kind¯chain_execution‹¢idÙ@23042b94273445c618bcaa21855bed813f059fdea850a49f67d1d20e0b644a08¢tsËAÚó'ËbR¨trace_id¤Q071­parent_run_idÙ$891f951b-ef68-4fec-9669-fd04629ebfab¦run_idÙ$fe96bc9c-82fe-44aa-988a-fe90bd45f0a1ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§contextÚ‘If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                       | First prompt the LLM to ask a generic step-back question about higher-level concepts or principles, and retrieve relevant facts about them. Use this grounding to help answer the user question. [Paper](https://arxiv.org/pdf/2310.06117).                                            |
| [HyDE](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)          | If you have challenges retrieving relevant documents using the raw user inputs.                 | Use an LLM to convert questions into hypothetical documents that answer the question. Use the embedded hypothetical documents to retrieve real documents with the premise that doc-doc similarity search can produce more relevant matches. [Paper](https://arxiv.org/abs/2212.10496). |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q071®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f594bdeb-741d-9308-8af2-dd205b7d92a0­checkpoint_nsÙ-generate:f594bdeb-741d-9308-8af2-dd205b7d92a0¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@7c916fe029194a111aa9af9cfec4a859a7affbebe6b6a6ac294ce47cf3b33100¢tsËAÚó'Ëhs¨trace_idÙ$fe96bc9c-82fe-44aa-988a-fe90bd45f0a1­parent_run_idÙ$891f951b-ef68-4fec-9669-fd04629ebfab¦run_idÙ$fe96bc9c-82fe-44aa-988a-fe90bd45f0a1ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚJmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What two steps are recommended to recover from ratelimiting errors? \nContext: If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\nYou have a few options to deal with rate limits:\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                       | First prompt the LLM to ask a generic step-back question about higher-level concepts or principles, and retrieve relevant facts about them. Use this grounding to help answer the user question. [Paper](https://arxiv.org/pdf/2310.06117).                                            |\n| [HyDE](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)          | If you have challenges retrieving relevant documents using the raw user inputs.                 | Use an LLM to convert questions into hypothetical documents that answer the question. Use the embedded hypothetical documents to retrieve real documents with the premise that doc-doc similarity search can produce more relevant matches. [Paper](https://arxiv.org/abs/2212.10496). | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@121a649b6cfe76504dcbe3f6131e4e84c38702fc06da07f35cc72b23cbeadf21¢tsËAÚó('Ö¨focus_msÍŸ§payload‚¤role©assistant§contentÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.ªfocus_kind¬exec_latency¨query_id¤Q071‰¢idÙ@f74b9e2df1513a9ea216ca2fb4510655813137a77121cf957d7f955023258641¢tsËAÚó(' I¨trace_idÙ$891f951b-ef68-4fec-9669-fd04629ebfab­parent_run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6¦run_idÙ$891f951b-ef68-4fec-9669-fd04629ebfabªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.¨query_id¤Q071ªfocus_kind¶chain_execution_result‰¢idÙ@1516e3fb7f1c59c5eee1ba1d897fd341746d027a3c088c7143af4a53e1f37ab9¢tsËAÚó('«ß¨trace_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6­parent_run_idÀ¦run_idÙ$378d981e-f3a9-4162-ac75-ead51ed916d6ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙCWhat two steps are recommended to recover from ratelimiting errors?§context•‚´page_content_summaryÙÊIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

You have a few options to deal with rate limits:...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| [Step-back](https://github.com/langchain-ai/rag-from-scratch/blob/main/rag_from_scratch_5_to_9.ipynb)     | When a higher-level conceptual understanding is required.                                 ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx¦answerÙÿTo recover from rate limiting errors, you should wait a certain amount of time before retrying the request, increasing the wait time with each subsequent error. Additionally, you can use the `max_retries` parameter to control the number of retry attempts.¨query_id¤Q071ªfocus_kind¶chain_execution_result‹¢idÙ@e15e853fdfe9db75f8066bae061c01fdaeb1d13111cd1898316829af3447ef45¢tsËAÚó('²§¨trace_id¤Q072­parent_run_idÀ¦run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?¨query_id¤Q072§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q072ªfocus_kind¯chain_execution‹¢idÙ@2f920c31311a884ff9c5b0cda6db7d0d2ab2911b7b00bd5996040576b7e0f70f¢tsËAÚó('»Z¨trace_id¤Q072­parent_run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbc¦run_idÙ$ee3a8fbd-14c4-4033-9b2f-6316022ffbdcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context¦answer ¨query_id¤Q072¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q072®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:43b82072-1c2b-6916-f432-82307ec1b4f6ªfocus_kind¯chain_execution‰¢idÙ@6cad2d2bbcff1fcf7d85d1a6da5384b579042499c0a8948b7ab92d020408e301¢tsËAÚó(:¨trace_idÙ$ee3a8fbd-14c4-4033-9b2f-6316022ffbdc­parent_run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbc¦run_idÙ$ee3a8fbd-14c4-4033-9b2f-6316022ffbdcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q072ªfocus_kind¶chain_execution_result‹¢idÙ@f201493f11b005dd2f8e28bc25f766525551ffd8768b25c885a9c57a7299a10d¢tsËAÚó(:	)¨trace_id¤Q072­parent_run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbc¦run_idÙ$efcc38e4-a80f-442f-81e8-89d1d80aed49ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q072¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q072®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:165e82e9-43b2-feda-d0aa-42421f7e1a2cªfocus_kind¯chain_execution‹¢idÙ@c214c8fa8de2b83734ce02e2523354fabdbaafe319075e28fdab1bfd0152b5ec¢tsËAÚó(:¨trace_id¤Q072­parent_run_idÙ$efcc38e4-a80f-442f-81e8-89d1d80aed49¦run_idÙ$90f83ac2-1d0a-4ea8-b36d-73122c547b4fªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§contextÚò## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).

- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline's progress.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.



### `astream_events`
<span data-heading-keywords="astream_events,stream_events,stream events"></span>

:::tip
Use the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). 

While this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.
:::

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q072®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:165e82e9-43b2-feda-d0aa-42421f7e1a2c­checkpoint_nsÙ-generate:165e82e9-43b2-feda-d0aa-42421f7e1a2c¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3698d881e3954fa206e36585b8f97e3f073739bddadd082dc5e86feb3a366a1c¢tsËAÚó(:3¨trace_idÙ$90f83ac2-1d0a-4ea8-b36d-73122c547b4f­parent_run_idÙ$efcc38e4-a80f-442f-81e8-89d1d80aed49¦run_idÙ$90f83ac2-1d0a-4ea8-b36d-73122c547b4fªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÌmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which parameter allows a Runnable to stream events as JSON for UIs? \nContext: ## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n## Streaming APIs\n\nLangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).\n\n- **In LCEL Pipelines:**\nStreaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline\'s progress.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\n#### Usage with LCEL\n\nIf you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.\n\n\n\n### `astream_events`\n<span data-heading-keywords="astream_events,stream_events,stream events"></span>\n\n:::tip\nUse the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). \n\nWhile this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.\n:::\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@9b4293537d1ecaf1ac3c1c21e493f0b0565d5ec8d0476e6bca9a126a067eb4d2¢tsËAÚó(‹Q¨focus_msÍñ§payload‚¤role©assistant§contentÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.ªfocus_kind¬exec_latency¨query_id¤Q072‰¢idÙ@7bf67b73ee360a582348623057bea5c8fa424a9f53ce8f64b3b6e11b4771175b¢tsËAÚó(‹&¨trace_idÙ$efcc38e4-a80f-442f-81e8-89d1d80aed49­parent_run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbc¦run_idÙ$efcc38e4-a80f-442f-81e8-89d1d80aed49ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.¨query_id¤Q072ªfocus_kind¶chain_execution_result‰¢idÙ@6a2a3c3a861b5d79ec40629943fdd7d46b6ee2e100e733246732c67f33ee77f2¢tsËAÚó(‹1Ø¨trace_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbc­parent_run_idÀ¦run_idÙ$c31e19a2-ee62-46a4-8bf9-e1d80a799dbcªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙCWhich parameter allows a Runnable to stream events as JSON for UIs?§context•‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚTThe parameter that allows a Runnable to stream events as JSON for UIs is the `astream_events` API. This API enables access to custom data and intermediate outputs from applications built with the LangChain Expression Language (LCEL). It facilitates real-time streaming of results, enhancing user experience by providing incremental updates.¨query_id¤Q072ªfocus_kind¶chain_execution_result‹¢idÙ@ae62ec14176504f03c435d0c475f45e943bdaf0311d67dcb4c90004bf237eea5¢tsËAÚó(‹8Ş¨trace_id¤Q073­parent_run_idÀ¦run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.¨query_id¤Q073§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q073ªfocus_kind¯chain_execution‹¢idÙ@4c17a89c0837447bb105285431e41411440f9738e1dce870db633cadfc0ec9e0¢tsËAÚó(‹@)¨trace_id¤Q073­parent_run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702¦run_idÙ$2ea1421c-1b86-4f2b-94bb-c109c678960cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context¦answer ¨query_id¤Q073¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q073®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f35871c1-773c-c389-b74e-f8ea10e3f89bªfocus_kind¯chain_execution‰¢idÙ@93a91fe027e3a995263ea89e329a52babf5fd4e61c542dc9cea1c5f6ba4bb584¢tsËAÚó(2j¨trace_idÙ$2ea1421c-1b86-4f2b-94bb-c109c678960c­parent_run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702¦run_idÙ$2ea1421c-1b86-4f2b-94bb-c109c678960cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q073ªfocus_kind¶chain_execution_result‹¢idÙ@95c346dc6f468316a8411faffba64d1ecf1ccd498c6dbf0d5c2af91b527c739c¢tsËAÚó(=¨trace_id¤Q073­parent_run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702¦run_idÙ$809248c1-b31a-43d9-8c6a-9e4b9900888fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q073¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q073®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:b24a77a2-5e73-bfa5-57a8-6ab0ce84d26dªfocus_kind¯chain_execution‹¢idÙ@8cf0a04b698176e432471ad394fe270bac84ae4e815beca3870a159576099850¢tsËAÚó(B¨trace_id¤Q073­parent_run_idÙ$809248c1-b31a-43d9-8c6a-9e4b9900888f¦run_idÙ$14c4b660-15ad-4a94-ba8b-46f1b018586dªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§contextÚ# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html)

:::

:::info[Note]
This conceptual overview focuses on text-based embedding models.

Embedding models can also be [multimodal](/docs/concepts/multimodality) though such models are not currently supported by LangChain.
:::

# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.

Embeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.

- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategies for documents (which are to be searched) versus queries (the search input itself).
To illustrate, here's a practical example using LangChain's `.embed_documents` method to embed a list of strings:

```python
from langchain_openai import OpenAIEmbeddings
embeddings_model = OpenAIEmbeddings()
embeddings = embeddings_model.embed_documents(
    [
        "Hi there!",
        "Oh, hello!",
        "What's your name?",
        "My friends call me World",
        "Hello World!"
    ]
)
len(embeddings), len(embeddings[0])
(5, 1536)
```

For convenience, you can also use the `embed_query` method to embed a single text:

```python
query_embedding = embeddings_model.embed_query("What is the meaning of life?")
```

:::info[Further reading]

<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embeddings = embeddings_model.embed_documents(
    [
        "Hi there!",
        "Oh, hello!",
        "What's your name?",
        "My friends call me World",
        "Hello World!"
    ]
)
len(embeddings), len(embeddings[0])
```

```output
(5, 1536)
```


### `embed_query`
#### Embed single query
Use `.embed_query` to embed a single piece of text (e.g., for the purpose of comparing to other embedded pieces of texts).

```python
embedded_query = embeddings_model.embed_query("What was the name mentioned in the conversation?")
embedded_query[:5]
```

```output
[0.0053587136790156364,
 -0.0004999046213924885,
 0.038883671164512634,
 -0.003001077566295862,
 -0.00900818221271038]
```

```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url", "image_url": {"url": image_url}},
    ],
)
response = model.invoke([message])
```

Otherwise, chat models will typically accept the native, provider-specific content
block format. See [chat model integrations](/docs/integrations/chat/) for detail
on specific providers.


#### Outputs

Some chat models support multimodal outputs, such as images and audio. Multimodal
outputs will appear as part of the [AIMessage](/docs/concepts/messages/#aimessage)
response object. See for example:

- Generating [audio outputs](/docs/integrations/chat/openai/#audio-generation-preview) with OpenAI;
- Generating [image outputs](/docs/integrations/chat/google_generative_ai/#multimodal-usage) with Google Gemini.

#### Tools¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q073®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:b24a77a2-5e73-bfa5-57a8-6ab0ce84d26d­checkpoint_nsÙ-generate:b24a77a2-5e73-bfa5-57a8-6ab0ce84d26d¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c7a453dcf3eed9e330724234b866b1143c53f483918e35d9b5c47f8391284100¢tsËAÚó(GÔ¨trace_idÙ$14c4b660-15ad-4a94-ba8b-46f1b018586d­parent_run_idÙ$809248c1-b31a-43d9-8c6a-9e4b9900888f¦run_idÙ$14c4b660-15ad-4a94-ba8b-46f1b018586dªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ.messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Provide a code snippet to embed text with a local HuggingFace model. \nContext: # Embedding models\n<span data-heading-keywords="embedding,embeddings"></span>\n\n:::info[Prerequisites]\n\n* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html)\n\n:::\n\n:::info[Note]\nThis conceptual overview focuses on text-based embedding models.\n\nEmbedding models can also be [multimodal](/docs/concepts/multimodality) though such models are not currently supported by LangChain.\n:::\n\n# Text embedding models\n\n:::info\nHead to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.\n:::\n\nThe Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.\n\nEmbeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.\n\n- `embed_documents`: For embedding multiple texts (documents)\n- `embed_query`: For embedding a single text (query)\n\nThis distinction is important, as some providers employ different embedding strategies for documents (which are to be searched) versus queries (the search input itself).\nTo illustrate, here\'s a practical example using LangChain\'s `.embed_documents` method to embed a list of strings:\n\n```python\nfrom langchain_openai import OpenAIEmbeddings\nembeddings_model = OpenAIEmbeddings()\nembeddings = embeddings_model.embed_documents(\n    [\n        "Hi there!",\n        "Oh, hello!",\n        "What\'s your name?",\n        "My friends call me World",\n        "Hello World!"\n    ]\n)\nlen(embeddings), len(embeddings[0])\n(5, 1536)\n```\n\nFor convenience, you can also use the `embed_query` method to embed a single text:\n\n```python\nquery_embedding = embeddings_model.embed_query("What is the meaning of life?")\n```\n\n:::info[Further reading]\n\n<EmbeddingTabs customVarName="embeddings_model" />\n\n### `embed_documents`\n#### Embed list of texts\n\nUse `.embed_documents` to embed a list of strings, recovering a list of embeddings:\n\n```python\nembeddings = embeddings_model.embed_documents(\n    [\n        "Hi there!",\n        "Oh, hello!",\n        "What\'s your name?",\n        "My friends call me World",\n        "Hello World!"\n    ]\n)\nlen(embeddings), len(embeddings[0])\n```\n\n```output\n(5, 1536)\n```\n\n\n### `embed_query`\n#### Embed single query\nUse `.embed_query` to embed a single piece of text (e.g., for the purpose of comparing to other embedded pieces of texts).\n\n```python\nembedded_query = embeddings_model.embed_query("What was the name mentioned in the conversation?")\nembedded_query[:5]\n```\n\n```output\n[0.0053587136790156364,\n -0.0004999046213924885,\n 0.038883671164512634,\n -0.003001077566295862,\n -0.00900818221271038]\n```\n\n```python\nfrom langchain_core.messages import HumanMessage\n\nmessage = HumanMessage(\n    content=[\n        {"type": "text", "text": "Describe the weather in this image:"},\n        {"type": "image_url", "image_url": {"url": image_url}},\n    ],\n)\nresponse = model.invoke([message])\n```\n\nOtherwise, chat models will typically accept the native, provider-specific content\nblock format. See [chat model integrations](/docs/integrations/chat/) for detail\non specific providers.\n\n\n#### Outputs\n\nSome chat models support multimodal outputs, such as images and audio. Multimodal\noutputs will appear as part of the [AIMessage](/docs/concepts/messages/#aimessage)\nresponse object. See for example:\n\n- Generating [audio outputs](/docs/integrations/chat/openai/#audio-generation-preview) with OpenAI;\n- Generating [image outputs](/docs/integrations/chat/google_generative_ai/#multimodal-usage) with Google Gemini.\n\n#### Tools \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@3ac90f853ebe215b6c124295d53334541b7c506343ee4519852668e912a2c6e4¢tsËAÚó(úzá¨focus_msÍ §payload‚¤role©assistant§contentÚITo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Your text here."])
```

This will create embeddings for the provided list of texts.ªfocus_kind¬exec_latency¨query_id¤Q073‰¢idÙ@fb653a776c3e518492bf761a50a965d39244212faa8db82802f8479d0db9348b¢tsËAÚó(ú’¨trace_idÙ$809248c1-b31a-43d9-8c6a-9e4b9900888f­parent_run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702¦run_idÙ$809248c1-b31a-43d9-8c6a-9e4b9900888fªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚITo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Your text here."])
```

This will create embeddings for the provided list of texts.¨query_id¤Q073ªfocus_kind¶chain_execution_result‰¢idÙ@b74fb016c2f6755620ace4965f49f8a759ea0975908b449a8b5dac5d1f5d47fb¢tsËAÚó(ú™N¨trace_idÙ$b14adb90-6d41-47b6-a874-242df0c77702­parent_run_idÀ¦run_idÙ$b14adb90-6d41-47b6-a874-242df0c77702ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙDProvide a code snippet to embed text with a local HuggingFace model.§context•‚´page_content_summaryÙË# Embedding models
<span data-heading-keywords="embedding,embeddings"></span>

:::info[Prerequisites]

* [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents....¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË# Text embedding models

:::info
Head to [Integrations](/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.
:::

The Embeddings class is...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË- `embed_documents`: For embedding multiple texts (documents)
- `embed_query`: For embedding a single text (query)

This distinction is important, as some providers employ different embedding strategi...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/embedding_models.mdx‚´page_content_summaryÙË<EmbeddingTabs customVarName="embeddings_model" />

### `embed_documents`
#### Embed list of texts

Use `.embed_documents` to embed a list of strings, recovering a list of embeddings:

```python
embed...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/embed_text.mdx‚´page_content_summaryÙË```python
from langchain_core.messages import HumanMessage

message = HumanMessage(
    content=[
        {"type": "text", "text": "Describe the weather in this image:"},
        {"type": "image_url",...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÚITo embed text using a local Hugging Face model, you can use the following code snippet:

```python
from langchain_huggingface import HuggingFaceEmbeddings
embeddings_model = HuggingFaceEmbeddings()
embeddings = embeddings_model.embed_documents(["Your text here."])
```

This will create embeddings for the provided list of texts.¨query_id¤Q073ªfocus_kind¶chain_execution_result‹¢idÙ@8baccfd7ac5dd5ec2c8555acd207230491dd91d1adb7b1dc464c9b3cdbe4bb8f¢tsËAÚó(ú{¨trace_id¤Q074­parent_run_idÀ¦run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?¨query_id¤Q074§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q074ªfocus_kind¯chain_execution‹¢idÙ@65e08b9a40098b6a2378c36aff248ab12b306e2063af742baf6ccc85d7f0afc8¢tsËAÚó(ú§†¨trace_id¤Q074­parent_run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8¦run_idÙ$8b5934d1-f7a4-4a59-b107-b059c5b64488ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context¦answer ¨query_id¤Q074¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q074®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:31f87f92-a955-ebd0-98ea-a4520e89c382ªfocus_kind¯chain_execution‰¢idÙ@186dd48134c1117ad3e610123ffe17161fd47e9607e945575fa4021c1fb1dbaf¢tsËAÚó)08¨trace_idÙ$8b5934d1-f7a4-4a59-b107-b059c5b64488­parent_run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8¦run_idÙ$8b5934d1-f7a4-4a59-b107-b059c5b64488ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q074ªfocus_kind¶chain_execution_result‹¢idÙ@9e94c5336d472851e1cb25008e2f7f646e097a2b75de643dbd48cf16d8bf9de6¢tsËAÚó)<Í¨trace_id¤Q074­parent_run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8¦run_idÙ$6120890f-86a2-40d8-8a77-481c2f518994ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q074¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q074®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5df94c69-a649-a165-655e-dbb3b32aab0aªfocus_kind¯chain_execution‹¢idÙ@567a9e6cd0bd5356bf2462751183bdcd7319be12e156ad7da397e661a5129cec¢tsËAÚó)B¨trace_id¤Q074­parent_run_idÙ$6120890f-86a2-40d8-8a77-481c2f518994¦run_idÙ$90b7b759-7f55-4acf-8361-addf2a4dc36bªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§contextÚº![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small chunk size for indexing documents in a vectorstore. 
If you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. 

LangChain has two different retrievers that can be used to address this challenge. 
The [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. 
The [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we combine search results from many retrievers? 
This motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).

### Source document retention 

Many retrievers utilize some kind of index to make documents easily searchable.
The process of indexing can include a transformation step (e.g., vectorstores often use document splitting). 
Whatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.

![Retrieval with full docs](/img/retriever_full_docs.png)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q074®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5df94c69-a649-a165-655e-dbb3b32aab0a­checkpoint_nsÙ-generate:5df94c69-a649-a165-655e-dbb3b32aab0a¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@95a1f7c3940c93e6794e28bbed07b2362fc2f990263ba5230e72e3ed66d30878¢tsËAÚó)H#¨trace_idÙ$90b7b759-7f55-4acf-8361-addf2a4dc36b­parent_run_idÙ$6120890f-86a2-40d8-8a77-481c2f518994¦run_idÙ$90b7b759-7f55-4acf-8361-addf2a4dc36bªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¢messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How does the `ContextualCompressionRetriever` reduce context windows? \nContext: ![Retrieval with full docs](/img/retriever_full_docs.png)\n\nThis is particularly useful in AI applications, because it ensures no loss in document context for the model.\nFor example, you may use small chunk size for indexing documents in a vectorstore. \nIf you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. \n\nLangChain has two different retrievers that can be used to address this challenge. \nThe [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. \nThe [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\nWhen ensembling, how do we combine search results from many retrievers? \nThis motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).\n\n### Source document retention \n\nMany retrievers utilize some kind of index to make documents easily searchable.\nThe process of indexing can include a transformation step (e.g., vectorstores often use document splitting). \nWhatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.\n\n![Retrieval with full docs](/img/retriever_full_docs.png) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@abe9b05750c6f138ccc8910cfa7e127a607a563b49847cfc7eca875dc51fbd36¢tsËAÚó)d@5¨focus_msÍ?§payload‚¤role©assistant§contentÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.ªfocus_kind¬exec_latency¨query_id¤Q074‰¢idÙ@324b85f7e5a67750ada85f90cddc432e4c0c4ea51f368a6415e87122c9bc03fd¢tsËAÚó)dS3¨trace_idÙ$6120890f-86a2-40d8-8a77-481c2f518994­parent_run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8¦run_idÙ$6120890f-86a2-40d8-8a77-481c2f518994ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.¨query_id¤Q074ªfocus_kind¶chain_execution_result‰¢idÙ@9d18b48ca3ed294141580c085d456436a386cc09b5afc9e7c2f5e78e0038928c¢tsËAÚó)d\:¨trace_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8­parent_run_idÀ¦run_idÙ$db8900e3-4b93-4684-a6a5-7ffc6d9111a8ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙEHow does the `ContextualCompressionRetriever` reduce context windows?§context•‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÚ“The `ContextualCompressionRetriever` reduces context windows by allowing the use of smaller chunk sizes for indexing documents while retaining the linkage to the original document. This ensures that even when only chunks are retrieved, the model does not lose the overall context of the document. By maintaining this connection, it effectively compresses the data while preserving essential information.¨query_id¤Q074ªfocus_kind¶chain_execution_result‹¢idÙ@8086935fe9866790dfd35c8f6300b178744500fd0df364f7de33d4370282b7fa¢tsËAÚó)ddÇ¨trace_id¤Q075­parent_run_idÀ¦run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?¨query_id¤Q075§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q075ªfocus_kind¯chain_execution‹¢idÙ@c090eb533ffe03cfc3d67ed75e7d74c4cd0136dd3c4120a3c78c42cc389b775f¢tsËAÚó)dsT¨trace_id¤Q075­parent_run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5¦run_idÙ$d7d7c572-97de-40c3-919c-93126476408bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context¦answer ¨query_id¤Q075¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q075®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e7204458-c6be-0a23-3122-01dd70c1888fªfocus_kind¯chain_execution‰¢idÙ@c335ec9a98ad12cd059183a9c0a7943267dd7ec17e7bfadaeb341d4b48bdb747¢tsËAÚó)z_F¨trace_idÙ$d7d7c572-97de-40c3-919c-93126476408b­parent_run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5¦run_idÙ$d7d7c572-97de-40c3-919c-93126476408bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q075ªfocus_kind¶chain_execution_result‹¢idÙ@20164316d19de9482a4bfce7b4df525461c4d2b55d889f17624d24e480cb6272¢tsËAÚó)zi"¨trace_id¤Q075­parent_run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5¦run_idÙ$823e6acf-d5b3-4144-8800-8b1cbeaa10eaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q075¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q075®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:340ebb79-9cc8-5e42-b3d7-a0e5ee1e0b8eªfocus_kind¯chain_execution‹¢idÙ@34b3d5a3b3bdef0c87564bef5ab84420a3af6656b12ef0d42612085e13d3349b¢tsËAÚó)zn¨trace_id¤Q075­parent_run_idÙ$823e6acf-d5b3-4144-8800-8b1cbeaa10ea¦run_idÙ$29c069a7-08cc-4a0a-8284-a8fafbf72391ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§contextÚIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check out [the relevant how-to guides](/docs/how_to/#langchain-expression-language-lcel).

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.
* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.

See the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)

Refer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble LangChain components into full-featured applications.

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q075®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:340ebb79-9cc8-5e42-b3d7-a0e5ee1e0b8e­checkpoint_nsÙ-generate:340ebb79-9cc8-5e42-b3d7-a0e5ee1e0b8e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@3de73db3511fdcef1b12429f218b71c720ae8e0fe9ae5db24cd6ca390ef45356¢tsËAÚó)zuû¨trace_idÙ$29c069a7-08cc-4a0a-8284-a8fafbf72391­parent_run_idÙ$823e6acf-d5b3-4144-8800-8b1cbeaa10ea¦run_idÙ$29c069a7-08cc-4a0a-8284-a8fafbf72391ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚúmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What guide should you consult for configuring runtime chain internals like temperature? \nContext: If you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).\n\nFor guides on how to do specific tasks with LCEL, check out [the relevant how-to guides](/docs/how_to/#langchain-expression-language-lcel).\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:\n\n* `configurable_fields`: This method allows you to configure specific **attributes** in a Runnable. For example, the `temperature` attribute of a chat model.\n* `configurable_alternatives`: This method enables you to specify **alternative** Runnables that can be run during runtime. For example, you could specify a list of different chat models that can be used.\n\nSee the [How to configure runtime chain internals](/docs/how_to/configure) guide for more information on how to configure runtime chain internals.\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph)\n\nRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.\n\n## Orchestration\n\nGet started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble LangChain components into full-featured applications.\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@936952fb1037d103d4bfd5750d27671b42d02cfb47b64b31736304949cd6cf75¢tsËAÚó)Ùˆe¨focus_msÍÍ§payload‚¤role©assistant§contentÙéYou should consult the guide titled "How to configure runtime chain internals" for information on configuring attributes like temperature. This guide provides detailed instructions on how to manage runtime configurations effectively.ªfocus_kind¬exec_latency¨query_id¤Q075‰¢idÙ@8fc060e8ee04b96d49692e8f6c6c272e748545f18fa99a8c5d9bb2798f287861¢tsËAÚó)Ù–c¨trace_idÙ$823e6acf-d5b3-4144-8800-8b1cbeaa10ea­parent_run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5¦run_idÙ$823e6acf-d5b3-4144-8800-8b1cbeaa10eaªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙéYou should consult the guide titled "How to configure runtime chain internals" for information on configuring attributes like temperature. This guide provides detailed instructions on how to manage runtime configurations effectively.¨query_id¤Q075ªfocus_kind¶chain_execution_result‰¢idÙ@523a5f452a8131bb7fbabc2e48d4a177519fb087dd6ad44380bd8ece2455a281¢tsËAÚó)ÙÃ¨trace_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5­parent_run_idÀ¦run_idÙ$d138cbd3-c298-4161-b45a-a9585bf9eff5ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙWWhat guide should you consult for configuring runtime chain internals like temperature?§context•‚´page_content_summaryÙËIf you are currently using one of these legacy chains, please see [this guide for guidance on how to migrate](/docs/versions/migrating_chains).

For guides on how to do specific tasks with LCEL, check...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:

* `configurable_fields`: This method allows you to configure specific **attribute...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËRefer to the [how-to guides](/docs/how_to) for more detail on using all LangChain components.

## Orchestration

Get started using [LangGraph](https://langchain-ai.github.io/langgraph/) to assemble La...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÙéYou should consult the guide titled "How to configure runtime chain internals" for information on configuring attributes like temperature. This guide provides detailed instructions on how to manage runtime configurations effectively.¨query_id¤Q075ªfocus_kind¶chain_execution_result‹¢idÙ@38068e490c59ae5897346a56233374e5358e6e9e8ef27bb03c455c615719925c¢tsËAÚó)Ù¤¨trace_id¤Q076­parent_run_idÀ¦run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?¨query_id¤Q076§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q076ªfocus_kind¯chain_execution‹¢idÙ@05e621d0b5b985e96315c0b80afb022fb777faa2a641250a9b5f617e99677b0b¢tsËAÚó)Ù¬¹¨trace_id¤Q076­parent_run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719¦run_idÙ$74962ade-75ec-4098-8745-98497c7e7b13ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context¦answer ¨query_id¤Q076¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q076®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:8d534830-26cd-d157-2a00-517c902859b2ªfocus_kind¯chain_execution‰¢idÙ@3f2fb2278aa5a7fad2f309ca6fdcb5e9384a9a3f07408a0d43905228ee95ba24¢tsËAÚó)ì…¨trace_idÙ$74962ade-75ec-4098-8745-98497c7e7b13­parent_run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719¦run_idÙ$74962ade-75ec-4098-8745-98497c7e7b13ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¨query_id¤Q076ªfocus_kind¶chain_execution_result‹¢idÙ@8639f5283a96ad7d17fd6990bd27a23bd491fa6e376b891e50cda17a4bd5a0f6¢tsËAÚó)ì™¨trace_id¤Q076­parent_run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719¦run_idÙ$5aa46460-549b-4046-9869-6bd14382e0bcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¦answer ¨query_id¤Q076¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q076®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ec8051c9-4042-6116-0661-b120c105b71dªfocus_kind¯chain_execution‹¢idÙ@be8b11e078da7cae62477a687487814eac2d6a0baea31ad675054efccc1e98ad¢tsËAÚó)ì¢¾¨trace_id¤Q076­parent_run_idÙ$5aa46460-549b-4046-9869-6bd14382e0bc¦run_idÙ$2c161630-b77f-423f-9eae-263ecd386e3aªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§contextÚ| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeVectorStore.max_marginal_relevance_search) | When needing to diversify search results.             | MMR attempts to diversify the results of a search to avoid returning similar and redundant documents.                                        |

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs/how_to/example_selectors)
- [How to: select examples by length](/docs/how_to/example_selectors_length_based)
- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)
- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)
- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)
- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).

This gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.
Sometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.

**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.

## Related resources

* [Example selector how-to guides](/docs/how_to/#example-selectors)

At a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's responses are used as examples for a worse (presumably cheaper/faster) model.
- User feedback: users (or labelers) leave feedback on interactions with the application and examples are generated based on that feedback (for example, all interactions with positive feedback could be turned into examples).
- LLM feedback: same as user feedback but the process is automated by having models evaluate themselves.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q076®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ec8051c9-4042-6116-0661-b120c105b71d­checkpoint_nsÙ-generate:ec8051c9-4042-6116-0661-b120c105b71d¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c92ef706429b8356441cf254c8c568957358fce13d4197023b413ba76abad39e¢tsËAÚó)ì®d¨trace_idÙ$2c161630-b77f-423f-9eae-263ecd386e3a­parent_run_idÙ$5aa46460-549b-4046-9869-6bd14382e0bc¦run_idÙ$2c161630-b77f-423f-9eae-263ecd386e3aªevent_type¬chain_output¬event_source¥chain§payload§outputsÚğmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which selector uses Maximal Marginal Relevance (MMR) to diversify examples? \nContext: | [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeVectorStore.max_marginal_relevance_search) | When needing to diversify search results.             | MMR attempts to diversify the results of a search to avoid returning similar and redundant documents.                                        |\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n### Example selectors\n\n[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.\n\n- [How to: use example selectors](/docs/how_to/example_selectors)\n- [How to: select examples by length](/docs/how_to/example_selectors_length_based)\n- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)\n- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)\n- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)\n- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n# Example selectors\n\n:::note Prerequisites\n\n- [Chat models](/docs/concepts/chat_models/)\n- [Few-shot prompting](/docs/concepts/few_shot_prompting/)\n:::\n\n## Overview\n\nOne common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).\n\nThis gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.\nSometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.\n\n**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.\n\n## Related resources\n\n* [Example selector how-to guides](/docs/how_to/#example-selectors)\n\nAt a high-level, the basic ways to generate examples are:\n- Manual: a person/people generates examples they think are useful.\n- Better model: a better (presumably more expensive/slower) model's responses are used as examples for a worse (presumably cheaper/faster) model.\n- User feedback: users (or labelers) leave feedback on interactions with the application and examples are generated based on that feedback (for example, all interactions with positive feedback could be turned into examples).\n- LLM feedback: same as user feedback but the process is automated by having models evaluate themselves. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ccafd2ad56d8b253707d07a9bc6efe53bf584065649bc68dca34b2fe47ffe626¢tsËAÚó*O.¨focus_msÍ§payload‚¤role©assistant§contentÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.ªfocus_kind¬exec_latency¨query_id¤Q076‰¢idÙ@06efc969c2e364b0ed620b753b6bf11c549b14a0318bb043d54d2514ba550e66¢tsËAÚó*O*Ï¨trace_idÙ$5aa46460-549b-4046-9869-6bd14382e0bc­parent_run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719¦run_idÙ$5aa46460-549b-4046-9869-6bd14382e0bcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.¨query_id¤Q076ªfocus_kind¶chain_execution_result‰¢idÙ@578d87f7a5f0962eb2dd9001f78cf971e17a1a4951e57432d4f19305b7618269¢tsËAÚó*O4
¨trace_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719­parent_run_idÀ¦run_idÙ$66d29259-abc8-43e6-94b2-53d8a999e719ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKWhich selector uses Maximal Marginal Relevance (MMR) to diversify examples?§context•‚´page_content_summaryÙË| [Maximal Marginal Relevance (MMR)](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html#langchain_pinecone.vectorstores.PineconeV...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËAt a high-level, the basic ways to generate examples are:
- Manual: a person/people generates examples they think are useful.
- Better model: a better (presumably more expensive/slower) model's respon...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx¦answerÚ5The selector that uses Maximal Marginal Relevance (MMR) to diversify examples is the "Example Selector by Maximal Marginal Relevance." This selector is designed to ensure a more diverse set of results by re-ranking after the initial similarity search. It helps avoid returning similar and redundant documents.¨query_id¤Q076ªfocus_kind¶chain_execution_result‹¢idÙ@94b4619c5e6a8156996be528e5595c0c4e67677d7824982e3ce7e957ad42d312¢tsËAÚó*O<%¨trace_id¤Q077­parent_run_idÀ¦run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?¨query_id¤Q077§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q077ªfocus_kind¯chain_execution‹¢idÙ@d42c7fa8c9c7154810f7d1cc0727b1ac2a82fe436b8f60b8394afcc3ba2d5027¢tsËAÚó*OFé¨trace_id¤Q077­parent_run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700c¦run_idÙ$5d71e10e-2906-4016-a98f-3cec0793108cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context¦answer ¨query_id¤Q077¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q077®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:fef5c632-cae5-c62d-6813-4a63233a1f41ªfocus_kind¯chain_execution‰¢idÙ@1fffa5b17a9fc979927361a0c7e547e3d98d7f3b5179fa2631e1cd6e3f762223¢tsËAÚó*Z¨trace_idÙ$5d71e10e-2906-4016-a98f-3cec0793108c­parent_run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700c¦run_idÙ$5d71e10e-2906-4016-a98f-3cec0793108cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q077ªfocus_kind¶chain_execution_result‹¢idÙ@a860ea547ecb0eeb9a8267a7ed2007cfa42bb40f0002a1897d29b380e24d4fdc¢tsËAÚó*Z(F¨trace_id¤Q077­parent_run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700c¦run_idÙ$c6f0da48-053e-437d-a272-d28798904204ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q077¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q077®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:34baafc7-63e4-3ab3-3259-fe7dce88ec22ªfocus_kind¯chain_execution‹¢idÙ@1eaa381e1f17d160c3f320245c46b8faf1af4acc625928ecea2518b397f9dad9¢tsËAÚó*Z,¨trace_id¤Q077­parent_run_idÙ$c6f0da48-053e-437d-a272-d28798904204¦run_idÙ$e4ae45cb-00cd-4120-8c35-de449bdde656ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§contextÚû### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, tool calling involves binding a tool to a model and, when appropriate, the model can *decide* to call this tool and ensure its response conforms to the tool's schema.
With this in mind, the central concept is straightforward: *simply bind our schema to a model as a tool!*
Here is an example using the `ResponseFormatter` schema defined above:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o", temperature=0)
# Bind responseformatter schema as a tool to the model
model_with_tools = model.bind_tools([ResponseFormatter])
# Invoke the model
ai_msg = model_with_tools.invoke("What is the powerhouse of the cell?")
```

# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.
But what about cases where we want a model to also interact *directly* with systems, such as databases or an API?
These systems often have a particular input schema; for example, APIs frequently have a required payload structure.
This need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.

:::info
You will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. 
:::

![Conceptual overview of tool calling](/img/tool_calling_concept.png)

## Key concepts

### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/)), that allows a developer to request model responses that match a particular schema.
The APIs for each provider differ. 
LangChain's [chat model](/docs/concepts/chat_models/) interface provides a common way to bind [tools](/docs/concepts/tools) to a model in order to support [tool calling](/docs/concepts/tool_calling/):

```python
# Tool creation
tools = [my_tool]
# Tool binding
model_with_tools = model.bind_tools(tools)
```

### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSON output.
You can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).
Here is an example of how to use JSON mode with OpenAI:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")
ai_msg = model.invoke("Return a JSON object with key 'random_ints' and a value of 10 random ints in [0-99]")
ai_msg
{'random_ints': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}
```

## Structured output method 

There are a few challenges when producing structured output with the above methods: 

(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.

Some important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can't be supported on these.
- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they're not enforced on models in `langchain-community`.

Chat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.

## Tool calling

Chat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please
see the [tool calling](/docs/concepts/tool_calling) guide for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q077®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:34baafc7-63e4-3ab3-3259-fe7dce88ec22­checkpoint_nsÙ-generate:34baafc7-63e4-3ab3-3259-fe7dce88ec22¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@cf123767393da7f4a1ebd845d7e464830fae9617c9a09310c76f94c11d8d42d9¢tsËAÚó*Z2¨trace_idÙ$e4ae45cb-00cd-4120-8c35-de449bdde656­parent_run_idÙ$c6f0da48-053e-437d-a272-d28798904204¦run_idÙ$e4ae45cb-00cd-4120-8c35-de449bdde656ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the recommended way to expose tool schemas to chat models that use OpenAI function calling? \nContext: ### Using tool calling\n\nMany [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).\nIn short, tool calling involves binding a tool to a model and, when appropriate, the model can *decide* to call this tool and ensure its response conforms to the tool\'s schema.\nWith this in mind, the central concept is straightforward: *simply bind our schema to a model as a tool!*\nHere is an example using the `ResponseFormatter` schema defined above:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o", temperature=0)\n# Bind responseformatter schema as a tool to the model\nmodel_with_tools = model.bind_tools([ResponseFormatter])\n# Invoke the model\nai_msg = model_with_tools.invoke("What is the powerhouse of the cell?")\n```\n\n# Tool calling\n\n:::info[Prerequisites]\n* [Tools](/docs/concepts/tools)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n\n## Overview \n\nMany AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.\nBut what about cases where we want a model to also interact *directly* with systems, such as databases or an API?\nThese systems often have a particular input schema; for example, APIs frequently have a required payload structure.\nThis need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.\n\n:::info\nYou will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. \n:::\n\n![Conceptual overview of tool calling](/img/tool_calling_concept.png)\n\n## Key concepts\n\n### Example: chat models \n\nMany [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/)), that allows a developer to request model responses that match a particular schema.\nThe APIs for each provider differ. \nLangChain\'s [chat model](/docs/concepts/chat_models/) interface provides a common way to bind [tools](/docs/concepts/tools) to a model in order to support [tool calling](/docs/concepts/tool_calling/):\n\n```python\n# Tool creation\ntools = [my_tool]\n# Tool binding\nmodel_with_tools = model.bind_tools(tools)\n```\n\n### JSON mode\n\nIn addition to tool calling, some model providers support a feature called `JSON mode`. \nThis supports JSON schema definition as input and enforces the model to produce a conforming JSON output.\nYou can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).\nHere is an example of how to use JSON mode with OpenAI:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")\nai_msg = model.invoke("Return a JSON object with key \'random_ints\' and a value of 10 random ints in [0-99]")\nai_msg\n{\'random_ints\': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}\n```\n\n## Structured output method \n\nThere are a few challenges when producing structured output with the above methods: \n\n(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.\n\nSome important things to note:\n\n- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration for maximum output tokens, so max_tokens can\'t be supported on these.\n- Standard parameters are currently only enforced on integrations that have their own integration packages (e.g. `langchain-openai`, `langchain-anthropic`, etc.), they\'re not enforced on models in `langchain-community`.\n\nChat models also accept other parameters that are specific to that integration. To find all the parameters supported by a Chat model head to the their respective [API reference](https://python.langchain.com/api_reference/) for that model.\n\n## Tool calling\n\nChat models can call [tools](/docs/concepts/tools) to perform tasks such as fetching data from a database, making API requests, or running custom code. Please\nsee the [tool calling](/docs/concepts/tool_calling) guide for more information. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@8efc3b0795eed37bd533e90e7f3d8074c247d11f1e288c0a6a8d6513ae47ce75¢tsËAÚó*åæŠ¨focus_msÍ†§payload‚¤role©assistant§contentÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.ªfocus_kind¬exec_latency¨query_id¤Q077‰¢idÙ@f9d10292f2c3cb73296c68d612c52742202e6f6d82d65602983e3c4a2f5e1381¢tsËAÚó*åÿ&¨trace_idÙ$c6f0da48-053e-437d-a272-d28798904204­parent_run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700c¦run_idÙ$c6f0da48-053e-437d-a272-d28798904204ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.¨query_id¤Q077ªfocus_kind¶chain_execution_result‰¢idÙ@65a9b840999ccbcca6cc52abccc8d6521e053d931afee62ed1a7b82ee4f96dc4¢tsËAÚó*æ»¨trace_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700c­parent_run_idÀ¦run_idÙ$d84c1ff6-a091-4300-85f1-25e9f070700cªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙcWhat is the recommended way to expose tool schemas to chat models that use OpenAI function calling?§context•‚´page_content_summaryÙË### Using tool calling

Many [model providers support](/docs/integrations/chat/) tool calling, a concept discussed in more detail in our [tool calling guide](/docs/concepts/tool_calling/).
In short, t...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË### Example: chat models 

Many [model providers](/docs/concepts/chat_models/) support [tool calling](/docs/concepts/tool_calling/), a critical feature for many applications (e.g., [agents](https://la...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙËSome important things to note:

- Standard parameters only apply to model providers that expose parameters with the intended functionality. For example, some providers do not expose a configuration fo...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚrThe recommended way to expose tool schemas to chat models using OpenAI function calling is to bind the schema as a tool to the model. This can be done using the `bind_tools` method, where you pass the schema as a list of tools. For example, you would create a model instance and then bind the schema like this: `model_with_tools = model.bind_tools([ResponseFormatter])`.¨query_id¤Q077ªfocus_kind¶chain_execution_result‹¢idÙ@327a111d7bfeb8231da090218291df83d0efaa04b7a07edd1e81aef7ee9c3269¢tsËAÚó*æ¨trace_id¤Q078­parent_run_idÀ¦run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.¨query_id¤Q078§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q078ªfocus_kind¯chain_execution‹¢idÙ@a0a568adea3eeb4ab1dcfef9c3d8fde6ca0b0745cc74087041a6cde183f26f01¢tsËAÚó*æü¨trace_id¤Q078­parent_run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683¦run_idÙ$e834c086-51dd-45d3-ac00-1eb0db5ba2c0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context¦answer ¨query_id¤Q078¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q078®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f5f8ecbd-946e-e447-a132-ba252d8069ddªfocus_kind¯chain_execution‰¢idÙ@2821e4b9fa1ebd456411ee992271fc73b3db6f6ffd19605cc75757b1eb40f549¢tsËAÚó*ùÎ¯¨trace_idÙ$e834c086-51dd-45d3-ac00-1eb0db5ba2c0­parent_run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683¦run_idÙ$e834c086-51dd-45d3-ac00-1eb0db5ba2c0ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q078ªfocus_kind¶chain_execution_result‹¢idÙ@e951231c3df896b00f594f5cbd9ac0cc3efa3764369cfe022d861dd7dc513276¢tsËAÚó*ùÙw¨trace_id¤Q078­parent_run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683¦run_idÙ$60d35e47-72b1-45a8-8e8b-838765a1a9d4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q078¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q078®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ab0e4375-f625-c077-607a-366d3b6a7781ªfocus_kind¯chain_execution‹¢idÙ@b91e6a75c2a4b9c36f52383db1568f3a520806c3295839e3a657aa94e1ab5c7c¢tsËAÚó*ùßU¨trace_id¤Q078­parent_run_idÙ$60d35e47-72b1-45a8-8e8b-838765a1a9d4¦run_idÙ$71f12af0-b108-429e-ac1a-80ba1d6f9cdeªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§contextÚÁThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.
- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q078®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ab0e4375-f625-c077-607a-366d3b6a7781­checkpoint_nsÙ-generate:ab0e4375-f625-c077-607a-366d3b6a7781¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@453c096289914c3c2c320cc9f748cf35ca3815ecc9edcb0dfb522cd2297a438b¢tsËAÚó*ùçq¨trace_idÙ$71f12af0-b108-429e-ac1a-80ba1d6f9cde­parent_run_idÙ$60d35e47-72b1-45a8-8e8b-838765a1a9d4¦run_idÙ$71f12af0-b108-429e-ac1a-80ba1d6f9cdeªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¦messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain the advantage of using `batch_as_completed` for long running tasks. \nContext: The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/concepts/runnables/#optimized-parallel-execution-batch). Parallel execution can significantly reduce the latency as processing can be done in parallel instead of sequentially.\n- **Guaranteed Async support**: Any chain built with LCEL can be run asynchronously using the [Runnable Async API](/docs/concepts/runnables/#asynchronous-support). This can be useful when running chains in a server environment where you want to handle large number of requests concurrently. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@0097829aa9c8dab33d7e379ffa346407d6b476f138da981772b213811bed83fc¢tsËAÚó+Y)ö¨focus_msÍĞ§payload‚¤role©assistant§contentÚæThe advantage of using `batch_as_completed` for long-running tasks is that it allows for efficient parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly reduce latency, especially for I/O-bound tasks, as it enables the system to handle results as soon as they are available. Additionally, it simplifies thread management for users, allowing them to focus on the task rather than the underlying execution details.ªfocus_kind¬exec_latency¨query_id¤Q078‰¢idÙ@6ba415ea33f1517a9985332c8ea8c8e765c1085876a813c07ecc4e4c03d2a4bb¢tsËAÚó+YPj¨trace_idÙ$60d35e47-72b1-45a8-8e8b-838765a1a9d4­parent_run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683¦run_idÙ$60d35e47-72b1-45a8-8e8b-838765a1a9d4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚæThe advantage of using `batch_as_completed` for long-running tasks is that it allows for efficient parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly reduce latency, especially for I/O-bound tasks, as it enables the system to handle results as soon as they are available. Additionally, it simplifies thread management for users, allowing them to focus on the task rather than the underlying execution details.¨query_id¤Q078ªfocus_kind¶chain_execution_result‰¢idÙ@b036056f115d727f47965682dc9061b1f454b849310ec9fafa0566eec1011565¢tsËAÚó+YXK¨trace_idÙ$2b52e086-2eea-442b-b762-d5dba9203683­parent_run_idÀ¦run_idÙ$2b52e086-2eea-442b-b762-d5dba9203683ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKExplain the advantage of using `batch_as_completed` for long running tasks.§context•‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **Optimized parallel execution**: Run Runnables in parallel using [RunnableParallel](#runnableparallel) or run multiple inputs through a given chain in parallel using the [Runnable Batch API](/docs/...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚæThe advantage of using `batch_as_completed` for long-running tasks is that it allows for efficient parallel processing of multiple inputs, returning results as they complete rather than in a fixed order. This can significantly reduce latency, especially for I/O-bound tasks, as it enables the system to handle results as soon as they are available. Additionally, it simplifies thread management for users, allowing them to focus on the task rather than the underlying execution details.¨query_id¤Q078ªfocus_kind¶chain_execution_result‹¢idÙ@e2044cfa0eba5e02d53079dec2c640f6fd959ff8b0471db2a246945894c73542¢tsËAÚó+Y^¨trace_id¤Q079­parent_run_idÀ¦run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?¨query_id¤Q079§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q079ªfocus_kind¯chain_execution‹¢idÙ@58b62e5b14e4b5231559e613bdc63696099fc495c4d4d7357ce5228ec8c0f5d4¢tsËAÚó+Yh¿¨trace_id¤Q079­parent_run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2¦run_idÙ$438f00cc-eda0-484b-9f1d-54bdd8273ba6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context¦answer ¨query_id¤Q079¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q079®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e4c905e3-d743-c412-85f7-ab8c3e1eca55ªfocus_kind¯chain_execution‰¢idÙ@07c98dc5668b2b15787994cb11f83a0ec44a38fd08de5296e9a1ad1c3330aeec¢tsËAÚó+t8Ÿ¨trace_idÙ$438f00cc-eda0-484b-9f1d-54bdd8273ba6­parent_run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2¦run_idÙ$438f00cc-eda0-484b-9f1d-54bdd8273ba6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q079ªfocus_kind¶chain_execution_result‹¢idÙ@d45db9d46d30615a4316f9e3373f5892cf4aac35bcc8ecbfe7e6c35a789f2792¢tsËAÚó+tK¨trace_id¤Q079­parent_run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2¦run_idÙ$26b87d39-18f8-4738-aa92-12a7d8f872f6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q079¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q079®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:83e0b2e4-8a5b-87eb-18b4-98e8d648b159ªfocus_kind¯chain_execution‹¢idÙ@b9ef374fef967c38ac69f769912fc67340fca31778d0c9fd2d1789bc62111c60¢tsËAÚó+tR¨trace_id¤Q079­parent_run_idÙ$26b87d39-18f8-4738-aa92-12a7d8f872f6¦run_idÙ$b536a89e-df43-4521-a9b0-ec3f04ad1464ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§contextÚB## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

The **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often involves a combination of two patterns of alternating messages:

1. The **user** and the **assistant** representing a back-and-forth conversation.
2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.

## Managing chat history

Since chat models have a maximum limit on input size, it's important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

While processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.
    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.
- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.

:::tip
Understanding correct conversation structure is essential for being able to properly implement
[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.
:::

## Related resources

### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](/docs/how_to/trim_messages/)
- [How to: filter messages](/docs/how_to/filter_messages/)
- [How to: merge consecutive messages of the same type](/docs/how_to/merge_message_runs/)

### Prompt templates

[Prompt Templates](/docs/concepts/prompt_templates) are responsible for formatting user input into a format that can be passed to a language model.

- [How to: use few shot examples](/docs/how_to/few_shot_examples)
- [How to: use few shot examples in chat models](/docs/how_to/few_shot_examples_chat/)
- [How to: partially format prompt templates](/docs/how_to/prompts_partial)
- [How to: compose prompts together](/docs/how_to/prompts_composition)
- [How to: use multimodal prompts](/docs/how_to/multimodal_prompts/)

### Example selectors¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q079®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:83e0b2e4-8a5b-87eb-18b4-98e8d648b159­checkpoint_nsÙ-generate:83e0b2e4-8a5b-87eb-18b4-98e8d648b159¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@765a9add842760abd11b16f22f0bfd262d42fb279a83f7b932406c0f890b36ca¢tsËAÚó+tXÉ¨trace_idÙ$b536a89e-df43-4521-a9b0-ec3f04ad1464­parent_run_idÙ$26b87d39-18f8-4738-aa92-12a7d8f872f6¦run_idÙ$b536a89e-df43-4521-a9b0-ec3f04ad1464ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ:messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two files outline strategies to trim messages to fit the context window? \nContext: ## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\nThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.\n\nA full conversation often involves a combination of two patterns of alternating messages:\n\n1. The **user** and the **assistant** representing a back-and-forth conversation.\n2. The **assistant** and **tool messages** representing an ["agentic" workflow](/docs/concepts/agents) where the assistant is invoking tools to perform specific tasks.\n\n## Managing chat history\n\nSince chat models have a maximum limit on input size, it\'s important to manage chat history and trim it as needed to avoid exceeding the [context window](/docs/concepts/chat_models/#context-window).\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\nWhile processing chat history, it\'s essential to preserve a correct conversation structure. \n\nKey guidelines for managing chat history:\n\n- The conversation should follow one of these structures:\n    - The first message is either a "user" message or a "system" message, followed by a "user" and then an "assistant" message.\n    - The last message should be either a "user" message or a "tool" message containing the result of a tool call.\n- When using [tool calling](/docs/concepts/tool_calling), a "tool" message should only follow an "assistant" message that requested the tool invocation.\n\n:::tip\nUnderstanding correct conversation structure is essential for being able to properly implement\n[memory](https://langchain-ai.github.io/langgraph/concepts/memory/) in chat models.\n:::\n\n## Related resources\n\n### Messages\n\n[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.\n\n- [How to: trim messages](/docs/how_to/trim_messages/)\n- [How to: filter messages](/docs/how_to/filter_messages/)\n- [How to: merge consecutive messages of the same type](/docs/how_to/merge_message_runs/)\n\n### Prompt templates\n\n[Prompt Templates](/docs/concepts/prompt_templates) are responsible for formatting user input into a format that can be passed to a language model.\n\n- [How to: use few shot examples](/docs/how_to/few_shot_examples)\n- [How to: use few shot examples in chat models](/docs/how_to/few_shot_examples_chat/)\n- [How to: partially format prompt templates](/docs/how_to/prompts_partial)\n- [How to: compose prompts together](/docs/how_to/prompts_composition)\n- [How to: use multimodal prompts](/docs/how_to/multimodal_prompts/)\n\n### Example selectors \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@14f5060988121f58afb935568be06367d8f2b50998783c3aed895ec6c7160b53¢tsËAÚó+É‹*¨focus_msÍ2§payload‚¤role©assistant§contentÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."ªfocus_kind¬exec_latency¨query_id¤Q079‰¢idÙ@6aaab1db735bd6707f8c035445cefba28e28bb26a33d72a7eccb962f77acd6f4¢tsËAÚó+É£“¨trace_idÙ$26b87d39-18f8-4738-aa92-12a7d8f872f6­parent_run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2¦run_idÙ$26b87d39-18f8-4738-aa92-12a7d8f872f6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."¨query_id¤Q079ªfocus_kind¶chain_execution_result‰¢idÙ@d9a105383f4068f1104861a588109f473cd2e9c517c4ec9b664386717e8b3d7e¢tsËAÚó+É°ó¨trace_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2­parent_run_idÀ¦run_idÙ$94430d9f-0c37-4ad2-a870-53f1658b96e2ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙNWhich two files outline strategies to trim messages to fit the context window?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙËThe **assistant** may respond directly to the user or if configured with tools request that a [tool](/docs/concepts/tool_calling) be invoked to perform a specific task.

A full conversation often invo...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËWhile processing chat history, it's essential to preserve a correct conversation structure. 

Key guidelines for managing chat history:

- The conversation should follow one of these structures:
    -...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Messages

[Messages](/docs/concepts/messages) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.

- [How to: trim messages](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÙ‰The two files that outline strategies to trim messages to fit the context window are "How to trim messages" and "How to filter messages."¨query_id¤Q079ªfocus_kind¶chain_execution_result‹¢idÙ@3e30f2de51da26972225c9da84552f145e90e4402109e22dcc1ff81efd2f8872¢tsËAÚó+É¹0¨trace_id¤Q080­parent_run_idÀ¦run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?¨query_id¤Q080§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q080ªfocus_kind¯chain_execution‹¢idÙ@4ed01d4e5988309360b7397159dddf2aeea7ffe60095744c13c5467e9e5c7c43¢tsËAÚó+ÉÃÆ¨trace_id¤Q080­parent_run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2¦run_idÙ$3fade685-4847-4528-9fc5-53cd95018169ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context¦answer ¨query_id¤Q080¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q080®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e44a737e-845c-7d72-51ed-99f507d11036ªfocus_kind¯chain_execution‰¢idÙ@9192817084ef00cd6d23001cc98a7c8c21af4f348616ff9ac3fba36737b7d95b¢tsËAÚó+ÚjI¨trace_idÙ$3fade685-4847-4528-9fc5-53cd95018169­parent_run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2¦run_idÙ$3fade685-4847-4528-9fc5-53cd95018169ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q080ªfocus_kind¶chain_execution_result‹¢idÙ@a07f115d47aac71c2a9f985211dd1b00b44f01d83e805a483b7c7c0e8ce6c324¢tsËAÚó+Úr†¨trace_id¤Q080­parent_run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2¦run_idÙ$209bcebb-ca5f-4bdc-a5e5-a6427d557580ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q080¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q080®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:b72d7365-179b-5fae-27af-68725024b9d5ªfocus_kind¯chain_execution‹¢idÙ@f10bccb9367335729df0d1dc470bb239852ce36d9f3264e0729f80f5db209de3¢tsËAÚó+Úy§¨trace_id¤Q080­parent_run_idÙ$209bcebb-ca5f-4bdc-a5e5-a6427d557580¦run_idÙ$51e1f3ea-0445-4f23-a725-0348583dd407ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§contextÚ—1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.

### Setting max concurrency

If using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.


:::tip
If you're trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.

## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. Please read more about
the technique in the [structured outputs](/docs/concepts/structured_outputs) guide.

## Multimodality

Large Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).

Currently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.

## Context window

A chat model's context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q080®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:b72d7365-179b-5fae-27af-68725024b9d5­checkpoint_nsÙ-generate:b72d7365-179b-5fae-27af-68725024b9d5¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@a0c6b2266924ccd9c24d7471f250503f0be43e6bc2016886cc498a55150d2da0¢tsËAÚó+Ú‚E¨trace_idÙ$51e1f3ea-0445-4f23-a725-0348583dd407­parent_run_idÙ$209bcebb-ca5f-4bdc-a5e5-a6427d557580¦run_idÙ$51e1f3ea-0445-4f23-a725-0348583dd407ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚtmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does the `max_concurrency` field not control when using a ChatModel? \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nSome Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.\n\n### Setting max concurrency\n\nIf using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.\n\n\n:::tip\nIf you\'re trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.\n\n## Structured outputs\n\nChat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely\nuseful for information extraction tasks. Please read more about\nthe technique in the [structured outputs](/docs/concepts/structured_outputs) guide.\n\n## Multimodality\n\nLarge Language Models (LLMs) are not limited to processing text. They can also be used to process other types of data, such as images, audio, and video. This is known as [multimodality](/docs/concepts/multimodality).\n\nCurrently, only some LLMs support multimodal inputs, and almost none support multimodal outputs. Please consult the specific model documentation for details.\n\n## Context window\n\nA chat model\'s context window refers to the maximum size of the input sequence the model can process at one time. While the context windows of modern LLMs are quite large, they still present a limitation that developers must keep in mind when working with chat models.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@00e914f9112bd0b61dd0ce94409bbd593ccbf4d04f813105adfaea19257fe646¢tsËAÚó,Y”Ğ¨focus_msÍÁ§payload‚¤role©assistant§contentÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.ªfocus_kind¬exec_latency¨query_id¤Q080‰¢idÙ@e15056a64d76539e32cf038c30941eb147859763fde3a8d7cd38256f0bc30379¢tsËAÚó,Y£8¨trace_idÙ$209bcebb-ca5f-4bdc-a5e5-a6427d557580­parent_run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2¦run_idÙ$209bcebb-ca5f-4bdc-a5e5-a6427d557580ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.¨query_id¤Q080ªfocus_kind¶chain_execution_result‰¢idÙ@7378f1f481108c3a0d1a32017129f8fd50dcd96aecade31fa2facae0a46c8bfa¢tsËAÚó,Yª§¨trace_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2­parent_run_idÀ¦run_idÙ$78064da3-f7fd-418c-ab73-f90581e59bd2ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIWhat does the `max_concurrency` field not control when using a ChatModel?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Structured outputs

Chat models can be requested to respond in a particular format (e.g., JSON or matching a particular schema). This feature is extremely
useful for information extraction tasks. P...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚœThe `max_concurrency` field does not control the rate at which requests are made to the model provider; that is managed by the `rate_limiter` parameter. Additionally, it does not affect the number of retries allowed after hitting a rate limit, which is controlled by the `max_retries` parameter. Essentially, `max_concurrency` is focused on parallel calls, while rate limiting and retries are handled separately.¨query_id¤Q080ªfocus_kind¶chain_execution_result‹¢idÙ@fdeb14f8a5e34d5057e4ec8bef81799729b02fb8cea1b2bd289b4f51f7576140¢tsËAÚó,Y±G¨trace_id¤Q081­parent_run_idÀ¦run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?¨query_id¤Q081§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q081ªfocus_kind¯chain_execution‹¢idÙ@bfef662b63845c36d451c514820a1eb64fb4766ceba2fdc679652af6b9679ab3¢tsËAÚó,Yº„¨trace_id¤Q081­parent_run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8¦run_idÙ$67610f02-1448-4609-8b90-1957dd4b59feªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context¦answer ¨query_id¤Q081¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q081®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:f73bcf08-86cc-ed6e-9d09-10d6c710a975ªfocus_kind¯chain_execution‰¢idÙ@c2ee447944417a5f9b19462cdb6eed49bf104a779a60bb689f3611991832a334¢tsËAÚó,gös¨trace_idÙ$67610f02-1448-4609-8b90-1957dd4b59fe­parent_run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8¦run_idÙ$67610f02-1448-4609-8b90-1957dd4b59feªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¨query_id¤Q081ªfocus_kind¶chain_execution_result‹¢idÙ@4fb473a66dd249b9abe6433623a95be699698bf26ef7a3e483dcf121d20b666d¢tsËAÚó,h ¨trace_id¤Q081­parent_run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8¦run_idÙ$9d9a2a61-2592-4e9d-a26f-032f6ece16b5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¦answer ¨query_id¤Q081¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q081®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:db16a2a4-87cb-c983-6132-309a97440543ªfocus_kind¯chain_execution‹¢idÙ@0ab5cdaadbc27e7191eea6e8192ce8f459c3123cd17245d700ae6789be7e3633¢tsËAÚó,h¯¨trace_id¤Q081­parent_run_idÙ$9d9a2a61-2592-4e9d-a26f-032f6ece16b5¦run_idÙ$38d45049-6a5c-4ef9-8bbe-782d711f9fc2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§contextÚ[- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How to: pass tool outputs to chat models](/docs/how_to/tool_results_pass_to_model)
- [How to: pass run time values to tools](/docs/how_to/tool_runtime)
- [How to: add a human-in-the-loop for tools](/docs/how_to/tools_human)
- [How to: handle tool errors](/docs/how_to/tools_error)
- [How to: force models to call a tool](/docs/how_to/tool_choice)
- [How to: disable parallel tool calling](/docs/how_to/tool_calling_parallel)
- [How to: access the `RunnableConfig` from a tool](/docs/how_to/tool_configure)
- [How to: stream events from a tool](/docs/how_to/tool_stream_events)
- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)

- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_model_caching)
- [How to: get log probabilities](/docs/how_to/logprobs)
- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)
- [How to: stream a response back](/docs/how_to/chat_streaming)
- [How to: track token usage](/docs/how_to/chat_token_usage_tracking)
- [How to: track response metadata across providers](/docs/how_to/response_metadata)
- [How to: use chat model to call tools](/docs/how_to/tool_calling)
- [How to: stream tool calls](/docs/how_to/tool_streaming)
- [How to: handle rate limits](/docs/how_to/chat_model_rate_limiting)
- [How to: few shot prompt tool behavior](/docs/how_to/tools_few_shot)
- [How to: bind model-specific formatted tools](/docs/how_to/tools_model_specific)
- [How to: force a specific tool call](/docs/how_to/tool_choice)

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.
* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).

:::

## Best practices

When designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:

- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)
- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)

# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.
But what about cases where we want a model to also interact *directly* with systems, such as databases or an API?
These systems often have a particular input schema; for example, APIs frequently have a required payload structure.
This need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.

:::info
You will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. 
:::

![Conceptual overview of tool calling](/img/tool_calling_concept.png)

## Key concepts¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q081®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:db16a2a4-87cb-c983-6132-309a97440543­checkpoint_nsÙ-generate:db16a2a4-87cb-c983-6132-309a97440543¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d1280120b68173306e468600fe2c91355b26ca0ce4568bf33012662fd482eae1¢tsËAÚó,h¨trace_idÙ$38d45049-6a5c-4ef9-8bbe-782d711f9fc2­parent_run_idÙ$9d9a2a61-2592-4e9d-a26f-032f6ece16b5¦run_idÙ$38d45049-6a5c-4ef9-8bbe-782d711f9fc2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚCmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which document explains how to call tools in parallel with OpenAI? \nContext: - [How to: create tools](/docs/how_to/custom_tools)\n- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)\n- [How to: use chat models to call tools](/docs/how_to/tool_calling)\n- [How to: pass tool outputs to chat models](/docs/how_to/tool_results_pass_to_model)\n- [How to: pass run time values to tools](/docs/how_to/tool_runtime)\n- [How to: add a human-in-the-loop for tools](/docs/how_to/tools_human)\n- [How to: handle tool errors](/docs/how_to/tools_error)\n- [How to: force models to call a tool](/docs/how_to/tool_choice)\n- [How to: disable parallel tool calling](/docs/how_to/tool_calling_parallel)\n- [How to: access the `RunnableConfig` from a tool](/docs/how_to/tool_configure)\n- [How to: stream events from a tool](/docs/how_to/tool_stream_events)\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n\n- [How to: do function/tool calling](/docs/how_to/tool_calling)\n- [How to: get models to return structured output](/docs/how_to/structured_output)\n- [How to: cache model responses](/docs/how_to/chat_model_caching)\n- [How to: get log probabilities](/docs/how_to/logprobs)\n- [How to: create a custom chat model class](/docs/how_to/custom_chat_model)\n- [How to: stream a response back](/docs/how_to/chat_streaming)\n- [How to: track token usage](/docs/how_to/chat_token_usage_tracking)\n- [How to: track response metadata across providers](/docs/how_to/response_metadata)\n- [How to: use chat model to call tools](/docs/how_to/tool_calling)\n- [How to: stream tool calls](/docs/how_to/tool_streaming)\n- [How to: handle rate limits](/docs/how_to/chat_model_rate_limiting)\n- [How to: few shot prompt tool behavior](/docs/how_to/tools_few_shot)\n- [How to: bind model-specific formatted tools](/docs/how_to/tools_model_specific)\n- [How to: force a specific tool call](/docs/how_to/tool_choice)\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.\n* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).\n\n:::\n\n## Best practices\n\nWhen designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:\n\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)\n- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)\n\n# Tool calling\n\n:::info[Prerequisites]\n* [Tools](/docs/concepts/tools)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n\n## Overview \n\nMany AI applications interact directly with humans. In these cases, it is appropriate for models to respond in natural language.\nBut what about cases where we want a model to also interact *directly* with systems, such as databases or an API?\nThese systems often have a particular input schema; for example, APIs frequently have a required payload structure.\nThis need motivates the concept of *tool calling*. You can use [tool calling](https://platform.openai.com/docs/guides/function-calling/example-use-cases) to request model responses that match a particular schema.\n\n:::info\nYou will sometimes hear the term `function calling`. We use this term interchangeably with `tool calling`. \n:::\n\n![Conceptual overview of tool calling](/img/tool_calling_concept.png)\n\n## Key concepts \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@893f396c45d1161a3140bd41030a3a7ea345e827fea3cffe478ac9ce31a12fa4¢tsËAÚó,½¨focus_msÍ8§payload‚¤role©assistant§contentÙÿThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context provided. For more details on tool calling in general, refer to "How to: use chat models to call tools."ªfocus_kind¬exec_latency¨query_id¤Q081‰¢idÙ@4c3d273ad28c50405a5861077743e88fd7de46eed1a263f7acb718788c26a236¢tsËAÚó,½°T¨trace_idÙ$9d9a2a61-2592-4e9d-a26f-032f6ece16b5­parent_run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8¦run_idÙ$9d9a2a61-2592-4e9d-a26f-032f6ece16b5ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÿThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context provided. For more details on tool calling in general, refer to "How to: use chat models to call tools."¨query_id¤Q081ªfocus_kind¶chain_execution_result‰¢idÙ@e450dc7e8a483d189a09401113fbd51195f622b6d88ba970888c03eb05651a59¢tsËAÚó,½¸å¨trace_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8­parent_run_idÀ¦run_idÙ$9ffd9b79-6672-4a82-bb80-b0b762d394d8ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙBWhich document explains how to call tools in parallel with OpenAI?§context•‚´page_content_summaryÙË- [How to: create tools](/docs/how_to/custom_tools)
- [How to: use built-in tools and toolkits](/docs/how_to/tools_builtin)
- [How to: use chat models to call tools](/docs/how_to/tool_calling)
- [How ...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- [How to: do function/tool calling](/docs/how_to/tool_calling)
- [How to: get models to return structured output](/docs/how_to/structured_output)
- [How to: cache model responses](/docs/how_to/chat_m...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Tool calling

:::info[Prerequisites]
* [Tools](/docs/concepts/tools)
* [Chat Models](/docs/concepts/chat_models)
:::


## Overview 

Many AI applications interact directly with humans. In these case...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx¦answerÙÿThe document that explains how to call tools in parallel with OpenAI is titled "How to: disable parallel tool calling." You can find it in the context provided. For more details on tool calling in general, refer to "How to: use chat models to call tools."¨query_id¤Q081ªfocus_kind¶chain_execution_result‹¢idÙ@e658cf3f7285605f1cb54f758484f1b3aa2a529d7346e9a8326523f2a4085cb3¢tsËAÚó,½Á¨¨trace_id¤Q082­parent_run_idÀ¦run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.¨query_id¤Q082§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q082ªfocus_kind¯chain_execution‹¢idÙ@972f35cd6dd0a608eb1a0946866fa3b5cfd06bd86bbeed913c809e58219c8da4¢tsËAÚó,½Ğ‘¨trace_id¤Q082­parent_run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7¦run_idÙ$af260ca0-4023-4744-8b7c-927f4afcb90aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context¦answer ¨query_id¤Q082¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q082®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:9fff3a29-5c55-f5c0-78a0-c8729f883806ªfocus_kind¯chain_execution‰¢idÙ@08d884204eb7cc34c1293205a3f23b0d8a50a745bcf3b6aa1c14cf953c1c16fd¢tsËAÚó,Ø…¨trace_idÙ$af260ca0-4023-4744-8b7c-927f4afcb90a­parent_run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7¦run_idÙ$af260ca0-4023-4744-8b7c-927f4afcb90aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q082ªfocus_kind¶chain_execution_result‹¢idÙ@906973bf7b268e07c395d6499108521bddf0c487da9968a380b5aa0759b2b321¢tsËAÚó,Ø&y¨trace_id¤Q082­parent_run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7¦run_idÙ$f5e64fc7-3438-4ef3-8403-e668f8af5527ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q082¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q082®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:00d73f6d-ec29-c9ba-8c50-aff370d74cb3ªfocus_kind¯chain_execution‹¢idÙ@26e4de4cb6a8008aa81ce791924465d161babba2d12e149342b45e8400fddfba¢tsËAÚó,Ø+_¨trace_id¤Q082­parent_run_idÙ$f5e64fc7-3438-4ef3-8403-e668f8af5527¦run_idÙ$918940bc-8012-481a-831e-d6292d0dfb69ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§contextÚË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.

For example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
chain = RunnableSequence([RunnableParallel(mapping), runnable3])
```

:::caution
You have to be careful because the `mapping` dictionary is not a `RunnableParallel` object, it is just a dictionary. This means that the following code will raise an `AttributeError`:

```python
mapping.invoke(some_input)
```
:::

#### Function to RunnableLambda

Inside an LCEL expression, a function is automatically converted to a `RunnableLambda`.

```
def some_func(x):
    return x

chain = some_func | runnable1
```

It gets automatically converted to the following:

```python
chain = RunnableSequence([RunnableLambda(some_func), runnable1])
```

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)
and is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.
:::

Sometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.

To simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q082®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:00d73f6d-ec29-c9ba-8c50-aff370d74cb3­checkpoint_nsÙ-generate:00d73f6d-ec29-c9ba-8c50-aff370d74cb3¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@11206f8f2fee33c55df8d9f41c2a0860aa59c748d9636b357ef31efaa54f49dc¢tsËAÚó,Ø3Y¨trace_idÙ$918940bc-8012-481a-831e-d6292d0dfb69­parent_run_idÙ$f5e64fc7-3438-4ef3-8403-e668f8af5527¦run_idÙ$918940bc-8012-481a-831e-d6292d0dfb69ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÌmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe how `RunnableGenerator` differs from `RunnableLambda`. \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.\n\nFor example, the following code:\n\n```python\nmapping = {\n    "key1": runnable1,\n    "key2": runnable2,\n}\n\nchain = mapping | runnable3\n```\n\nIt gets automatically converted to the following:\n\n```python\nchain = RunnableSequence([RunnableParallel(mapping), runnable3])\n```\n\n:::caution\nYou have to be careful because the `mapping` dictionary is not a `RunnableParallel` object, it is just a dictionary. This means that the following code will raise an `AttributeError`:\n\n```python\nmapping.invoke(some_input)\n```\n:::\n\n#### Function to RunnableLambda\n\nInside an LCEL expression, a function is automatically converted to a `RunnableLambda`.\n\n```\ndef some_func(x):\n    return x\n\nchain = some_func | runnable1\n```\n\nIt gets automatically converted to the following:\n\n```python\nchain = RunnableSequence([RunnableLambda(some_func), runnable1])\n```\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n## Configurable runnables\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n\nIt helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel)\nand is leveraged by [LangServe](/docs/concepts/architecture#langserve) for deployed Runnables.\n:::\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things with your Runnable. This could involve adjusting parameters like the temperature in a chat model or even switching between different chat models.\n\nTo simplify this process, the Runnable interface provides two methods for creating configurable Runnables at runtime: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@97e38ea58b457dffd56baeaba0fc01542af73d90d08a7dea2253f1504b0be1c2¢tsËAÚó-JK¨focus_msÍó§payload‚¤role©assistant§contentÚ´`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their tasks. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.ªfocus_kind¬exec_latency¨query_id¤Q082‰¢idÙ@eb713242a54b01cf789616b3f481f2c683a4772c0d169e95edc2032cbe877778¢tsËAÚó-J+Ã¨trace_idÙ$f5e64fc7-3438-4ef3-8403-e668f8af5527­parent_run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7¦run_idÙ$f5e64fc7-3438-4ef3-8403-e668f8af5527ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ´`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their tasks. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.¨query_id¤Q082ªfocus_kind¶chain_execution_result‰¢idÙ@6eacd1174306f60f4476c724d58bd62aa980f313455d9616807da1b017b44213¢tsËAÚó-J0ø¨trace_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7­parent_run_idÀ¦run_idÙ$ffcd0fc7-aae4-4e48-b2a1-c6c3e5bcecf7ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ?Describe how `RunnableGenerator` differs from `RunnableLambda`.§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËFor example, the following code:

```python
mapping = {
    "key1": runnable1,
    "key2": runnable2,
}

chain = mapping | runnable3
```

It gets automatically converted to the following:

```python
c...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Configurable runnables

:::note
This is an advanced feature that is unnecessary for most users.

It helps with configuration of large "chains" created using the [LangChain Expression Language (LCEL...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚ´`RunnableLambda` is designed for simple transformations where streaming is not required, while `RunnableGenerator` is intended for more complex transformations that involve streaming. This distinction allows developers to choose the appropriate runnable based on the complexity and requirements of their tasks. In summary, use `RunnableLambda` for straightforward tasks and `RunnableGenerator` when streaming capabilities are necessary.¨query_id¤Q082ªfocus_kind¶chain_execution_result‹¢idÙ@200c00824d6daf22c677b0da0ee6f221ddbba1e4edbb7eb22fece68199528c7c¢tsËAÚó-J5.¨trace_id¤Q083­parent_run_idÀ¦run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?¨query_id¤Q083§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q083ªfocus_kind¯chain_execution‹¢idÙ@e14bed7cd16e94c17ad961b614e04d89eecb82398321304cdf03bcde6b85e97c¢tsËAÚó-J;½¨trace_id¤Q083­parent_run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0f¦run_idÙ$365fed70-7435-4156-a615-844aa35c8f0aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context¦answer ¨query_id¤Q083¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q083®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e8c6858f-59c7-ef46-8c92-8364cfa69bc1ªfocus_kind¯chain_execution‰¢idÙ@0b982ec760c67b7b86c6dc07657ec740f56fa8d0976c3f985a9fd89c943e3162¢tsËAÚó-[¨trace_idÙ$365fed70-7435-4156-a615-844aa35c8f0a­parent_run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0f¦run_idÙ$365fed70-7435-4156-a615-844aa35c8f0aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¨query_id¤Q083ªfocus_kind¶chain_execution_result‹¢idÙ@94e328a06fe016c398eee348b70b8de273a22b789187b5edec127325fdf1b147¢tsËAÚó-[Å¨trace_id¤Q083­parent_run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0f¦run_idÙ$3a9f0faf-c5c5-4084-acf7-f25dd183dd04ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answer ¨query_id¤Q083¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q083®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3a02076a-651c-ac29-684c-43de82fa8d11ªfocus_kind¯chain_execution‹¢idÙ@a2407044a17a45d9dcc45230b07bf80f7b096ed5c62e058de744acb1130737b1¢tsËAÚó-[ ¨trace_id¤Q083­parent_run_idÙ$3a9f0faf-c5c5-4084-acf7-f25dd183dd04¦run_idÙ$4901103a-f96c-4265-94ef-2363b0842d0bªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Which vector store integration supports time weighted relevance?§contextÚèThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, such as text, images, and audio, to retrieve relevant information based on semantic similarity rather than exact keyword matches.

![Vector stores](/img/vectorstores.png)

## Integrations

LangChain has a large number of vectorstore integrations, allowing users to easily switch between different vectorstore implementations.

Please see the [full list of LangChain vectorstore integrations](/docs/integrations/vectorstores/).

## Interface

LangChain provides a standard interface for working with vector stores, allowing users to easily switch between different vectorstore implementations.

The interface consists of basic methods for writing, deleting and searching for documents in the vector store.

The key methods are:

::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview.  
In short, rather than using word frequencies, vectorstores use an [embedding model](/docs/concepts/embedding_models/) to compress documents into high-dimensional vector representation. 
This allows for efficient similarity search over embedding vectors using simple mathematical operations like cosine similarity.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/vectorstore_retriever/) for more details on working with vectorstores.
* See our [list of vectorstore integrations](/docs/integrations/vectorstores/).
* See Cameron Wolfe's [blog post](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2) on the basics of vector search.

:::

#### Relational databases

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

### Vector store 

[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. 
A vectorstore can be used as a retriever by calling the `as_retriever()` method.

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble

# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/docs/concepts/text_splitters/)

:::
:::info[Note]

This conceptual overview focuses on text-based indexing and retrieval for simplicity. 
However, embedding models can be [multi-modal](https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings)
and vector stores can be used to store and retrieve a variety of data types beyond text.
:::

## Overview

Vector stores are specialized data stores that enable indexing and retrieving information based on vector representations.

These vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

As use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q083®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3a02076a-651c-ac29-684c-43de82fa8d11­checkpoint_nsÙ-generate:3a02076a-651c-ac29-684c-43de82fa8d11¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@16edd0100bf928aba32209e0392be420d54493ad6011d41ae9caa637dcbf942b¢tsËAÚó-[(„¨trace_idÙ$4901103a-f96c-4265-94ef-2363b0842d0b­parent_run_idÙ$3a9f0faf-c5c5-4084-acf7-f25dd183dd04¦run_idÙ$4901103a-f96c-4265-94ef-2363b0842d0bªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÜmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which vector store integration supports time weighted relevance? \nContext: These vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.\n\nVector stores are frequently used to search over unstructured data, such as text, images, and audio, to retrieve relevant information based on semantic similarity rather than exact keyword matches.\n\n![Vector stores](/img/vectorstores.png)\n\n## Integrations\n\nLangChain has a large number of vectorstore integrations, allowing users to easily switch between different vectorstore implementations.\n\nPlease see the [full list of LangChain vectorstore integrations](/docs/integrations/vectorstores/).\n\n## Interface\n\nLangChain provides a standard interface for working with vector stores, allowing users to easily switch between different vectorstore implementations.\n\nThe interface consists of basic methods for writing, deleting and searching for documents in the vector store.\n\nThe key methods are:\n\n::: \n\n#### Vector indexes\n\nVector indexes are an alternative way to index and store unstructured data.\nSee our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview.  \nIn short, rather than using word frequencies, vectorstores use an [embedding model](/docs/concepts/embedding_models/) to compress documents into high-dimensional vector representation. \nThis allows for efficient similarity search over embedding vectors using simple mathematical operations like cosine similarity.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/vectorstore_retriever/) for more details on working with vectorstores.\n* See our [list of vectorstore integrations](/docs/integrations/vectorstores/).\n* See Cameron Wolfe\'s [blog post](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2) on the basics of vector search.\n\n:::\n\n#### Relational databases\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n### Vector store \n\n[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. \nA vectorstore can be used as a retriever by calling the `as_retriever()` method.\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble\n\n# Vector stores\n<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>\n\n:::info[Prerequisites]\n\n* [Embeddings](/docs/concepts/embedding_models/)\n* [Text splitters](/docs/concepts/text_splitters/)\n\n:::\n:::info[Note]\n\nThis conceptual overview focuses on text-based indexing and retrieval for simplicity. \nHowever, embedding models can be [multi-modal](https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-multimodal-embeddings)\nand vector stores can be used to store and retrieve a variety of data types beyond text.\n:::\n\n## Overview\n\nVector stores are specialized data stores that enable indexing and retrieving information based on vector representations.\n\nThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.\n\nAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ac2cd32fc51ef6c6b4d31127eabbeb8a7fe187208aa688900f925f02297eea29¢tsËAÚó-¦T¨focus_msÍ$§payload‚¤role©assistant§contentÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.ªfocus_kind¬exec_latency¨query_id¤Q083‰¢idÙ@b7c859888dc9d7e75f16948308c582fb8a1522fa3fadf0c18147573b65ab17ba¢tsËAÚó-­S¨trace_idÙ$3a9f0faf-c5c5-4084-acf7-f25dd183dd04­parent_run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0f¦run_idÙ$3a9f0faf-c5c5-4084-acf7-f25dd183dd04ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.¨query_id¤Q083ªfocus_kind¶chain_execution_result‰¢idÙ@6f7ec3b3e537a1668738496838fc7b4da992f19b91f45af5fdf5dd22d77a64fc¢tsËAÚó-²¨trace_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0f­parent_run_idÀ¦run_idÙ$2af79e8b-4146-4c6a-b22d-5e1f2331fe0fªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Which vector store integration supports time weighted relevance?§context•‚´page_content_summaryÙËThese vectors, called [embeddings](/docs/concepts/embedding_models/), capture the semantic meaning of data that has been embedded.

Vector stores are frequently used to search over unstructured data, ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË::: 

#### Vector indexes

Vector indexes are an alternative way to index and store unstructured data.
See our conceptual guide on [vectorstores](/docs/concepts/vectorstores/) for a detailed overview....¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË# Vector stores
<span data-heading-keywords="vector,vectorstore,vectorstores,vector store,vector stores"></span>

:::info[Prerequisites]

* [Embeddings](/docs/concepts/embedding_models/)
* [Text split...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙÁAs use cases involving multimodal search and retrieval tasks become more common, we expect to expand the vector store interface to accommodate other data types like images, audio, and video....¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/multimodality.mdx¦answerÙ‹The retrieved context does not specify which vector store integration supports time weighted relevance. Therefore, I don't know the answer.¨query_id¤Q083ªfocus_kind¶chain_execution_result‹¢idÙ@45e7e913a56728fa9a96bc5366649d3ed2f64f7adb2a53649acf26b30f16c480¢tsËAÚó-¶W¨trace_id¤Q084­parent_run_idÀ¦run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.¨query_id¤Q084§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q084ªfocus_kind¯chain_execution‹¢idÙ@ec55b1eef760cb4464bfd01b7f8b62ee4e7e00cfa0593ce3fc7196d07e2c5ba9¢tsËAÚó-½ğ¨trace_id¤Q084­parent_run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfa¦run_idÙ$dea9b3ee-812f-4ffe-bbae-e3223ac99191ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context¦answer ¨query_id¤Q084¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q084®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d020836e-b278-b83b-e54e-13f49d638d75ªfocus_kind¯chain_execution‰¢idÙ@b4d25448476c9d70e1c8ddb8d19cbde28754edd722af2c30a8d25bf982bc13ab¢tsËAÚó-¡á¨¨trace_idÙ$dea9b3ee-812f-4ffe-bbae-e3223ac99191­parent_run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfa¦run_idÙ$dea9b3ee-812f-4ffe-bbae-e3223ac99191ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q084ªfocus_kind¶chain_execution_result‹¢idÙ@b25c88683a57d8dd32127d175674070d0b1841c97c280ebcdac0540323e81fe6¢tsËAÚó-¡è¨trace_id¤Q084­parent_run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfa¦run_idÙ$133b3d45-8558-48d6-9922-71cfb3edadefªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q084¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q084®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e4648089-c327-49f5-e311-556b6c05b641ªfocus_kind¯chain_execution‹¢idÙ@db2ead0489f248fd7ba5632fd6461ca2accf0ceec0b093115384ec26433e942a¢tsËAÚó-¡í_¨trace_id¤Q084­parent_run_idÙ$133b3d45-8558-48d6-9922-71cfb3edadef¦run_idÙ$62a1237c-72fd-4c7a-b52e-40cb5cc3857fªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§contextÚ„## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.

LangSmith documentation is hosted on a separate site.
You can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).

### Evaluation

LangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:

- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)

### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.

The `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.

The `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.

Using these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can
filter and search on.

The attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.

# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called `runs`. These can be individual calls from a model, retriever,
tool, or sub-chains.
Tracing gives you observability inside your chains and agents, and is vital in diagnosing issues.

For a deeper dive, check out [this LangSmith conceptual guide](https://docs.smith.langchain.com/concepts/tracing).

[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like including [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/), [human-in-the-loop](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/), or [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

[LangSmith](https://docs.smith.langchain.com/) makes it possible to iterate with confidence on your applications, by providing LLM-specific observability and framework for testing and evaluating your application.

- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocation args to runnables](/docs/how_to/binding/)
- [How to: turn any function into a runnable](/docs/how_to/functions)
- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)
- [How to: configure runnable behavior at runtime](/docs/how_to/configure)
- [How to: add message history (memory) to a chain](/docs/how_to/message_history)
- [How to: route between sub-chains](/docs/how_to/routing)
- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)
- [How to: inspect runnables](/docs/how_to/inspect)
- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)
- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)

## [LangGraph](https://langchain-ai.github.io/langgraph)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q084®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e4648089-c327-49f5-e311-556b6c05b641­checkpoint_nsÙ-generate:e4648089-c327-49f5-e311-556b6c05b641¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@37d7be11f069e30f873d7d6ebd29f8ab0199d53240751e3052bbb93b8189ad01¢tsËAÚó-¡ôŒ¨trace_idÙ$62a1237c-72fd-4c7a-b52e-40cb5cc3857f­parent_run_idÙ$133b3d45-8558-48d6-9922-71cfb3edadef¦run_idÙ$62a1237c-72fd-4c7a-b52e-40cb5cc3857fªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ\messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain how to use `run_name` for easier debugging in LangSmith. \nContext: ## LangSmith\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\n\nLangSmith documentation is hosted on a separate site.\nYou can peruse [LangSmith tutorials here](https://docs.smith.langchain.com/).\n\n### Evaluation\n\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\n- [Evaluate your LLM application](https://docs.smith.langchain.com/tutorials/Developers/evaluation)\n\n### Setting custom run name, tags, and metadata\n\nThe `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metadata for a given Runnable.\n\nThe `run_name` is a string that can be used to set a custom name for the run. This name will be used in logs and other places to identify the run. It is not inherited by sub-calls.\n\nThe `tags` and `metadata` attributes are lists and dictionaries, respectively, that can be used to set custom tags and metadata for the run. These values are inherited by sub-calls.\n\nUsing these attributes can be useful for tracking and debugging runs, as they will be surfaced in [LangSmith](https://docs.smith.langchain.com/) as trace attributes that you can\nfilter and search on.\n\nThe attributes will also be propagated to [callbacks](/docs/concepts/callbacks), and will appear in streaming APIs like [astream_events](/docs/concepts/streaming) as part of each event in the stream.\n\n# Tracing\n\n<span data-heading-keywords="trace,tracing"></span>\n\nA trace is essentially a series of steps that your application takes to go from input to output.\nTraces contain individual steps called `runs`. These can be individual calls from a model, retriever,\ntool, or sub-chains.\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\nFor a deeper dive, check out [this LangSmith conceptual guide](https://docs.smith.langchain.com/concepts/tracing).\n\n[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like including [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/), [human-in-the-loop](https://langchain-ai.github.io/langgraph/concepts/human_in_the_loop/), or [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\n[LangSmith](https://docs.smith.langchain.com/) makes it possible to iterate with confidence on your applications, by providing LLM-specific observability and framework for testing and evaluating your application.\n\n- [How to: chain runnables](/docs/how_to/sequence)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: invoke runnables in parallel](/docs/how_to/parallel/)\n- [How to: add default invocation args to runnables](/docs/how_to/binding/)\n- [How to: turn any function into a runnable](/docs/how_to/functions)\n- [How to: pass through inputs from one chain step to the next](/docs/how_to/passthrough)\n- [How to: configure runnable behavior at runtime](/docs/how_to/configure)\n- [How to: add message history (memory) to a chain](/docs/how_to/message_history)\n- [How to: route between sub-chains](/docs/how_to/routing)\n- [How to: create a dynamic (self-constructing) chain](/docs/how_to/dynamic_chain/)\n- [How to: inspect runnables](/docs/how_to/inspect)\n- [How to: add fallbacks to a runnable](/docs/how_to/fallbacks)\n- [How to: pass runtime secrets to a runnable](/docs/how_to/runnable_runtime_secrets)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4eb7d82cc0d5d3c1f41466cb62023808d26d91a1053b171c702b889579e2ac50¢tsËAÚó.ê¨focus_msÍy§payload‚¤role©assistant§contentÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.ªfocus_kind¬exec_latency¨query_id¤Q084‰¢idÙ@e50c7f3f2e497922aa46ca5c12da88420789bc5161d0685f97a2a97e8ce209a7¢tsËAÚó.%İ¨trace_idÙ$133b3d45-8558-48d6-9922-71cfb3edadef­parent_run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfa¦run_idÙ$133b3d45-8558-48d6-9922-71cfb3edadefªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.¨query_id¤Q084ªfocus_kind¶chain_execution_result‰¢idÙ@8dc50aa9ba87cdcf9dd776bf4c2c53bf7479a29e7f3aacd3ac6ba9dca2643e0d¢tsËAÚó.3ü¨trace_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfa­parent_run_idÀ¦run_idÙ$8705e12f-991c-4862-be5e-ec90bbef6bfaªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Explain how to use `run_name` for easier debugging in LangSmith.§context•‚´page_content_summaryÙË## LangSmith

LangSmith allows you to closely trace, monitor and evaluate your LLM application.
It seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of you...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/tutorials/index.mdx‚´page_content_summaryÙË### Setting custom run name, tags, and metadata

The `run_name`, `tags`, and `metadata` attributes of the `RunnableConfig` dictionary can be used to set custom values for the run name, tags, and metad...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Tracing

<span data-heading-keywords="trace,tracing"></span>

A trace is essentially a series of steps that your application takes to go from input to output.
Traces contain individual steps called ...¨metadata¦sourceÙF/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tracing.mdx‚´page_content_summaryÙË[LangGraph](https://langchain-ai.github.io/langgraph/concepts/high_level/) makes it possible to orchestrate complex applications (e.g., [agents](/docs/concepts/agents/)) and provide features like incl...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË- [How to: chain runnables](/docs/how_to/sequence)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: invoke runnables in parallel](/docs/how_to/parallel/)
- [How to: add default invocati...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚhTo use `run_name` for easier debugging in LangSmith, set it as a custom string in the `RunnableConfig` dictionary for your run. This name will help identify the run in logs and other outputs, making it easier to trace and monitor your LLM application. Remember that the `run_name` is not inherited by sub-calls, so you may need to set it for each relevant run.¨query_id¤Q084ªfocus_kind¶chain_execution_result‹¢idÙ@4c84c5a284eac9b8679857f99c5c9a146fbd8790f54c1aa44e3765dc0557b332¢tsËAÚó.S*¨trace_id¤Q085­parent_run_idÀ¦run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051baªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?¨query_id¤Q085§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q085ªfocus_kind¯chain_execution‹¢idÙ@6a348384fdd6ba1df8a009914248028b3b63487cf254cf3f88c4edcb0fc21640¢tsËAÚó.o¨trace_id¤Q085­parent_run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051ba¦run_idÙ$d1068d1f-463f-43fc-9870-6e114752a6b2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context¦answer ¨query_id¤Q085¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q085®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:90dfdb98-8b00-12ea-aa34-4f2087032fb1ªfocus_kind¯chain_execution‰¢idÙ@cc5a70900191880c73ce9b9b2103daa6e1c767325bd28109116dcf1a18cf2e39¢tsËAÚó.Ç›¨trace_idÙ$d1068d1f-463f-43fc-9870-6e114752a6b2­parent_run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051ba¦run_idÙ$d1068d1f-463f-43fc-9870-6e114752a6b2ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¨query_id¤Q085ªfocus_kind¶chain_execution_result‹¢idÙ@7c2ca2ecb35f3bf538eb4c5e51208ae4e919badbf288ae76fe0a588582dde62c¢tsËAÚó.Õú¨trace_id¤Q085­parent_run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051ba¦run_idÙ$f6eae380-1c48-4a89-9c04-65b3b26deb78ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¦answer ¨query_id¤Q085¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q085®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c32f4a40-25a1-3b1a-3c3a-70b0fbd00640ªfocus_kind¯chain_execution‹¢idÙ@5f87eefe848313ec61170b488f781ae37be2bcd224d9e029655953cea0eb9e26¢tsËAÚó.Ş¨trace_id¤Q085­parent_run_idÙ$f6eae380-1c48-4a89-9c04-65b3b26deb78¦run_idÙ$5f86a136-9b05-4f3f-bba1-682c14a36935ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§contextÚ$### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don't have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.

```python
%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence

from langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader

file_path = "<filepath>"
endpoint = "<endpoint>"
key = "<key>"
loader = AzureAIDocumentIntelligenceLoader(
    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"
)

documents = loader.load()
```

## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
based service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from
digital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.

This [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.

### Prerequisite

# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.

This covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a LangChain 
[Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document)
object that we can use downstream.


## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

| Parameter      | Description                                                                                                                                                                                                                                                                                                    |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `model`        | The name or identifier of the specific AI model you want to use (e.g., `"gpt-3.5-turbo"` or `"gpt-4"`).                                                                                                                                                                                                        |

# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.

## Integrations

You can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).

## Interface

Documents loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).

Each DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.

Here's a simple example:

```python
from langchain_community.document_loaders.csv_loader import CSVLoader¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q085®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:c32f4a40-25a1-3b1a-3c3a-70b0fbd00640­checkpoint_nsÙ-generate:c32f4a40-25a1-3b1a-3c3a-70b0fbd00640¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@5b068bfac18cb6698c2d97992889c0a234913b985b76029575806d84a27eeb04¢tsËAÚó.è¨trace_idÙ$5f86a136-9b05-4f3f-bba1-682c14a36935­parent_run_idÙ$f6eae380-1c48-4a89-9c04-65b3b26deb78¦run_idÙ$5f86a136-9b05-4f3f-bba1-682c14a36935ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ!messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`? \nContext: ### Prerequisite\n\nAn Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don\'t have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.\n\n```python\n%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligence\n\nfrom langchain_community.document_loaders import AzureAIDocumentIntelligenceLoader\n\nfile_path = "<filepath>"\nendpoint = "<endpoint>"\nkey = "<key>"\nloader = AzureAIDocumentIntelligenceLoader(\n    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model="prebuilt-layout"\n)\n\ndocuments = loader.load()\n```\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning \nbased service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from\ndigital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.\n\nThis [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode="single"` or `mode="page"` to return pure texts in a single page or document split by page.\n\n### Prerequisite\n\n# How to load Microsoft Office files\n\nThe [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.\n\nThis covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a LangChain \n[Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document)\nobject that we can use downstream.\n\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\n\n| Parameter      | Description                                                                                                                                                                                                                                                                                                    |\n|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `model`        | The name or identifier of the specific AI model you want to use (e.g., `"gpt-3.5-turbo"` or `"gpt-4"`).                                                                                                                                                                                                        |\n\n# Document loaders\n<span data-heading-keywords="document loader,document loaders"></span>\n\n:::info[Prerequisites]\n\n* [Document loaders API reference](/docs/how_to/#document-loaders)\n:::\n\nDocument loaders are designed to load document objects. LangChain has hundreds of integrations with various data sources to load data from: Slack, Notion, Google Drive, etc.\n\n## Integrations\n\nYou can find available integrations on the [Document loaders integrations page](/docs/integrations/document_loaders/).\n\n## Interface\n\nDocuments loaders implement the [BaseLoader interface](https://python.langchain.com/api_reference/core/document_loaders/langchain_core.document_loaders.base.BaseLoader.html).\n\nEach DocumentLoader has its own specific parameters, but they can all be invoked in the same way with the `.load` method or `.lazy_load`.\n\nHere\'s a simple example:\n\n```python\nfrom langchain_community.document_loaders.csv_loader import CSVLoader \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@5daaaa28620f7d4ad3630abd1e3ca01ec4f5ca8d48b77088bda05cf7556e3d40¢tsËAÚó.n,¨focus_msÍ$§payload‚¤role©assistant§contentÙÊTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These parameters are essential for connecting to the Azure AI Document Intelligence resource.ªfocus_kind¬exec_latency¨query_id¤Q085‰¢idÙ@39f906b9124293d577d288fb4b44d5d85ee8b38b79703b6e49cfd14206aa4e49¢tsËAÚó.nA–¨trace_idÙ$f6eae380-1c48-4a89-9c04-65b3b26deb78­parent_run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051ba¦run_idÙ$f6eae380-1c48-4a89-9c04-65b3b26deb78ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÊTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These parameters are essential for connecting to the Azure AI Document Intelligence resource.¨query_id¤Q085ªfocus_kind¶chain_execution_result‰¢idÙ@631c6edf71bf8cbdd60148884578139b8b7863ec7b5ac5c113314bb9aa7711f1¢tsËAÚó.nNñ¨trace_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051ba­parent_run_idÀ¦run_idÙ$59a30ef4-2a5b-4f35-9406-9f4d11a051baªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙXWhich two parameters must be provided to initialize `AzureAIDocumentIntelligenceLoader`?§context•‚´page_content_summaryÙË### Prerequisite

An Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-s...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader

[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning 
b...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË# How to load Microsoft Office files

The [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, ...¨metadata¦sourceÙX/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/document_loader_office_file.mdx‚´page_content_summaryÙË| Parameter      | Description                                                                                                                                                                          ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Document loaders
<span data-heading-keywords="document loader,document loaders"></span>

:::info[Prerequisites]

* [Document loaders API reference](/docs/how_to/#document-loaders)
:::

Document load...¨metadata¦sourceÙO/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/document_loaders.mdx¦answerÙÊTo initialize `AzureAIDocumentIntelligenceLoader`, you must provide the `<endpoint>` and `<key>` parameters. These parameters are essential for connecting to the Azure AI Document Intelligence resource.¨query_id¤Q085ªfocus_kind¶chain_execution_result‹¢idÙ@60517e43d26e3b1afa308839dbc447d0a2defdfbe5c6c24513f6e9f4f255f6b7¢tsËAÚó.nWG¨trace_id¤Q086­parent_run_idÀ¦run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73beeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?¨query_id¤Q086§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q086ªfocus_kind¯chain_execution‹¢idÙ@af7f0a1fb7771dde6c5d915d5696e2ec0180d8fdf4349d8cacb6558445bbf7a8¢tsËAÚó.n_¨trace_id¤Q086­parent_run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73bee¦run_idÙ$9c22fd69-c27b-49fe-b169-a6e127eb1bfeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context¦answer ¨query_id¤Q086¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q086®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:0f92afa7-71f8-edd0-6df5-55edd19f629dªfocus_kind¯chain_execution‰¢idÙ@985761252bbe782cd190b3d27c785ee85baeca1911b6d7de41335398df864be3¢tsËAÚó.¼õ”¨trace_idÙ$9c22fd69-c27b-49fe-b169-a6e127eb1bfe­parent_run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73bee¦run_idÙ$9c22fd69-c27b-49fe-b169-a6e127eb1bfeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q086ªfocus_kind¶chain_execution_result‹¢idÙ@d9e08d8bf9829116c3cee7afaa2c16539ef4a650469bf91ba75cfd8a1f1b5e92¢tsËAÚó.¼ı¤¨trace_id¤Q086­parent_run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73bee¦run_idÙ$7ea00ce7-80ec-49d6-9e6f-56fac74462acªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q086¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q086®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2c7ed2ec-98a0-68cd-6b9c-8df0d5cb5be9ªfocus_kind¯chain_execution‹¢idÙ@8642b449cde830c630cc2605d34c391cc062c9067b9577e12d8038391297019a¢tsËAÚó.½Ş¨trace_id¤Q086­parent_run_idÙ$7ea00ce7-80ec-49d6-9e6f-56fac74462ac¦run_idÙ$1a759f69-249d-4465-8173-5d4f75786d1fªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§contextÚ>#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.



### `astream_events`
<span data-heading-keywords="astream_events,stream_events,stream events"></span>

:::tip
Use the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). 

While this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.
:::

The [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.

#### Usage with chat models

When using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM's output incrementally as it's being produced, which is particularly useful in interactive applications or interfaces.

#### Usage with LangGraph

[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.

1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): Use to stream outputs from individual Runnables (e.g., a chat model) as they are generated or stream any workflow created with LangGraph.
2. The async only [astream_events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events): Use this API to get access to custom events and intermediate outputs from LLM  applications built entirely with [LCEL](/docs/concepts/lcel). Note that this API is available, but not needed when working with LangGraph.

:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_log) API. This API is not recommended for new projects it is more complex and less feature-rich than the other streaming APIs.
:::

### `stream()` and `astream()`

The `stream()` method returns an iterator that yields chunks of output synchronously as they are produced. You can use a `for` loop to process each chunk in real-time. For example, when using an LLM, this allows the output to be streamed incrementally as it is generated, reducing the wait time for users.

model = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for event in chain.astream_events({"topic": "parrot"}):
    kind = event["event"]
    if kind == "on_chat_model_stream":
        print(event, end="|", flush=True)
```

You can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!

See [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.

## Writing custom data to the stream

To write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q086®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:2c7ed2ec-98a0-68cd-6b9c-8df0d5cb5be9­checkpoint_nsÙ-generate:2c7ed2ec-98a0-68cd-6b9c-8df0d5cb5be9¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@46e0f9c613d185919044d87e55882f926ac004287167b9638eb6e87b33d54d03¢tsËAÚó.½h¨trace_idÙ$1a759f69-249d-4465-8173-5d4f75786d1f­parent_run_idÙ$7ea00ce7-80ec-49d6-9e6f-56fac74462ac¦run_idÙ$1a759f69-249d-4465-8173-5d4f75786d1fªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the main benefit of `asam_stream` events over `astream`? \nContext: #### Usage with LCEL\n\nIf you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the output of the last step in the chain. This allows the final processed result to be streamed incrementally. **LCEL** tries to optimize streaming latency in pipelines so that the streaming results from the last step are available as soon as possible.\n\n\n\n### `astream_events`\n<span data-heading-keywords="astream_events,stream_events,stream events"></span>\n\n:::tip\nUse the `astream_events` API to access custom data and intermediate outputs from LLM applications built entirely with [LCEL](/docs/concepts/lcel). \n\nWhile this API is available for use with [LangGraph](/docs/concepts/architecture#langgraph) as well, it is usually not necessary when working with LangGraph, as the `stream` and `astream` methods provide comprehensive streaming capabilities for LangGraph graphs.\n:::\n\nThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.\n\n#### Usage with chat models\n\nWhen using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM\'s output incrementally as it\'s being produced, which is particularly useful in interactive applications or interfaces.\n\n#### Usage with LangGraph\n\n[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.\n\n1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream): Use to stream outputs from individual Runnables (e.g., a chat model) as they are generated or stream any workflow created with LangGraph.\n2. The async only [astream_events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events): Use this API to get access to custom events and intermediate outputs from LLM  applications built entirely with [LCEL](/docs/concepts/lcel). Note that this API is available, but not needed when working with LangGraph.\n\n:::note\nIn addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_log) API. This API is not recommended for new projects it is more complex and less feature-rich than the other streaming APIs.\n:::\n\n### `stream()` and `astream()`\n\nThe `stream()` method returns an iterator that yields chunks of output synchronously as they are produced. You can use a `for` loop to process each chunk in real-time. For example, when using an LLM, this allows the output to be streamed incrementally as it is generated, reducing the wait time for users.\n\nmodel = ChatAnthropic(model="claude-3-sonnet-20240229")\n\nprompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")\nparser = StrOutputParser()\nchain = prompt | model | parser\n\nasync for event in chain.astream_events({"topic": "parrot"}):\n    kind = event["event"]\n    if kind == "on_chat_model_stream":\n        print(event, end="|", flush=True)\n```\n\nYou can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!\n\nSee [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.\n\n## Writing custom data to the stream\n\nTo write custom data to the stream, you will need to choose one of the following methods based on the component you are working with: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@19d871342fb18a0f5e20dfcd6ca9cce05459ea0923b895924dde70fe1c2a7920¢tsËAÚó/&ğ¨focus_msÍh§payload‚¤role©assistant§contentÚÊThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing interactivity. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.ªfocus_kind¬exec_latency¨query_id¤Q086‰¢idÙ@4cc799451905f73609468368f4dd76a9866b1b874f773d2cc62e51db34753c93¢tsËAÚó/&&x¨trace_idÙ$7ea00ce7-80ec-49d6-9e6f-56fac74462ac­parent_run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73bee¦run_idÙ$7ea00ce7-80ec-49d6-9e6f-56fac74462acªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÊThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing interactivity. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.¨query_id¤Q086ªfocus_kind¶chain_execution_result‰¢idÙ@7a5f47863c4c4cc1111c26684445961ed3b2ae57835e03f2da59cd69021e5c9f¢tsËAÚó/&0ğ¨trace_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73bee­parent_run_idÀ¦run_idÙ$5a61fe95-9f59-4913-b1f4-65d456c73beeªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@What is the main benefit of `asam_stream` events over `astream`?§context•‚´page_content_summaryÙÍ#### Usage with LCEL

If you compose multiple Runnables using [LangChainâ€™s Expression Language (LCEL)](/docs/concepts/lcel), the `stream()` and `astream()` methods will, by convention, stream the outp...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. sync [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) and async [astream](https://python...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË:::note
In addition, there is a **legacy** async [astream_log](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runna...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚÊThe main benefit of `asam_stream` events over `astream` is that it allows access to custom data and intermediate outputs from LLM applications built with LangChain's Expression Language (LCEL). This provides more granular control and insight into the streaming process, which can be particularly useful for debugging or enhancing interactivity. In contrast, `astream` primarily focuses on streaming outputs without the additional event handling capabilities.¨query_id¤Q086ªfocus_kind¶chain_execution_result‹¢idÙ@105cb659cb4cd05adab3589953b4493a71eb29b0bbb2a2cfc27c1ab51253dcc9¢tsËAÚó/&=È¨trace_id¤Q087­parent_run_idÀ¦run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?¨query_id¤Q087§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q087ªfocus_kind¯chain_execution‹¢idÙ@58eed1f5df0e7f62fdace77c226156dd10842d1c32ccc3eb14d24b3884a8a9f4¢tsËAÚó/&Jñ¨trace_id¤Q087­parent_run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29¦run_idÙ$03416557-f1a4-447c-ba5f-59295ff86236ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context¦answer ¨query_id¤Q087¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q087®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:cb02df03-6db5-3521-8e85-3b9b2f85ab51ªfocus_kind¯chain_execution‰¢idÙ@58ff55d007ca0622f893275a206d41f8567ea2b4573070002ebc9ab90ab0a8af¢tsËAÚó/3D¨trace_idÙ$03416557-f1a4-447c-ba5f-59295ff86236­parent_run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29¦run_idÙ$03416557-f1a4-447c-ba5f-59295ff86236ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q087ªfocus_kind¶chain_execution_result‹¢idÙ@a073c455bacf592873cbed17a29b7ce604f471c076132b6b814227def06a7fa7¢tsËAÚó/3 °¨trace_id¤Q087­parent_run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29¦run_idÙ$860b95a5-4a18-4831-8f42-a379590237aaªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q087¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q087®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:09a14099-f0a7-d032-70a2-65bf10ee09c3ªfocus_kind¯chain_execution‹¢idÙ@65f45a80a1d3a49bc44c919d39519b98e217578a233f96257341647816b22ee3¢tsËAÚó/3($¨trace_id¤Q087­parent_run_idÙ$860b95a5-4a18-4831-8f42-a379590237aa¦run_idÙ$48cc6a44-2744-440b-bdda-c519114d6482ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§contextÚÜYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.

:::info[Further reading]

* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.
* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).

:::

## Best practices

When designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:

These requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples only include expected tool calls and not the actual tool outputs, you can try adding dummy ToolMessages / AIMessages to the end of each example with generic contents to satisfy the API constraints.
In these cases it's especially worth experimenting with inserting your examples as strings versus messages, as having dummy messages can adversely affect certain models.

You can see a case study of how Anthropic and OpenAI respond to different few-shot prompting techniques on two different tool calling benchmarks [here](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/).

- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)
- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets)¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q087®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:09a14099-f0a7-d032-70a2-65bf10ee09c3­checkpoint_nsÙ-generate:09a14099-f0a7-d032-70a2-65bf10ee09c3¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@b71233617b554689cd4d9cbfd53d02a6c77139e8b7ddc7695511636c210f1f20¢tsËAÚó/308¨trace_idÙ$48cc6a44-2744-440b-bdda-c519114d6482­parent_run_idÙ$860b95a5-4a18-4831-8f42-a379590237aa¦run_idÙ$48cc6a44-2744-440b-bdda-c519114d6482ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÉmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How do you specify hidden arguments in a Tool so the model cannot set them? \nContext: You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/) offers pre-built components (e.g., [`ToolNode`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#langgraph.prebuilt.tool_node.ToolNode)) that will often invoke the tool in behalf of the user.\n\n:::info[Further reading]\n\n* See our [how-to guide](/docs/how_to/tool_calling/) on tool calling.\n* See the [LangGraph documentation on using ToolNode](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/).\n\n:::\n\n## Best practices\n\nWhen designing [tools](/docs/concepts/tools/) to be used by a model, it is important to keep in mind that:\n\nThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples only include expected tool calls and not the actual tool outputs, you can try adding dummy ToolMessages / AIMessages to the end of each example with generic contents to satisfy the API constraints.\nIn these cases it\'s especially worth experimenting with inserting your examples as strings versus messages, as having dummy messages can adversely affect certain models.\n\nYou can see a case study of how Anthropic and OpenAI respond to different few-shot prompting techniques on two different tool calling benchmarks [here](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/).\n\n- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)\n- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)\n- [How to: add ad-hoc tool calling capability to models](/docs/how_to/tools_prompting)\n- [How to: pass in runtime secrets](/docs/how_to/runnable_runtime_secrets) \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@c08026897fd3060a1e53c61f37745e5af8eb3638dd492b6e3b7b61ff2aa60c4f¢tsËAÚó/ “¨focus_msÍ¬§payload‚¤role©assistant§contentÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.ªfocus_kind¬exec_latency¨query_id¤Q087‰¢idÙ@e527ea88a7421fc74c589f05ba2f9c0a38f5a5e0cb81539ec8a1d9e644a700d0¢tsËAÚó/ ›B¨trace_idÙ$860b95a5-4a18-4831-8f42-a379590237aa­parent_run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29¦run_idÙ$860b95a5-4a18-4831-8f42-a379590237aaªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.¨query_id¤Q087ªfocus_kind¶chain_execution_result‰¢idÙ@c6f1f025b7097c97e5e5031541a97424aadc588a2b8b5485ec3d0e499654f1a6¢tsËAÚó/ ¤Û¨trace_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29­parent_run_idÀ¦run_idÙ$5e80bcee-bb0a-4390-a58a-70caaaac3e29ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙKHow do you specify hidden arguments in a Tool so the model cannot set them?§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

[LangGraph]...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙËThese requirements are model-specific and should be checked for the model you are using. If your model requires ToolMessages after tool calls and/or AIMessages after ToolMessages and your examples onl...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/few_shot_prompting.mdx‚´page_content_summaryÙË- [How to: return artifacts from a tool](/docs/how_to/tool_artifacts/)
- [How to: convert Runnables to tools](/docs/how_to/convert_runnable_to_tool)
- [How to: add ad-hoc tool calling capability to mo...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚkTo specify hidden arguments in a Tool so the model cannot set them, you can use the `InjectedToolArg` annotation. This allows certain parameters to be injected manually at runtime without being exposed in the tool's schema. Other special annotations like `RunnableConfig`, `InjectedState`, and `InjectedStore` can also be used to remove arguments from the schema.¨query_id¤Q087ªfocus_kind¶chain_execution_result‹¢idÙ@522e2174149dc5feeedd07b353a1386a89e6be48b7542f789fe57c1facdfc57e¢tsËAÚó/ ­û¨trace_id¤Q088­parent_run_idÀ¦run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?¨query_id¤Q088§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q088ªfocus_kind¯chain_execution‹¢idÙ@0a3021abb4e1a061d9c93a3a12ea8b212916f617333c9ae706923e196ef3a14e¢tsËAÚó/ ½Â¨trace_id¤Q088­parent_run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97¦run_idÙ$3282c27b-b8a1-4b50-ba37-a7a494913311ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context¦answer ¨query_id¤Q088¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q088®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:b04b5aef-1ba7-49b8-258d-02a996df5e2bªfocus_kind¯chain_execution‰¢idÙ@c65ae9a172609a8705d51d3ea2c75f4c369af774f087f9a08af12f5cecdfa7d8¢tsËAÚó/ê:¨trace_idÙ$3282c27b-b8a1-4b50-ba37-a7a494913311­parent_run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97¦run_idÙ$3282c27b-b8a1-4b50-ba37-a7a494913311ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¨query_id¤Q088ªfocus_kind¶chain_execution_result‹¢idÙ@2144c9720a350eecfbb9f0a2f27070289a4792bccc2b5e53cc492668610ac130¢tsËAÚó/ê6ß¨trace_id¤Q088­parent_run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97¦run_idÙ$65981a3d-78d4-4d82-be07-e982019f5141ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answer ¨query_id¤Q088¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q088®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9628c9fc-a487-b1d9-681c-62451708b921ªfocus_kind¯chain_execution‹¢idÙ@2907d6341a561655a2f5dedf71569f86332592ee356a962f5d1119c739156541¢tsËAÚó/ê?–¨trace_id¤Q088­parent_run_idÙ$65981a3d-78d4-4d82-be07-e982019f5141¦run_idÙ$98cb7b05-2fe8-4c11-a910-3ceeb50621e5ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§contextÚÉ:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't need to actually *store* documents. 
For example, we can be built retrievers on top of search APIs that simply return search results! 
See our retriever integrations with [Amazon Kendra](/docs/integrations/retrievers/amazon_kendra_retriever/) or [Wikipedia Search](/docs/integrations/retrievers/wikipedia/). 

### Relational or graph database

Retrievers can be built on top of relational or graph databases.
In these cases, [query analysis](/docs/concepts/retrieval/) techniques to construct a structured query from natural language is critical.
For example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) retriever to be transformed into a SQL query behind the scenes.

:::info[Further reading]

You can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for databases that typically require structured query languages.
For example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) to be transformed into a SQL query behind the scenes.
Regardless of the underlying retrieval system, all retrievers in LangChain share a common interface. You can use them with the simple `invoke` method:


```python
docs = retriever.invoke(query)
```

:::info[Further reading]

* See our [conceptual guide on retrievers](/docs/concepts/retrievers/).
* See our [how-to guide](/docs/how_to/#retrievers) on working with retrievers.

:::

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/docs/concepts/text_splitters/)

:::

:::danger[Security]
 
Some of the concepts reviewed here utilize models to generate queries (e.g., for SQL or graph databases).
There are inherent risks in doing this. 
Make sure that your database connection permissions are scoped as narrowly as possible for your application's needs. 
This will mitigate, though not eliminate, the risks of building a model-driven system capable of querying databases. 
For more on general security best practices, see our [security guide](/docs/security/).

:::

## Overview 

Retrieval systems are fundamental to many AI applications, efficiently identifying relevant information from large datasets. 
These systems accommodate various data formats:

### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#query-analysis).

- [How to: add examples to the prompt](/docs/how_to/query_few_shot)
- [How to: handle cases where no queries are generated](/docs/how_to/query_no_queries)
- [How to: handle multiple queries](/docs/how_to/query_multiple_queries)
- [How to: handle multiple retrievers](/docs/how_to/query_multiple_retrievers)
- [How to: construct filters](/docs/how_to/query_constructing_filters)
- [How to: deal with high cardinality categorical variables](/docs/how_to/query_high_cardinality)

### Q&A over SQL + CSV

You can use LLMs to do question answering over tabular data.
For a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/).¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q088®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9628c9fc-a487-b1d9-681c-62451708b921­checkpoint_nsÙ-generate:9628c9fc-a487-b1d9-681c-62451708b921¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@c289df1c9e12c18ed09ea922d04111d00098f202a7a28aacf811b94509ef687a¢tsËAÚó/êH¨trace_idÙ$98cb7b05-2fe8-4c11-a910-3ceeb50621e5­parent_run_idÙ$65981a3d-78d4-4d82-be07-e982019f5141¦run_idÙ$98cb7b05-2fe8-4c11-a910-3ceeb50621e5ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚÍmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which guide demonstrates building a SQL retriever over a large database? \nContext: :::\n \n## Common types\n\nDespite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.\n\n### Search apis\n\nIt\'s important to note that retrievers don\'t need to actually *store* documents. \nFor example, we can be built retrievers on top of search APIs that simply return search results! \nSee our retriever integrations with [Amazon Kendra](/docs/integrations/retrievers/amazon_kendra_retriever/) or [Wikipedia Search](/docs/integrations/retrievers/wikipedia/). \n\n### Relational or graph database\n\nRetrievers can be built on top of relational or graph databases.\nIn these cases, [query analysis](/docs/concepts/retrieval/) techniques to construct a structured query from natural language is critical.\nFor example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) retriever to be transformed into a SQL query behind the scenes.\n\n:::info[Further reading]\n\nYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for databases that typically require structured query languages.\nFor example, you can build a retriever for a SQL database using text-to-SQL conversion. This allows a natural language query (string) to be transformed into a SQL query behind the scenes.\nRegardless of the underlying retrieval system, all retrievers in LangChain share a common interface. You can use them with the simple `invoke` method:\n\n\n```python\ndocs = retriever.invoke(query)\n```\n\n:::info[Further reading]\n\n* See our [conceptual guide on retrievers](/docs/concepts/retrievers/).\n* See our [how-to guide](/docs/how_to/#retrievers) on working with retrievers.\n\n:::\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\n# Retrieval\n\n:::info[Prerequisites]\n\n* [Retrievers](/docs/concepts/retrievers/)\n* [Vector stores](/docs/concepts/vectorstores/)\n* [Embeddings](/docs/concepts/embedding_models/)\n* [Text splitters](/docs/concepts/text_splitters/)\n\n:::\n\n:::danger[Security]\n \nSome of the concepts reviewed here utilize models to generate queries (e.g., for SQL or graph databases).\nThere are inherent risks in doing this. \nMake sure that your database connection permissions are scoped as narrowly as possible for your application\'s needs. \nThis will mitigate, though not eliminate, the risks of building a model-driven system capable of querying databases. \nFor more on general security best practices, see our [security guide](/docs/security/).\n\n:::\n\n## Overview \n\nRetrieval systems are fundamental to many AI applications, efficiently identifying relevant information from large datasets. \nThese systems accommodate various data formats:\n\n### Query analysis\n\nQuery Analysis is the task of using an LLM to generate a query to send to a retriever.\nFor a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#query-analysis).\n\n- [How to: add examples to the prompt](/docs/how_to/query_few_shot)\n- [How to: handle cases where no queries are generated](/docs/how_to/query_no_queries)\n- [How to: handle multiple queries](/docs/how_to/query_multiple_queries)\n- [How to: handle multiple retrievers](/docs/how_to/query_multiple_retrievers)\n- [How to: construct filters](/docs/how_to/query_constructing_filters)\n- [How to: deal with high cardinality categorical variables](/docs/how_to/query_high_cardinality)\n\n### Q&A over SQL + CSV\n\nYou can use LLMs to do question answering over tabular data.\nFor a high-level tutorial, check out [this guide](/docs/tutorials/sql_qa/). \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@cbee694cbfca6a1a35f17f71848c6da769965bb6d0b5f39d0710594496787cc5¢tsËAÚó09rd¨focus_msÍÔ§payload‚¤role©assistant§contentÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.ªfocus_kind¬exec_latency¨query_id¤Q088‰¢idÙ@db2561d73dbb0a6cf46a74f8d29b03bf1bd4838d182389d9f9868806cf0dab59¢tsËAÚó09“6¨trace_idÙ$65981a3d-78d4-4d82-be07-e982019f5141­parent_run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97¦run_idÙ$65981a3d-78d4-4d82-be07-e982019f5141ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.¨query_id¤Q088ªfocus_kind¶chain_execution_result‰¢idÙ@641d5dd72db3cd8e6fc326acdc283db8d2c9a7e73b2bcdb490f20cb82559bf1b¢tsËAÚó09™x¨trace_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97­parent_run_idÀ¦run_idÙ$df06e489-6cd4-4e91-8ae1-b1b35ae72f97ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙHWhich guide demonstrates building a SQL retriever over a large database?§context•‚´page_content_summaryÙË:::
 
## Common types

Despite the flexibility of the retriever interface, a few common types of retrieval systems are frequently used.

### Search apis

It's important to note that retrievers don't n...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËYou can create a retriever using any of the retrieval systems mentioned earlier. The query analysis techniques we discussed are particularly useful here, as they enable natural language interfaces for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Retrieval

:::info[Prerequisites]

* [Retrievers](/docs/concepts/retrievers/)
* [Vector stores](/docs/concepts/vectorstores/)
* [Embeddings](/docs/concepts/embedding_models/)
* [Text splitters](/doc...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË### Query analysis

Query Analysis is the task of using an LLM to generate a query to send to a retriever.
For a high-level tutorial on query analysis, check out [this guide](/docs/tutorials/rag/#quer...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx¦answerÚThe guide that demonstrates building a SQL retriever over a large database is the "Q&A over SQL + CSV" tutorial. This guide focuses on using LLMs for question answering over tabular data, including SQL databases. For more details, you can refer to the specific tutorial mentioned.¨query_id¤Q088ªfocus_kind¶chain_execution_result‹¢idÙ@c0ed841c98ef862b2773b21237b585337ff78e349c60d3a432d91c76f56354a1¢tsËAÚó09¢ô¨trace_id¤Q089­parent_run_idÀ¦run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?¨query_id¤Q089§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q089ªfocus_kind¯chain_execution‹¢idÙ@ba57bccee55c738bd704ba811fc5fb308b24fc4d9774da1336258f85554eafbb¢tsËAÚó09­÷¨trace_id¤Q089­parent_run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833¦run_idÙ$aad15925-26e6-46f7-8e6a-6c5f8630c3fcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context¦answer ¨query_id¤Q089¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q089®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:3247370c-d9b9-2f76-306d-26ffd01174f3ªfocus_kind¯chain_execution‰¢idÙ@e73f1b848ee6a81bbc2b53dcfc2285e0883e98207af308fc3e9ec0873d24688c¢tsËAÚó0Lìg¨trace_idÙ$aad15925-26e6-46f7-8e6a-6c5f8630c3fc­parent_run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833¦run_idÙ$aad15925-26e6-46f7-8e6a-6c5f8630c3fcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q089ªfocus_kind¶chain_execution_result‹¢idÙ@4dea9d90ae13393a62fdfdacf867835b15baf6d918d4c3bb370fd4a1550624dc¢tsËAÚó0Lõ©¨trace_id¤Q089­parent_run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833¦run_idÙ$c2a2e3b8-3ac3-4468-a770-19e10d704cc9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q089¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q089®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:278d6e0b-1d2e-342b-b623-92bf7818123cªfocus_kind¯chain_execution‹¢idÙ@355ca93b881cf25b2ee0d81f8d52659a9f8ab67f3e903ef1ccbd1d8f8a466148¢tsËAÚó0Lû±¨trace_id¤Q089­parent_run_idÙ$c2a2e3b8-3ac3-4468-a770-19e10d704cc9¦run_idÙ$e8a9bbd6-918e-4362-a6b8-002bae9a31a1ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§contextÚŞ### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

A semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.

However, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.

Please see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.

## Related resources

* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).
* List of supported chat models: [chat model integrations](/docs/integrations/chat/).

### Conceptual guides

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q089®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:278d6e0b-1d2e-342b-b623-92bf7818123c­checkpoint_nsÙ-generate:278d6e0b-1d2e-342b-b623-92bf7818123c¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@51e6824bc7fda3d41ac9939152a91bf7a4cc31e2270e9cbfa722fe10e00dfcf6¢tsËAÚó0M:¨trace_idÙ$e8a9bbd6-918e-4362-a6b8-002bae9a31a1­parent_run_idÙ$c2a2e3b8-3ac3-4468-a770-19e10d704cc9¦run_idÙ$e8a9bbd6-918e-4362-a6b8-002bae9a31a1ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¥messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Why is semantic caching unlikely to hit after the first chat turn? \nContext: ### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\nA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it\'s not guaranteed to capture the meaning of the input accurately.\n\nHowever, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.\n\nPlease see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.\n\n## Related resources\n\n* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).\n* List of supported chat models: [chat model integrations](/docs/integrations/chat/).\n\n### Conceptual guides\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@a0c84b88e8e7b32fc9036b123d2425c4122273cd38a39c5fd9bc0faff32d4ce2¢tsËAÚó0»ù¡¨focus_msÍÅ§payload‚¤role©assistant§contentÚªSemantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the likelihood of cache hits. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.ªfocus_kind¬exec_latency¨query_id¤Q089‰¢idÙ@67bbbe15d1b70d00afb1df228a3d966f70b65c5697943443527afb08049ff286¢tsËAÚó0¼¨trace_idÙ$c2a2e3b8-3ac3-4468-a770-19e10d704cc9­parent_run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833¦run_idÙ$c2a2e3b8-3ac3-4468-a770-19e10d704cc9ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚªSemantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the likelihood of cache hits. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.¨query_id¤Q089ªfocus_kind¶chain_execution_result‰¢idÙ@265ae5aefb3267ec519450538dac25c47a12dcbdcc55caa29b1b3ed107b6f802¢tsËAÚó0¼¨trace_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833­parent_run_idÀ¦run_idÙ$eef130f9-110a-4d66-bdee-bfdb6b6c4833ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙBWhy is semantic caching unlikely to hit after the first chat turn?§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚªSemantic caching is unlikely to hit after the first chat turn because conversations typically do not start with the exact same message, making it rare for subsequent interactions to match previous inputs. Additionally, the complexity of accurately capturing the meaning of inputs can further reduce the likelihood of cache hits. Therefore, relying on exact inputs for caching in dynamic conversations is generally ineffective.¨query_id¤Q089ªfocus_kind¶chain_execution_result‹¢idÙ@c3db10fd79f46e38e2b8774562be79beb37bb38f98cbe5f5f835f539600a229b¢tsËAÚó0¼Õ¨trace_id¤Q090­parent_run_idÀ¦run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.¨query_id¤Q090§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q090ªfocus_kind¯chain_execution‹¢idÙ@73956ff5bcb074bfb085eb79de0d052f9cd9b6d4e47d706cfc2b734db1ada980¢tsËAÚó0¼©¨trace_id¤Q090­parent_run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556¦run_idÙ$d53f9480-f795-4748-930f-25c96b98308fªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context¦answer ¨query_id¤Q090¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q090®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7e79a152-411b-9e26-6ec2-a6c24a9f0085ªfocus_kind¯chain_execution‰¢idÙ@400717ce5a463bbfad62ca0212ca5687148270190a306f14ee2418144b3697ed¢tsËAÚó0Ñ,¡¨trace_idÙ$d53f9480-f795-4748-930f-25c96b98308f­parent_run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556¦run_idÙ$d53f9480-f795-4748-930f-25c96b98308fªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¨query_id¤Q090ªfocus_kind¶chain_execution_result‹¢idÙ@0e5029bd4397dd6b5a22febe60b0f80c41cf6d5719582aa4e81f7df26877cf48¢tsËAÚó0Ñ6z¨trace_id¤Q090­parent_run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556¦run_idÙ$363c6f65-1811-4ae0-9c4c-835b76c1632eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answer ¨query_id¤Q090¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q090®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:424c6dfd-84b0-f5ce-d4cd-ca75ec03d93bªfocus_kind¯chain_execution‹¢idÙ@1a1898b995e0b8334660a4ec7471462b488676492721f2526633d65868883e1f¢tsËAÚó0Ñ<æ¨trace_id¤Q090­parent_run_idÙ$363c6f65-1811-4ae0-9c4c-835b76c1632e¦run_idÙ$20cc30cc-415b-4e3c-9f48-1843f7b0ce88ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§contextÚ_:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy, creating split that maintain natural language flow, maintain semantic coherence within split, and adapts to varying levels of text granularity.
LangChain's [`RecursiveCharacterTextSplitter`](/docs/how_to/recursive_text_splitter/) implements this concept:
- The `RecursiveCharacterTextSplitter` attempts to keep larger units (e.g., paragraphs) intact.
- If a unit exceeds the chunk size, it moves to the next level (e.g., sentences).
- This process continues down to the word level if necessary.

Here is example usage:

```python
from langchain_text_splitters import RecursiveCharacterTextSplitter
text_splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=0)
texts = text_splitter.split_text(document)
```

:::info[Further reading]

Example implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter.from_tiktoken_encoder(
    encoding_name="cl100k_base", chunk_size=100, chunk_overlap=0
)
texts = text_splitter.split_text(document)
```

:::info[Further reading]

* See the how-to guide for [token-based](/docs/how_to/split_by_token/) splitting.
* See the how-to guide for [character-based](/docs/how_to/character_text_splitter/) splitting.

:::

### Text-structured based

# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:::

## Overview

Document splitting is often a crucial preprocessing step for many applications.
It involves breaking down large texts into smaller, manageable chunks.
This process offers several benefits, such as ensuring consistent processing of varying document lengths, overcoming input size limitations of models, and improving the quality of text representations used in retrieval systems.
There are several strategies for splitting documents, each with its own advantages.

## Key concepts

![Conceptual Overview](/img/text_splitters.png)

Text splitters split documents into smaller chunks for use in downstream applications.

## Why split documents?

There are several reasons to split documents:

:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, such as HTML, Markdown, or JSON files. 
In these cases, it's beneficial to split the document based on its structure, as it often naturally groups semantically related text.
Key benefits of structure-based splitting:
- Preserves the logical organization of the document
- Maintains context within each chunk
- Can be more effective for downstream tasks like retrieval or summarization

Examples of structure-based splitting:
- **Markdown**: Split based on headers (e.g., #, ##, ###)
- **HTML**: Split using tags
- **JSON**: Split by object or array elements
- **Code**: Split by functions, classes, or logical blocks

:::info[Further reading]

:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).
* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).
* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).

:::

### Semantic meaning based

Unlike the previous methods, semantic-based splitting actually considers the *content* of the text. 
While other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.
There are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.
As an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q090®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:424c6dfd-84b0-f5ce-d4cd-ca75ec03d93b­checkpoint_nsÙ-generate:424c6dfd-84b0-f5ce-d4cd-ca75ec03d93b¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@d75b4ac19aa80ece221f7c576e9cc127c4496b5debdad20e8ce599f5f9795fb7¢tsËAÚó0ÑDñ¨trace_idÙ$20cc30cc-415b-4e3c-9f48-1843f7b0ce88­parent_run_idÙ$363c6f65-1811-4ae0-9c4c-835b76c1632e¦run_idÙ$20cc30cc-415b-4e3c-9f48-1843f7b0ce88ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚcmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe a use case for `RecursiveCharacterTextSplitter`. \nContext: :::\n\n### Text-structured based\n\nText is naturally organized into hierarchical units such as paragraphs, sentences, and words. \nWe can leverage this inherent structure to inform our splitting strategy, creating split that maintain natural language flow, maintain semantic coherence within split, and adapts to varying levels of text granularity.\nLangChain\'s [`RecursiveCharacterTextSplitter`](/docs/how_to/recursive_text_splitter/) implements this concept:\n- The `RecursiveCharacterTextSplitter` attempts to keep larger units (e.g., paragraphs) intact.\n- If a unit exceeds the chunk size, it moves to the next level (e.g., sentences).\n- This process continues down to the word level if necessary.\n\nHere is example usage:\n\n```python\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=0)\ntexts = text_splitter.split_text(document)\n```\n\n:::info[Further reading]\n\nExample implementation using LangChain\'s `CharacterTextSplitter` with token-based splitting:\n\n```python\nfrom langchain_text_splitters import CharacterTextSplitter\ntext_splitter = CharacterTextSplitter.from_tiktoken_encoder(\n    encoding_name="cl100k_base", chunk_size=100, chunk_overlap=0\n)\ntexts = text_splitter.split_text(document)\n```\n\n:::info[Further reading]\n\n* See the how-to guide for [token-based](/docs/how_to/split_by_token/) splitting.\n* See the how-to guide for [character-based](/docs/how_to/character_text_splitter/) splitting.\n\n:::\n\n### Text-structured based\n\n# Text splitters\n<span data-heading-keywords="text splitter,text splitting"></span>\n\n:::info[Prerequisites]\n\n* [Documents](/docs/concepts/retrievers/#interface)\n* Tokenization(/docs/concepts/tokens)\n:::\n\n## Overview\n\nDocument splitting is often a crucial preprocessing step for many applications.\nIt involves breaking down large texts into smaller, manageable chunks.\nThis process offers several benefits, such as ensuring consistent processing of varying document lengths, overcoming input size limitations of models, and improving the quality of text representations used in retrieval systems.\nThere are several strategies for splitting documents, each with its own advantages.\n\n## Key concepts\n\n![Conceptual Overview](/img/text_splitters.png)\n\nText splitters split documents into smaller chunks for use in downstream applications.\n\n## Why split documents?\n\nThere are several reasons to split documents:\n\n:::info[Further reading]\n\n* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).\n\n:::\n\n### Document-structured based\n\nSome documents have an inherent structure, such as HTML, Markdown, or JSON files. \nIn these cases, it\'s beneficial to split the document based on its structure, as it often naturally groups semantically related text.\nKey benefits of structure-based splitting:\n- Preserves the logical organization of the document\n- Maintains context within each chunk\n- Can be more effective for downstream tasks like retrieval or summarization\n\nExamples of structure-based splitting:\n- **Markdown**: Split based on headers (e.g., #, ##, ###)\n- **HTML**: Split using tags\n- **JSON**: Split by object or array elements\n- **Code**: Split by functions, classes, or logical blocks\n\n:::info[Further reading]\n\n:::info[Further reading]\n\n* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).\n* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).\n* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).\n* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).\n\n:::\n\n### Semantic meaning based\n\nUnlike the previous methods, semantic-based splitting actually considers the *content* of the text. \nWhile other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text\'s semantics.\nThere are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.\nAs an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@4937ce41bf71685f9bdcaee3947cb8334b6575d81766f782aa32ee6eafeea3cd¢tsËAÚó1Ešİ¨focus_msÍ§payload‚¤role©assistant§contentÚÓA use case for `RecursiveCharacterTextSplitter` is in preprocessing large documents for natural language processing tasks, where maintaining semantic coherence is important. It splits text into manageable chunks while preserving larger units like paragraphs and sentences, adapting to smaller units only when necessary. This approach enhances the quality of text representations used in retrieval systems and ensures consistent processing of varying document lengths.ªfocus_kind¬exec_latency¨query_id¤Q090‰¢idÙ@3759058f39394f7de0f9d977ec4e2a71923d3e970d8a2d68460b14f78a5cac24¢tsËAÚó1E¤¥¨trace_idÙ$363c6f65-1811-4ae0-9c4c-835b76c1632e­parent_run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556¦run_idÙ$363c6f65-1811-4ae0-9c4c-835b76c1632eªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÓA use case for `RecursiveCharacterTextSplitter` is in preprocessing large documents for natural language processing tasks, where maintaining semantic coherence is important. It splits text into manageable chunks while preserving larger units like paragraphs and sentences, adapting to smaller units only when necessary. This approach enhances the quality of text representations used in retrieval systems and ensures consistent processing of varying document lengths.¨query_id¤Q090ªfocus_kind¶chain_execution_result‰¢idÙ@5f5f4d3b9b5c9854105ca182d670c45db60715bbd02eb5c390bdf2250cc6ced5¢tsËAÚó1E®¸¨trace_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556­parent_run_idÀ¦run_idÙ$668fd90d-bcb6-401a-aa08-625675aa9556ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ9Describe a use case for `RecursiveCharacterTextSplitter`.§context•‚´page_content_summaryÙË:::

### Text-structured based

Text is naturally organized into hierarchical units such as paragraphs, sentences, and words. 
We can leverage this inherent structure to inform our splitting strategy,...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËExample implementation using LangChain's `CharacterTextSplitter` with token-based splitting:

```python
from langchain_text_splitters import CharacterTextSplitter
text_splitter = CharacterTextSplitter...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË# Text splitters
<span data-heading-keywords="text splitter,text splitting"></span>

:::info[Prerequisites]

* [Documents](/docs/concepts/retrievers/#interface)
* Tokenization(/docs/concepts/tokens)
:...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [recursive text splitting](/docs/how_to/recursive_text_splitter/).

:::

### Document-structured based

Some documents have an inherent structure, ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answerÚÓA use case for `RecursiveCharacterTextSplitter` is in preprocessing large documents for natural language processing tasks, where maintaining semantic coherence is important. It splits text into manageable chunks while preserving larger units like paragraphs and sentences, adapting to smaller units only when necessary. This approach enhances the quality of text representations used in retrieval systems and ensures consistent processing of varying document lengths.¨query_id¤Q090ªfocus_kind¶chain_execution_result‹¢idÙ@ac23b2ca72e38309c42bc71c5722ef3b791073f8148132534d55a6cf415eea58¢tsËAÚó1E·‰¨trace_id¤Q091­parent_run_idÀ¦run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.¨query_id¤Q091§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q091ªfocus_kind¯chain_execution‹¢idÙ@3de05a0ccdc51dea4bcf7bb3c663be1dd9c180c806dc5132af6c62b17b1ed48a¢tsËAÚó1EÀ‹¨trace_id¤Q091­parent_run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9a¦run_idÙ$08009080-c795-4df0-96e2-9311b4ae7027ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context¦answer ¨query_id¤Q091¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q091®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:2bf3c773-f2bc-91bf-7584-e4d1201f9673ªfocus_kind¯chain_execution‰¢idÙ@62a4dcdb3ca6c194a4307fb80450ee14320a020ff0e1deccfb68d7f596086c91¢tsËAÚó1[Œã¨trace_idÙ$08009080-c795-4df0-96e2-9311b4ae7027­parent_run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9a¦run_idÙ$08009080-c795-4df0-96e2-9311b4ae7027ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q091ªfocus_kind¶chain_execution_result‹¢idÙ@c95768300ecac0b8f9d3bf93c34dd2b107a5b1b691b2f3cb2fac5d31a383adb1¢tsËAÚó1[”…¨trace_id¤Q091­parent_run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9a¦run_idÙ$9c840875-6a47-4920-b93c-a3343903876aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q091¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q091®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8257dac7-1f3f-780f-8cb2-ade38e9fe69bªfocus_kind¯chain_execution‹¢idÙ@69e10ec85752b68b148e0ec9fab8a4aa264b566fea524b6f42db83f6d492b7cf¢tsËAÚó1[™5¨trace_id¤Q091­parent_run_idÙ$9c840875-6a47-4920-b93c-a3343903876a¦run_idÙ$793917f1-76c1-4cc9-ac47-dedd11a303c2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ3Give two methods to stream output from a ChatModel.§contextÚKThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.

#### Usage with chat models

When using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM's output incrementally as it's being produced, which is particularly useful in interactive applications or interfaces.

#### Usage with LangGraph

[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.

## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).

1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astream** APIs when working with LangGraph. **Important** this is a LangGraph feature, so it is not available when working with pure LCEL. See [how to streaming custom data](https://langchain-ai.github.io/langgraph/how-tos/streaming-content/) for more information.
2. [dispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.dispatch_custom_event.html#) / [adispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.adispatch_custom_event.html) can be used to write custom data that will be surfaced through the **astream_events** API. See [how to dispatch custom callback events](/docs/how_to/callbacks_custom_events/#astream-events-api) for more information.

## "Auto-Streaming" Chat Models

model = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for event in chain.astream_events({"topic": "parrot"}):
    kind = event["event"]
    if kind == "on_chat_model_stream":
        print(event, end="|", flush=True)
```

You can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!

See [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.

## Writing custom data to the stream

To write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:

# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q091®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:8257dac7-1f3f-780f-8cb2-ade38e9fe69b­checkpoint_nsÙ-generate:8257dac7-1f3f-780f-8cb2-ade38e9fe69b¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@37e4d5591134c16b15ca259231a630f60930f263bd5202ca1742886805ddadeb¢tsËAÚó1[£,¨trace_idÙ$793917f1-76c1-4cc9-ac47-dedd11a303c2­parent_run_idÙ$9c840875-6a47-4920-b93c-a3343903876a¦run_idÙ$793917f1-76c1-4cc9-ac47-dedd11a303c2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Give two methods to stream output from a ChatModel. \nContext: The [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming behavior.\n\n#### Usage with chat models\n\nWhen using `stream()` or `astream()` with chat models, the output is streamed as [AIMessageChunks](/docs/concepts/messages#aimessagechunk) as it is generated by the LLM. This allows you to present or process the LLM\'s output incrementally as it\'s being produced, which is particularly useful in interactive applications or interfaces.\n\n#### Usage with LangGraph\n\n[LangGraph](/docs/concepts/architecture#langgraph) compiled graphs are [Runnables](/docs/concepts/runnables) and support the standard streaming APIs.\n\n## Streaming APIs\n\nLangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), including [LLMs](/docs/concepts/chat_models), [compiled LangGraph graphs](https://langchain-ai.github.io/langgraph/concepts/low_level/), and any Runnable generated with [LCEL](/docs/concepts/lcel).\n\n1. LangGraph\'s [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astream** APIs when working with LangGraph. **Important** this is a LangGraph feature, so it is not available when working with pure LCEL. See [how to streaming custom data](https://langchain-ai.github.io/langgraph/how-tos/streaming-content/) for more information.\n2. [dispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.dispatch_custom_event.html#) / [adispatch_events](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.manager.adispatch_custom_event.html) can be used to write custom data that will be surfaced through the **astream_events** API. See [how to dispatch custom callback events](/docs/how_to/callbacks_custom_events/#astream-events-api) for more information.\n\n## "Auto-Streaming" Chat Models\n\nmodel = ChatAnthropic(model="claude-3-sonnet-20240229")\n\nprompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")\nparser = StrOutputParser()\nchain = prompt | model | parser\n\nasync for event in chain.astream_events({"topic": "parrot"}):\n    kind = event["event"]\n    if kind == "on_chat_model_stream":\n        print(event, end="|", flush=True)\n```\n\nYou can roughly think of it as an iterator over callback events (though the format differs) - and you can use it on almost all LangChain components!\n\nSee [this guide](/docs/how_to/streaming/#using-stream-events) for more detailed information on how to use `.astream_events()`, including a table listing available events.\n\n## Writing custom data to the stream\n\nTo write custom data to the stream, you will need to choose one of the following methods based on the component you are working with:\n\n# Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@55292559c845fde1f830f1bc54963ffb5f636bacc41f91ff4f253963b1f08196¢tsËAÚó1§ıv¨focus_msÍ¨§payload‚¤role©assistant§contentÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.ªfocus_kind¬exec_latency¨query_id¤Q091‰¢idÙ@762d2767f05c40d02f00eca8b1b02f1c95349476a0d982f125d19b387d540669¢tsËAÚó1¨×¨trace_idÙ$9c840875-6a47-4920-b93c-a3343903876a­parent_run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9a¦run_idÙ$9c840875-6a47-4920-b93c-a3343903876aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.¨query_id¤Q091ªfocus_kind¶chain_execution_result‰¢idÙ@2a665218cb26c37893e68e9c249c9c35185ed0ed3fa31f0cb087c89dd434b5f1¢tsËAÚó1¨(g¨trace_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9a­parent_run_idÀ¦run_idÙ$2a27a20f-fbcd-4a5c-8afb-1c7e4b456f9aªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ3Give two methods to stream output from a ChatModel.§context•‚´page_content_summaryÙËThe [asynchronous version](/docs/concepts/async), `astream()`, works similarly but is designed for non-blocking workflows. You can use it in asynchronous code to achieve the same real-time streaming b...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Streaming APIs

LangChain has two main APIs for streaming output in real-time. These APIs are supported by any component that implements the [Runnable Interface](/docs/concepts/runnables), includin...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. LangGraph's [StreamWriter](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.StreamWriter) can be used to write custom data that will surface through **stream** and **astrea...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙËmodel = ChatAnthropic(model="claude-3-sonnet-20240229")

prompt = ChatPromptTemplate.from_template("tell me a joke about {topic}")
parser = StrOutputParser()
chain = prompt | model | parser

async for...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚTwo methods to stream output from a ChatModel are `stream()` and `astream()`. The `stream()` method is synchronous, while `astream()` is designed for asynchronous workflows. Both methods allow for real-time streaming of output as it is generated by the model.¨query_id¤Q091ªfocus_kind¶chain_execution_result‹¢idÙ@6832ddc1fa15aa69d1e090a20a20c59d181e15b334ef87e4634813a267a556b9¢tsËAÚó1¨Eˆ¨trace_id¤Q092­parent_run_idÀ¦run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?¨query_id¤Q092§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q092ªfocus_kind¯chain_execution‹¢idÙ@a5da91ec2a28d590be7cdaa71c480ea8b2f948d0bee618c08693469de3312080¢tsËAÚó1¨V°¨trace_id¤Q092­parent_run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3¦run_idÙ$c1a5ed3e-4adc-49fc-a9e5-ca5af6bb02f8ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context¦answer ¨query_id¤Q092¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q092®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:7ca8394a-030e-340d-7d27-9a31cf5bcaa1ªfocus_kind¯chain_execution‰¢idÙ@b74ff29a4d83c72827f7631f85990d2b9de43d8b363141771e0d65585c923cd0¢tsËAÚó1¹2ô¨trace_idÙ$c1a5ed3e-4adc-49fc-a9e5-ca5af6bb02f8­parent_run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3¦run_idÙ$c1a5ed3e-4adc-49fc-a9e5-ca5af6bb02f8ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¨query_id¤Q092ªfocus_kind¶chain_execution_result‹¢idÙ@d7db3d066005a1306870af874c10b7e98e35a9e8acb8841a1e7cfecff8770e94¢tsËAÚó1¹@l¨trace_id¤Q092­parent_run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3¦run_idÙ$66b2bdf0-c000-4867-9b4b-8a725b1eaef0ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answer ¨query_id¤Q092¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q092®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:4ca7d185-0202-1fef-2f67-8f54c7a268e4ªfocus_kind¯chain_execution‹¢idÙ@520cd5130db729e90bbe1927344868605e1a0302d6563964feeccae712564c87¢tsËAÚó1¹G¨trace_id¤Q092­parent_run_idÙ$66b2bdf0-c000-4867-9b4b-8a725b1eaef0¦run_idÙ$7f297c04-4b22-4958-b089-92a64d159fb2ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§contextÚ,- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](/docs/how_to/hybrid)

The particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each word to a list of locations at which it occurs in various documents. 
Using this data structure, it is possible to efficiently match the words in search queries to the documents in which they appear.
[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

#### Vector indexes

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |

:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for context on how to build a retreiver using a graph database and text-to-Cypher.

:::

### Lexical search

As discussed in our conceptual review of [retrieval](/docs/concepts/retrieval/), many search engines are based upon matching words in a query to the words in each document. 
[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).
LangChain has retrievers for many popular lexical search algorithms / engines.

:::info[Further reading]

At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [how-to guide on hybrid search](/docs/how_to/hybrid/) for more details.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q092®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:4ca7d185-0202-1fef-2f67-8f54c7a268e4­checkpoint_nsÙ-generate:4ca7d185-0202-1fef-2f67-8f54c7a268e4¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@011243341fde65792d65ce592bb5d637eb61aae408f1109750d4287de4114fe0¢tsËAÚó1¹Re¨trace_idÙ$7f297c04-4b22-4958-b089-92a64d159fb2­parent_run_idÙ$66b2bdf0-c000-4867-9b4b-8a725b1eaef0¦run_idÙ$7f297c04-4b22-4958-b089-92a64d159fb2ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which document teaches you to build a hybrid search retriever combining keyword and vector? \nContext: - [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n- [How to: use hybrid vector and keyword retrieval](/docs/how_to/hybrid)\n\nThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).\nThis types of index contains a list of words and a mapping of each word to a list of locations at which it occurs in various documents. \nUsing this data structure, it is possible to efficiently match the words in search queries to the documents in which they appear.\n[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n#### Vector indexes\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |\n\n:::info[Further reading]\n\n* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.\n* See our [tutorial](/docs/tutorials/graph/) for context on how to build a retreiver using a graph database and text-to-Cypher.\n\n:::\n\n### Lexical search\n\nAs discussed in our conceptual review of [retrieval](/docs/concepts/retrieval/), many search engines are based upon matching words in a query to the words in each document. \n[BM25](https://en.wikipedia.org/wiki/Okapi_BM25#:~:text=BM25%20is%20a%20bag%2Dof,slightly%20different%20components%20and%20parameters.) and [TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf) are [two popular lexical search algorithms](https://cameronrwolfe.substack.com/p/the-basics-of-ai-powered-vector-search?utm_source=profile&utm_medium=reader2).\nLangChain has retrievers for many popular lexical search algorithms / engines.\n\n:::info[Further reading]\n\nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\nSee this [how-to guide on hybrid search](/docs/how_to/hybrid/) for more details. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@3cc89f2fbed0d532c31d467fc4bbe54da68e366fdfc19dc7900494934c6537f2¢tsËAÚó2	ªÒ¨focus_msÍæ§payload‚¤role©assistant§contentÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.ªfocus_kind¬exec_latency¨query_id¤Q092‰¢idÙ@beee76c6a04ce7ebd6d6c802e5a03188b3dc2369c797beab80f41b8c27579230¢tsËAÚó2	¹™¨trace_idÙ$66b2bdf0-c000-4867-9b4b-8a725b1eaef0­parent_run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3¦run_idÙ$66b2bdf0-c000-4867-9b4b-8a725b1eaef0ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.¨query_id¤Q092ªfocus_kind¶chain_execution_result‰¢idÙ@90dc4ded9b605afa58396878ea3e3611ffc9b968f80fbacbcdf77b910c2a8412¢tsËAÚó2	èŠ¨trace_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3­parent_run_idÀ¦run_idÙ$ff0893e6-639f-40d7-999a-1e82d9f3afc3ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ[Which document teaches you to build a hybrid search retriever combining keyword and vector?§context•‚´page_content_summaryÙË- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)
- [How to: use hybrid vector and keyword retrieval](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËThe particular data structure used to implement this is often an [*inverted index*](https://www.geeksforgeeks.org/inverted-index/).
This types of index contains a list of words and a mapping of each w...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrieval.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See our [tutorial](/docs/tutorials/sql_qa/) for context on how to build a retreiver using a SQL database and text-to-SQL.
* See our [tutorial](/docs/tutorials/graph/) for c...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙËAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.
See this [ho...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answerÚ$The document that teaches you to build a hybrid search retriever combining keyword and vector is titled "How to: use hybrid vector and keyword retrieval." You can find it in the provided context. This guide explains how to combine keyword-based and semantic similarity approaches effectively.¨query_id¤Q092ªfocus_kind¶chain_execution_result‹¢idÙ@1c15978b06945f146b6bc8f7ba9bfc06c35c9520fb525abaf70696f0bbe06495¢tsËAÚó2	òk¨trace_id¤Q093­parent_run_idÀ¦run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?¨query_id¤Q093§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q093ªfocus_kind¯chain_execution‹¢idÙ@1ae71784bc7d2d1a23731925acd13f71ed622efb08abfe12e86e5292e6efd064¢tsËAÚó2
[¨trace_id¤Q093­parent_run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950¦run_idÙ$8a94673e-f4b1-4ccd-affa-a3ed16744feeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context¦answer ¨query_id¤Q093¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q093®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:cc03c2d1-26a4-4374-4423-5db54682666dªfocus_kind¯chain_execution‰¢idÙ@e3e313c9689be0bbecb945f16e369e093c5d238f68b86c6d926cb47dd9c3e287¢tsËAÚó2L¨trace_idÙ$8a94673e-f4b1-4ccd-affa-a3ed16744fee­parent_run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950¦run_idÙ$8a94673e-f4b1-4ccd-affa-a3ed16744feeªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¨query_id¤Q093ªfocus_kind¶chain_execution_result‹¢idÙ@26ddae8d5153b82b29c5f86048f53aa2fca5c91f0f8cf00d1cc580c8c408d491¢tsËAÚó2Y’¨trace_id¤Q093­parent_run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950¦run_idÙ$042acc9a-a53f-41a1-aefa-ed73caed7c0aªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¦answer ¨query_id¤Q093¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q093®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d4518346-50ca-8a09-70f7-69d32afa54e6ªfocus_kind¯chain_execution‹¢idÙ@59f128a96c53d5aa175316a74b8b606da1845021b890dc070713e6e927419325¢tsËAÚó2b¨trace_id¤Q093­parent_run_idÙ$042acc9a-a53f-41a1-aefa-ed73caed7c0a¦run_idÙ$002c773a-8a16-4728-8d76-7d7cab2dbc41ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§contextÚ™See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).

Please see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.

## Tool artifacts

## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that we want to make accessible to downstream components in our chain or agent, but that we don't want to expose to the model itself. For example if a tool returns a custom object, a dataframe or an image, we may want to pass some metadata about this output to the model without passing the actual output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.

```python
@tool(response_format="content_and_artifact")
def some_tool(...) -> Tuple[str, Any]:
    """Tool that does something."""
    ...
    return 'Message for chat model', some_artifact 
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working with, there are common types of objects that are typically allowed or recommended for structured output in Python.

The simplest and most common format for structured output is a JSON-like structure, which in Python can be represented as a dictionary (dict) or list (list).
JSON objects (or dicts in Python) are often used directly when the tool requires raw, flexible, and minimal-overhead structured data.

```json
{
  "answer": "The answer to the user's question",
  "followup_question": "A followup question the user could ask"
}
```

As a second example, [Pydantic](https://docs.pydantic.dev/latest/) is particularly useful for defining structured output schemas because it offers type hints and validation.
Here's an example of a Pydantic schema:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q093®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d4518346-50ca-8a09-70f7-69d32afa54e6­checkpoint_nsÙ-generate:d4518346-50ca-8a09-70f7-69d32afa54e6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@cc012fb24ab333f67e7ce8bd42a55f79b5d3e19818873ed769213653e0814ec4¢tsËAÚó2hù¨trace_idÙ$002c773a-8a16-4728-8d76-7d7cab2dbc41­parent_run_idÙ$042acc9a-a53f-41a1-aefa-ed73caed7c0a¦run_idÙ$002c773a-8a16-4728-8d76-7d7cab2dbc41ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the purpose of `annotated` type hints in tool schemas? \nContext: See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\n## Configuring the schema\n\nThe `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description\nor parse the function\'s doc-string to infer the schema).\n\nPlease see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.\n\n## Tool artifacts\n\n## Tool artifacts\n\n**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool\'s execution that we want to make accessible to downstream components in our chain or agent, but that we don\'t want to expose to the model itself. For example if a tool returns a custom object, a dataframe or an image, we may want to pass some metadata about this output to the model without passing the actual output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.\n\n```python\n@tool(response_format="content_and_artifact")\ndef some_tool(...) -> Tuple[str, Any]:\n    """Tool that does something."""\n    ...\n    return \'Message for chat model\', some_artifact \n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\n## Schema definition\n\nThe central concept is that the output structure of model responses needs to be represented in some way. \nWhile types of objects you can use depend on the model you\'re working with, there are common types of objects that are typically allowed or recommended for structured output in Python.\n\nThe simplest and most common format for structured output is a JSON-like structure, which in Python can be represented as a dictionary (dict) or list (list).\nJSON objects (or dicts in Python) are often used directly when the tool requires raw, flexible, and minimal-overhead structured data.\n\n```json\n{\n  "answer": "The answer to the user\'s question",\n  "followup_question": "A followup question the user could ask"\n}\n```\n\nAs a second example, [Pydantic](https://docs.pydantic.dev/latest/) is particularly useful for defining structured output schemas because it offers type hints and validation.\nHere\'s an example of a Pydantic schema: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2fcea393f72f7657305546f8b65c56bb166753d2a686d2cc34c5dc2cae51f450¢tsËAÚó2†Æ&¨focus_msÍn§payload‚¤role©assistant§contentÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.ªfocus_kind¬exec_latency¨query_id¤Q093‰¢idÙ@d16a41328276a8da5e0c415e8ab598e50a262f7f49f4335d0ed0a5ee75667dce¢tsËAÚó2†Û'¨trace_idÙ$042acc9a-a53f-41a1-aefa-ed73caed7c0a­parent_run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950¦run_idÙ$042acc9a-a53f-41a1-aefa-ed73caed7c0aªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.¨query_id¤Q093ªfocus_kind¶chain_execution_result‰¢idÙ@ddde0ed66e363be2acdf940d5df6169899e1a9efaa99990e71007c02258e31c7¢tsËAÚó2†î–¨trace_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950­parent_run_idÀ¦run_idÙ$f5794e38-455e-4285-b59e-d05ce5b5d950ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>What is the purpose of `annotated` type hints in tool schemas?§context•‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Tool artifacts

**Tools** are utilities that can be called by a model, and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that w...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Schema definition

The central concept is that the output structure of model responses needs to be represented in some way. 
While types of objects you can use depend on the model you're working wi...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx¦answerÚuThe purpose of `Annotated` type hints in tool schemas is to provide descriptions for arguments that will be exposed in the tool's schema. This allows for better documentation and understanding of the tool's parameters when they are presented to users or models. Additionally, it helps in configuring the runtime behavior of the tool by clarifying the role of each argument.¨query_id¤Q093ªfocus_kind¶chain_execution_result‹¢idÙ@c40b71e17abb032239cdd366779983eddc44d6a080b74f53760b27929994e979¢tsËAÚó2†ı¨trace_id¤Q094­parent_run_idÀ¦run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.¨query_id¤Q094§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q094ªfocus_kind¯chain_execution‹¢idÙ@a6781a81e1182d073874ec543e9e98e9f452a30196948a1e214072c31eab131d¢tsËAÚó2‡N¨trace_id¤Q094­parent_run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864¦run_idÙ$3b489d55-cf1c-4583-ac9e-f1b2cd151422ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.§context¦answer ¨query_id¤Q094¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q094®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:466dae49-4a36-35b5-5136-a0411952f21fªfocus_kind¯chain_execution‰¢idÙ@48cc43f78c35cb8dd83f9bf5ba250de4561a0073764b7d3257ae5a71859cc5fb¢tsËAÚó2šYÈ¨trace_idÙ$3b489d55-cf1c-4583-ac9e-f1b2cd151422­parent_run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864¦run_idÙ$3b489d55-cf1c-4583-ac9e-f1b2cd151422ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q094ªfocus_kind¶chain_execution_result‹¢idÙ@ae96b5e618dc7997a8d213e3a069e0ba1cf07dd40115c4e485908bed4dc7840e¢tsËAÚó2š`t¨trace_id¤Q094­parent_run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864¦run_idÙ$93fa423b-b9e1-4de7-80ba-250c40ecae1bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ8Explain why caching chat model responses is challenging.§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q094¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q094®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1bcb6072-65bf-a966-d014-63dceb7e6bfcªfocus_kind¯chain_execution‹¢idÙ@42ebe1d196148ce8e67639118e818f0b89dff2519d4a80020fd60a0ffda7e659¢tsËAÚó2šeb¨trace_id¤Q094­parent_run_idÙ$93fa423b-b9e1-4de7-80ba-250c40ecae1b¦run_idÙ$a96fb66e-341b-486a-b815-291a18f73e4eªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ8Explain why caching chat model responses is challenging.§contextÚ¡### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.

The reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?

An alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.

A semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.

However, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.

Please see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.

## Related resources

* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).
* List of supported chat models: [chat model integrations](/docs/integrations/chat/).

### Conceptual guides

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.

## Overview

Generating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.

1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q094®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:1bcb6072-65bf-a966-d014-63dceb7e6bfc­checkpoint_nsÙ-generate:1bcb6072-65bf-a966-d014-63dceb7e6bfc¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@701f2c4c72a63df6594e47af13b0eb21c40ad62dbae816c3e1795975e3d83fae¢tsËAÚó2šk±¨trace_idÙ$a96fb66e-341b-486a-b815-291a18f73e4e­parent_run_idÙ$93fa423b-b9e1-4de7-80ba-250c40ecae1b¦run_idÙ$a96fb66e-341b-486a-b815-291a18f73e4eªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ\messages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain why caching chat model responses is challenging. \nContext: ### Caching\n\nChat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of requests made to the model provider. In practice, caching chat model responses is a complex problem and should be approached with caution.\n\nThe reason is that getting a cache hit is unlikely after the first or second interaction in a conversation if relying on caching the **exact** inputs into the model. For example, how likely do you think that multiple conversations start with the exact same message? What about the exact same three messages?\n\nAn alternative approach is to use semantic caching, where you cache responses based on the meaning of the input rather than the exact input itself. This can be effective in some situations, but not in others.\n\nA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to convert text to a vector representation), and it's not guaranteed to capture the meaning of the input accurately.\n\nHowever, there might be situations where caching chat model responses is beneficial. For example, if you have a chat model that is used to answer frequently asked questions, caching responses can help reduce the load on the model provider, costs, and improve response times.\n\nPlease see the [how to cache chat model responses](/docs/how_to/chat_model_caching/) guide for more details.\n\n## Related resources\n\n* How-to guides on using chat models: [how-to guides](/docs/how_to/#chat-models).\n* List of supported chat models: [chat model integrations](/docs/integrations/chat/).\n\n### Conceptual guides\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n# Streaming\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n* [Chat Models](/docs/concepts/chat_models)\n:::\n\n**Streaming** is crucial for enhancing the responsiveness of applications built on [LLMs](/docs/concepts/chat_models). By displaying output progressively, even before a complete response is ready, streaming significantly improves user experience (UX), particularly when dealing with the latency of LLMs.\n\n## Overview\n\nGenerating full responses from [LLMs](/docs/concepts/chat_models) often incurs a delay of several seconds, which becomes more noticeable in complex applications with multiple model calls. Fortunately, LLMs generate responses iteratively, allowing for intermediate results to be displayed as they are produced. By streaming these intermediate outputs, LangChain enables smoother UX in LLM-powered apps and offers built-in support for streaming at the core of its design.\n\n1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information. \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2e593ab70e6fd11a23f596ea00818a2f2d746d744a8973bd878b1cfd503660c1¢tsËAÚó2ôöà¨focus_msÍ†§payload‚¤role©assistant§contentÚÕCaching chat model responses is challenging because exact input matches are rare after the initial interactions in a conversation, making cache hits unlikely. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.ªfocus_kind¬exec_latency¨query_id¤Q094‰¢idÙ@66be5a355ecf9f6fe8e1d66c09bad2b57bd0518a647f7eb6b62437416be62031¢tsËAÚó2õ9¨trace_idÙ$93fa423b-b9e1-4de7-80ba-250c40ecae1b­parent_run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864¦run_idÙ$93fa423b-b9e1-4de7-80ba-250c40ecae1bªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÕCaching chat model responses is challenging because exact input matches are rare after the initial interactions in a conversation, making cache hits unlikely. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.¨query_id¤Q094ªfocus_kind¶chain_execution_result‰¢idÙ@4ccd38f709a48553cad01a7dcf10e1abaa6b837c903a243a98e9d4b8676a5f8c¢tsËAÚó2õD¨trace_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864­parent_run_idÀ¦run_idÙ$6bc2be52-54e1-41a9-8ace-a28894262864ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ8Explain why caching chat model responses is challenging.§context•‚´page_content_summaryÙË### Caching

Chat model APIs can be slow, so a natural question is whether to cache the results of previous conversations. Theoretically, caching can help improve performance by reducing the number of...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËA semantic cache introduces a dependency on another model on the critical path of your application (e.g., the semantic cache may rely on an [embedding model](/docs/concepts/embedding_models) to conver...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Streaming

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
* [Chat Models](/docs/concepts/chat_models)
:::

**Streaming** is crucial for enhancing the responsiveness of applic...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚÕCaching chat model responses is challenging because exact input matches are rare after the initial interactions in a conversation, making cache hits unlikely. Additionally, semantic caching, which relies on understanding the meaning of inputs, introduces dependencies on other models and may not accurately capture the intended meaning. While caching can improve performance in specific scenarios, such as frequently asked questions, it requires careful implementation.¨query_id¤Q094ªfocus_kind¶chain_execution_result‹¢idÙ@37b841010f9b79d369bc1732c9aff255fba42b320e4de1448d025f212b48350c¢tsËAÚó2õ¨trace_id¤Q095­parent_run_idÀ¦run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?¨query_id¤Q095§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q095ªfocus_kind¯chain_execution‹¢idÙ@cd1aa8f174f233efc52004373659dcd39b26055f12346936f77073872121b917¢tsËAÚó2õã¨trace_id¤Q095­parent_run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656¦run_idÙ$58cb9328-7666-466c-a972-614bcadcbbc4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context¦answer ¨query_id¤Q095¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q095®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:9b10579e-aab5-bfe7-351f-4708ced1f8a1ªfocus_kind¯chain_execution‰¢idÙ@dbeb021f97b8c93b79d6d599d85776f6af6ccca13a9e9de49777f8953a83d9cf¢tsËAÚó3
'O¨trace_idÙ$58cb9328-7666-466c-a972-614bcadcbbc4­parent_run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656¦run_idÙ$58cb9328-7666-466c-a972-614bcadcbbc4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q095ªfocus_kind¶chain_execution_result‹¢idÙ@d409bbe15ddb471b7e901caa60c003e82fe6169287dcbdc65249c479a739a4f2¢tsËAÚó3
/¨trace_id¤Q095­parent_run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656¦run_idÙ$1d0f86a7-8fa5-4efb-b53d-e655350009caªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q095¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q095®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f9979969-7412-d617-3a10-91e7b8b98fb6ªfocus_kind¯chain_execution‹¢idÙ@5aa4dd7e3cad34b4e43e73c91f6b67ae4a22b7637b1eb2c9ea0ce9217f9a9be8¢tsËAÚó3
3'¨trace_id¤Q095­parent_run_idÙ$1d0f86a7-8fa5-4efb-b53d-e655350009ca¦run_idÙ$be65e36c-95b8-433e-8dd9-93f8a80acccfªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙIWhich two docs together explain trimming long documents before embedding?§contextÚ## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).

### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_text_splitter)
- [How to: split HTML](/docs/how_to/split_html)
- [How to: split by character](/docs/how_to/character_text_splitter)
- [How to: split code](/docs/how_to/code_splitter)
- [How to: split Markdown by headers](/docs/how_to/markdown_header_metadata_splitter)
- [How to: recursively split JSON](/docs/how_to/recursive_json_splitter)
- [How to: split text into semantic chunks](/docs/how_to/semantic-chunker)
- [How to: split by tokens](/docs/how_to/split_by_token)

### Embedding models

[Embedding Models](/docs/concepts/embedding_models) take a piece of text and create a numerical representation of it.
See [supported integrations](/docs/integrations/text_embedding/) for details on getting started with embedding models from a specific provider.

- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model limitations**: Many embedding models and language models have maximum input size constraints. Splitting allows us to process documents that would otherwise exceed these limits.
- **Improving representation quality**: For longer documents, the quality of embeddings or other representations may degrade as they try to capture too much information. Splitting can lead to more focused and accurate representations of each section.
- **Enhancing retrieval precision**: In information retrieval systems, splitting can improve the granularity of search results, allowing for more precise matching of queries to relevant document sections.
- **Optimizing computational resources**: Working with smaller chunks of text can be more memory-efficient and allow for better parallelization of processing tasks.

Now, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkviz.up.railway.app/) to visualize different splitting strategies discussed below.
:::

## Approaches

### Length-based

The most intuitive strategy is to split documents based on their length. This simple yet effective approach ensures that each chunk doesn't exceed a specified size limit.
Key benefits of length-based splitting:
- Straightforward implementation
- Consistent chunk sizes
- Easily adaptable to different model requirements

Types of length-based splitting:
- **Token-based**: Splits text based on the number of tokens, which is useful when working with language models.
- **Character-based**: Splits text based on the number of characters, which can be more consistent across different types of text.

| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are best indexed by themselves, but best retrieved all together. | This involves indexing multiple chunks for each document. Then you find the chunks that are most similar in embedding space, but you retrieve the whole parent document and return that (rather than individual chunks). |
| [Multi Vector](/docs/how_to/multi_vector/)                | Vector store + Document Store | Sometimes during indexing | If you are able to extract information from documents that you think is more relevant to index than the text itself.                    | This involves creating multiple vectors for each document. Each vector could be created in a myriad of ways - examples include summaries of the text and hypothetical questions.                                         |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q095®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f9979969-7412-d617-3a10-91e7b8b98fb6­checkpoint_nsÙ-generate:f9979969-7412-d617-3a10-91e7b8b98fb6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@5c96c7cc8129be518b453045b5e37aa9bdc835f1bc29ece239e4a5736ca2285a¢tsËAÚó3
9´¨trace_idÙ$be65e36c-95b8-433e-8dd9-93f8a80acccf­parent_run_idÙ$1d0f86a7-8fa5-4efb-b53d-e655350009ca¦run_idÙ$be65e36c-95b8-433e-8dd9-93f8a80acccfªevent_type¬chain_output¬event_source¥chain§payload§outputsÚômessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two docs together explain trimming long documents before embedding? \nContext: ## Related resources\n\n- [How to trim messages](/docs/how_to/trim_messages/)\n- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and long-term memory in chat models using [LangGraph](https://langchain-ai.github.io/langgraph/).\n\n### Text splitters\n\n[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.\n\n- [How to: recursively split text](/docs/how_to/recursive_text_splitter)\n- [How to: split HTML](/docs/how_to/split_html)\n- [How to: split by character](/docs/how_to/character_text_splitter)\n- [How to: split code](/docs/how_to/code_splitter)\n- [How to: split Markdown by headers](/docs/how_to/markdown_header_metadata_splitter)\n- [How to: recursively split JSON](/docs/how_to/recursive_json_splitter)\n- [How to: split text into semantic chunks](/docs/how_to/semantic-chunker)\n- [How to: split by tokens](/docs/how_to/split_by_token)\n\n### Embedding models\n\n[Embedding Models](/docs/concepts/embedding_models) take a piece of text and create a numerical representation of it.\nSee [supported integrations](/docs/integrations/text_embedding/) for details on getting started with embedding models from a specific provider.\n\n- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.\n- **Overcoming model limitations**: Many embedding models and language models have maximum input size constraints. Splitting allows us to process documents that would otherwise exceed these limits.\n- **Improving representation quality**: For longer documents, the quality of embeddings or other representations may degrade as they try to capture too much information. Splitting can lead to more focused and accurate representations of each section.\n- **Enhancing retrieval precision**: In information retrieval systems, splitting can improve the granularity of search results, allowing for more precise matching of queries to relevant document sections.\n- **Optimizing computational resources**: Working with smaller chunks of text can be more memory-efficient and allow for better parallelization of processing tasks.\n\nNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.\n\n:::info[Further reading]\n* See Greg Kamradt's [chunkviz](https://chunkviz.up.railway.app/) to visualize different splitting strategies discussed below.\n:::\n\n## Approaches\n\n### Length-based\n\nThe most intuitive strategy is to split documents based on their length. This simple yet effective approach ensures that each chunk doesn't exceed a specified size limit.\nKey benefits of length-based splitting:\n- Straightforward implementation\n- Consistent chunk sizes\n- Easily adaptable to different model requirements\n\nTypes of length-based splitting:\n- **Token-based**: Splits text based on the number of tokens, which is useful when working with language models.\n- **Character-based**: Splits text based on the number of characters, which can be more consistent across different types of text.\n\n| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are best indexed by themselves, but best retrieved all together. | This involves indexing multiple chunks for each document. Then you find the chunks that are most similar in embedding space, but you retrieve the whole parent document and return that (rather than individual chunks). |\n| [Multi Vector](/docs/how_to/multi_vector/)                | Vector store + Document Store | Sometimes during indexing | If you are able to extract information from documents that you think is more relevant to index than the text itself.                    | This involves creating multiple vectors for each document. Each vector could be created in a myriad of ways - examples include summaries of the text and hypothetical questions.                                         | \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@ad18c6612a4ee6f529bed7f25404823ebdba41de31661ea52e494aae00cc52b1¢tsËAÚó3Dç;¨focus_msÍ”§payload‚¤role©assistant§contentÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.ªfocus_kind¬exec_latency¨query_id¤Q095‰¢idÙ@4e2d24a45707e3a36bbe164dd73e93f9a33221f0326735e7cb554dab10409c5f¢tsËAÚó3Dÿe¨trace_idÙ$1d0f86a7-8fa5-4efb-b53d-e655350009ca­parent_run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656¦run_idÙ$1d0f86a7-8fa5-4efb-b53d-e655350009caªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.¨query_id¤Q095ªfocus_kind¶chain_execution_result‰¢idÙ@8815cbf373c906d818ce4de5a9de120c25e5227e4658c0cbc0b6a36e9f8ea081¢tsËAÚó3EÔ¨trace_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656­parent_run_idÀ¦run_idÙ$48d13dd7-7fc2-4960-bd6a-1be9cd488656ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙIWhich two docs together explain trimming long documents before embedding?§context•‚´page_content_summaryÙË## Related resources

- [How to trim messages](/docs/how_to/trim_messages/)
- [Memory guide](https://langchain-ai.github.io/langgraph/concepts/memory/) for information on implementing short-term and l...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_history.mdx‚´page_content_summaryÙË### Text splitters

[Text Splitters](/docs/concepts/text_splitters) take a document and split into chunks that can be used for retrieval.

- [How to: recursively split text](/docs/how_to/recursive_tex...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË- **Handling non-uniform document lengths**: Real-world document collections often contain texts of varying sizes. Splitting ensures consistent processing across all documents.
- **Overcoming model li...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙËNow, the next question is *how* to split the documents into chunks! There are several strategies, each with its own advantages.

:::info[Further reading]
* See Greg Kamradt's [chunkviz](https://chunkv...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx‚´page_content_summaryÙË| [ParentDocument](/docs/how_to/parent_document_retriever/) | Vector store + Document Store | No                        | If your pages have lots of smaller pieces of distinct information that are bes...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÙçThe two documents that explain trimming long documents before embedding are "How to trim messages" and "Text Splitters." These resources provide guidance on effectively managing document lengths for better processing and embedding.¨query_id¤Q095ªfocus_kind¶chain_execution_result‹¢idÙ@a383d84e8b3d16eadc3a2dfe1ed57f7da252a7116847714a2ec57fab47efa88a¢tsËAÚó3EQ¨trace_id¤Q096­parent_run_idÀ¦run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264eeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?¨query_id¤Q096§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q096ªfocus_kind¯chain_execution‹¢idÙ@9ef27458768f32ed5aa784e98baa4051c96e2fe150570777d93cb0024938c904¢tsËAÚó3E"d¨trace_id¤Q096­parent_run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264ee¦run_idÙ$b59ef34b-cf20-4925-9072-3084cf18b7afªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context¦answer ¨query_id¤Q096¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q096®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:67703eb9-a078-91fb-8bfb-9c2724910381ªfocus_kind¯chain_execution‰¢idÙ@0deabae51ea5aa275c0847c8a9b0cd248a52582d026d065725301ed4bc9ce7ec¢tsËAÚó3VÜ¨trace_idÙ$b59ef34b-cf20-4925-9072-3084cf18b7af­parent_run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264ee¦run_idÙ$b59ef34b-cf20-4925-9072-3084cf18b7afªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¨query_id¤Q096ªfocus_kind¶chain_execution_result‹¢idÙ@911e8e588f44d95079cde091f57363c77059888a279fb61103313f525033eb83¢tsËAÚó3Vìš¨trace_id¤Q096­parent_run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264ee¦run_idÙ$a2da2776-a155-4e7a-829a-5736de66d416ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¦answer ¨query_id¤Q096¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q096®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d805532b-2814-a000-3443-9b69367be063ªfocus_kind¯chain_execution‹¢idÙ@ab998bca0ec57f5c19270c72e607f11d3a114c755c41901f9e6e4d6a14c1ab07¢tsËAÚó3VõÏ¨trace_id¤Q096­parent_run_idÙ$a2da2776-a155-4e7a-829a-5736de66d416¦run_idÙ$5b597e84-5fe3-4eb3-b27c-aabc8fa491d1ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§contextÚ### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects](/docs/how_to/output_parser_string)
- [How to: use output parsers to parse an LLM response into structured format](/docs/how_to/output_parser_structured)
- [How to: parse JSON output](/docs/how_to/output_parser_json)
- [How to: parse XML output](/docs/how_to/output_parser_xml)
- [How to: parse YAML output](/docs/how_to/output_parser_yaml)
- [How to: retry when output parsing errors occur](/docs/how_to/output_parser_retry)
- [How to: try to fix errors in output parsing](/docs/how_to/output_parser_fixing)
- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)

### Document loaders

[Document Loaders](/docs/concepts/document_loaders) are responsible for loading documents from a variety of sources.

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_caching)
- [How to: create a custom LLM class](/docs/how_to/custom_llm)
- [How to: stream a response back](/docs/how_to/streaming_llm)
- [How to: track token usage](/docs/how_to/llm_token_usage_tracking)
- [How to: work with local models](/docs/how_to/local_llms)

### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSON output.
You can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).
Here is an example of how to use JSON mode with OpenAI:

```python
from langchain_openai import ChatOpenAI
model = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")
ai_msg = model.invoke("Return a JSON object with key 'random_ints' and a value of 10 random ints in [0-99]")
ai_msg
{'random_ints': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}
```

## Structured output method 

There are a few challenges when producing structured output with the above methods: 

(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.

| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputParser)                            |                    | âœ…                       |           | `str` \| `Message` | `Dict[str, str]`     | An output parser that returns structured information. It is less powerful than other output parsers since it only allows for fields to be strings. This can be useful when you are working with smaller LLMs.                                            |

| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…                  | âœ…                       |           | `str` \| `Message` | JSON object          | Returns a JSON object as specified. You can specify a Pydantic model and it will return JSON for that model. Probably the most reliable output parser for getting structured data that does NOT use function calling.                                    |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q096®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d805532b-2814-a000-3443-9b69367be063­checkpoint_nsÙ-generate:d805532b-2814-a000-3443-9b69367be063¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@86e9e28450e958287b8a89107548def44bfa57f02847c8449dc7283edc5dbaa5¢tsËAÚó3Vıø¨trace_idÙ$5b597e84-5fe3-4eb3-b27c-aabc8fa491d1­parent_run_idÙ$a2da2776-a155-4e7a-829a-5736de66d416¦run_idÙ$5b597e84-5fe3-4eb3-b27c-aabc8fa491d1ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚúmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What class enables you to get structured JSON output directly from LLMS without a parser? \nContext: ### Output parsers\n\n[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.\n\n- [How to: parse text from message objects](/docs/how_to/output_parser_string)\n- [How to: use output parsers to parse an LLM response into structured format](/docs/how_to/output_parser_structured)\n- [How to: parse JSON output](/docs/how_to/output_parser_json)\n- [How to: parse XML output](/docs/how_to/output_parser_xml)\n- [How to: parse YAML output](/docs/how_to/output_parser_yaml)\n- [How to: retry when output parsing errors occur](/docs/how_to/output_parser_retry)\n- [How to: try to fix errors in output parsing](/docs/how_to/output_parser_fixing)\n- [How to: write a custom output parser class](/docs/how_to/output_parser_custom)\n\n### Document loaders\n\n[Document Loaders](/docs/concepts/document_loaders) are responsible for loading documents from a variety of sources.\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n- [How to: cache model responses](/docs/how_to/llm_caching)\n- [How to: create a custom LLM class](/docs/how_to/custom_llm)\n- [How to: stream a response back](/docs/how_to/streaming_llm)\n- [How to: track token usage](/docs/how_to/llm_token_usage_tracking)\n- [How to: work with local models](/docs/how_to/local_llms)\n\n### Output parsers\n\n[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.\n\n### JSON mode\n\nIn addition to tool calling, some model providers support a feature called `JSON mode`. \nThis supports JSON schema definition as input and enforces the model to produce a conforming JSON output.\nYou can find a table of model providers that support JSON mode [here](/docs/integrations/chat/).\nHere is an example of how to use JSON mode with OpenAI:\n\n```python\nfrom langchain_openai import ChatOpenAI\nmodel = ChatOpenAI(model="gpt-4o").with_structured_output(method="json_mode")\nai_msg = model.invoke("Return a JSON object with key \'random_ints\' and a value of 10 random ints in [0-99]")\nai_msg\n{\'random_ints\': [45, 67, 12, 34, 89, 23, 78, 56, 90, 11]}\n```\n\n## Structured output method \n\nThere are a few challenges when producing structured output with the above methods: \n\n(1) When tool calling is used, tool call arguments needs to be parsed from a dictionary back to the original schema.\n\n| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputParser)                            |                    | âœ…                       |           | `str` \\| `Message` | `Dict[str, str]`     | An output parser that returns structured information. It is less powerful than other output parsers since it only allows for fields to be strings. This can be useful when you are working with smaller LLMs.                                            |\n\n| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…                  | âœ…                       |           | `str` \\| `Message` | JSON object          | Returns a JSON object as specified. You can specify a Pydantic model and it will return JSON for that model. Probably the most reliable output parser for getting structured data that does NOT use function calling.                                    | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@598b2c8c4d8ef12f2da76b44a08411a002fefff5596ff30c8952d11ad1b189a0¢tsËAÚó3Âƒˆ¨focus_msÍ§payload‚¤role©assistant§contentÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.ªfocus_kind¬exec_latency¨query_id¤Q096‰¢idÙ@51b79c7b62fdcd219e555ed114e6ca2f3eb3a946706e229bbd8d590369bf19d5¢tsËAÚó3ÂX¨trace_idÙ$a2da2776-a155-4e7a-829a-5736de66d416­parent_run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264ee¦run_idÙ$a2da2776-a155-4e7a-829a-5736de66d416ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.¨query_id¤Q096ªfocus_kind¶chain_execution_result‰¢idÙ@3b59223bb7e7c6c43d184803e3595c30f4f02e9418cece18f4cee21f1236a5c9¢tsËAÚó3Â”K¨trace_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264ee­parent_run_idÀ¦run_idÙ$30cebda2-9774-46d1-9622-f7d1bd6264eeªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙYWhat class enables you to get structured JSON output directly from LLMS without a parser?§context•‚´page_content_summaryÙË### Output parsers

[Output Parsers](/docs/concepts/output_parsers) are responsible for taking the output of an LLM and parsing into more structured format.

- [How to: parse text from message objects...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

- [How to: cache model responses](/docs/how_to/llm_cachin...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË### JSON mode

In addition to tool calling, some model providers support a feature called `JSON mode`. 
This supports JSON schema definition as input and enforces the model to produce a conforming JSO...¨metadata¦sourceÙQ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/structured_outputs.mdx‚´page_content_summaryÙË| [Structured](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.structured.StructuredOutputParser.html#langchain.output_parsers.structured.StructuredOutputP...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx‚´page_content_summaryÙÍ| [JSON](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html)                                                     | âœ…               ...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/output_parsers.mdx¦answerÚWThe class that enables you to get structured JSON output directly from LLMs without a parser is the `JsonOutputParser`. It returns a JSON object as specified and can work with Pydantic models to ensure the output conforms to the desired structure. This makes it a reliable option for obtaining structured data without additional parsing steps.¨query_id¤Q096ªfocus_kind¶chain_execution_result‹¢idÙ@190b93e5f164b7de09ea928e4af71c0277b9b041fd9032d130f553cbe062acd4¢tsËAÚó3Â˜»¨trace_id¤Q097­parent_run_idÀ¦run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130bªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.¨query_id¤Q097§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q097ªfocus_kind¯chain_execution‹¢idÙ@f84ce9151477d711412146e14e7a6ef5d5e98ef34bf21cf107a1d19713a41740¢tsËAÚó3Â Â¨trace_id¤Q097­parent_run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130b¦run_idÙ$bd84d645-b650-4df6-b58b-b72d60f88468ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.§context¦answer ¨query_id¤Q097¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q097®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:8fd4f05a-ae61-cfde-de12-90009e4fa478ªfocus_kind¯chain_execution‰¢idÙ@f00b4744d7006bac647dc90a699a6f057e9844de03cff846962f24029fa7a420¢tsËAÚó3ÒØõ¨trace_idÙ$bd84d645-b650-4df6-b58b-b72d60f88468­parent_run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130b¦run_idÙ$bd84d645-b650-4df6-b58b-b72d60f88468ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¨query_id¤Q097ªfocus_kind¶chain_execution_result‹¢idÙ@1dc637741b21d1308742cd3503a1ed1f5174155e3eb49062d9dd199bce2da822¢tsËAÚó3ÒáÒ¨trace_id¤Q097­parent_run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130b¦run_idÙ$c38790f3-b995-4999-93a1-3daf327ef8a7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<Name three built in message field keys aside from `content`.§context•‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¦answer ¨query_id¤Q097¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q097®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d774be9e-2b43-fd7f-9962-d2ccf192cdb7ªfocus_kind¯chain_execution‹¢idÙ@654b4daa01fba1f9c4d948328104207e1abaae534b9f223ad99c4bd4109271e1¢tsËAÚó3Òæ2¨trace_id¤Q097­parent_run_idÙ$c38790f3-b995-4999-93a1-3daf327ef8a7¦run_idÙ$d5e01698-fb66-432c-bae6-54c6c51ce5c4ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ<Name three built in message field keys aside from `content`.§contextÚÇ### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary between different chat model providers.

Currently, most chat models support text as the primary content type, with some models also supporting multimodal data. However, support for multimodal data is still limited across most chat model providers.

For more information see:
* [SystemMessage](#systemmessage) -- for content which should be passed to direct the conversation
* [HumanMessage](#humanmessage) -- for content in the input from the user.
* [AIMessage](#aimessage) -- for content in the response from the model.
* [Multimodality](/docs/concepts/multimodality) -- for more information on multimodal content.

### Other Message Data

Depending on the chat model provider, messages can include other data such as:

| Attribute            | Standardized/Raw | Description                                                                                                                                                                                                             |
|----------------------|:-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `content`            | Raw              | Usually a string, but can be a list of content blocks. See [content](#content) for details.                                                                                                                             |

## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the message (e.g., text, multimodal data).
- Additional metadata: id, name, [token usage](/docs/concepts/tokens) and other model-specific metadata.

### Role

Roles are used to distinguish between different types of messages in a conversation and help the chat model understand how to respond to a given sequence of messages.

# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to represent the input and output of a chat model, as well as any additional context or metadata that may be associated with a conversation.

Each message has a **role** (e.g., "user", "assistant") and **content** (e.g., text, multimodal data) with additional metadata that varies depending on the chat model provider.

LangChain provides a unified message format that can be used across chat models, allowing users to work with different chat models without worrying about the specific details of the message format used by each model provider.

## What is inside a message?

A message typically consists of the following pieces of information:

#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list of dictionaries** -- Each dictionary represents a content block and is associated with a `type`.
    * Used by Anthropic for surfacing agent thought process when doing [tool calling](/docs/concepts/tool_calling).
    * Used by OpenAI for audio outputs. Please see [multi-modal content](/docs/concepts/multimodality) for more information.

:::important
The **content** property is **not** standardized across different chat model providers, mostly because there are
still few examples to generalize from.
:::

### AIMessageChunk

It is common to [stream](/docs/concepts/streaming) responses for the chat model as they are being generated, so the user can see the response in real-time instead of waiting for the entire response to be generated before displaying it.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q097®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:d774be9e-2b43-fd7f-9962-d2ccf192cdb7­checkpoint_nsÙ-generate:d774be9e-2b43-fd7f-9962-d2ccf192cdb7¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@49a2bdff6676779af838829f2f9bbf9be02bce92e68d7f14e60660395e706206¢tsËAÚó3Òì)¨trace_idÙ$d5e01698-fb66-432c-bae6-54c6c51ce5c4­parent_run_idÙ$c38790f3-b995-4999-93a1-3daf327ef8a7¦run_idÙ$d5e01698-fb66-432c-bae6-54c6c51ce5c4ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ§messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Name three built in message field keys aside from `content`. \nContext: ### Content\n\nThe content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary between different chat model providers.\n\nCurrently, most chat models support text as the primary content type, with some models also supporting multimodal data. However, support for multimodal data is still limited across most chat model providers.\n\nFor more information see:\n* [SystemMessage](#systemmessage) -- for content which should be passed to direct the conversation\n* [HumanMessage](#humanmessage) -- for content in the input from the user.\n* [AIMessage](#aimessage) -- for content in the response from the model.\n* [Multimodality](/docs/concepts/multimodality) -- for more information on multimodal content.\n\n### Other Message Data\n\nDepending on the chat model provider, messages can include other data such as:\n\n| Attribute            | Standardized/Raw | Description                                                                                                                                                                                                             |\n|----------------------|:-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `content`            | Raw              | Usually a string, but can be a list of content blocks. See [content](#content) for details.                                                                                                                             |\n\n## What is inside a message?\n\nA message typically consists of the following pieces of information:\n\n- **Role**: The role of the message (e.g., "user", "assistant").\n- **Content**: The content of the message (e.g., text, multimodal data).\n- Additional metadata: id, name, [token usage](/docs/concepts/tokens) and other model-specific metadata.\n\n### Role\n\nRoles are used to distinguish between different types of messages in a conversation and help the chat model understand how to respond to a given sequence of messages.\n\n# Messages\n\n:::info Prerequisites\n- [Chat Models](/docs/concepts/chat_models)\n:::\n\n## Overview\n\nMessages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to represent the input and output of a chat model, as well as any additional context or metadata that may be associated with a conversation.\n\nEach message has a **role** (e.g., "user", "assistant") and **content** (e.g., text, multimodal data) with additional metadata that varies depending on the chat model provider.\n\nLangChain provides a unified message format that can be used across chat models, allowing users to work with different chat models without worrying about the specific details of the message format used by each model provider.\n\n## What is inside a message?\n\nA message typically consists of the following pieces of information:\n\n#### content\n\nThe **content** property of an `AIMessage` represents the response generated by the chat model.\n\nThe content is either:\n\n- **text** -- the norm for virtually all chat models.\n- A **list of dictionaries** -- Each dictionary represents a content block and is associated with a `type`.\n    * Used by Anthropic for surfacing agent thought process when doing [tool calling](/docs/concepts/tool_calling).\n    * Used by OpenAI for audio outputs. Please see [multi-modal content](/docs/concepts/multimodality) for more information.\n\n:::important\nThe **content** property is **not** standardized across different chat model providers, mostly because there are\nstill few examples to generalize from.\n:::\n\n### AIMessageChunk\n\nIt is common to [stream](/docs/concepts/streaming) responses for the chat model as they are being generated, so the user can see the response in real-time instead of waiting for the entire response to be generated before displaying it. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@a7995adb07b5a8aee8eed941bc1b248bc4b3baf5c12d3e78a1cc8758a33e288d¢tsËAÚó4^¹Z¨focus_msÍˆ§payload‚¤role©assistant§contentÚ%Three built-in message field keys aside from `content` are `role`, `id`, and `name`. The `role` distinguishes between different types of messages, while `id` and `name` serve as additional metadata. These keys help in organizing and understanding the context of the messages in a conversation.ªfocus_kind¬exec_latency¨query_id¤Q097‰¢idÙ@73cb434c0656988f4e95fc94a6509f3468ceb3830d7512f48fb36f6b1bb6eb9c¢tsËAÚó4^Ìó¨trace_idÙ$c38790f3-b995-4999-93a1-3daf327ef8a7­parent_run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130b¦run_idÙ$c38790f3-b995-4999-93a1-3daf327ef8a7ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ%Three built-in message field keys aside from `content` are `role`, `id`, and `name`. The `role` distinguishes between different types of messages, while `id` and `name` serve as additional metadata. These keys help in organizing and understanding the context of the messages in a conversation.¨query_id¤Q097ªfocus_kind¶chain_execution_result‰¢idÙ@5d097247e8787d42ba9ff4451fcbe11bca6b7878513e6643ccb4f44953d9b76c¢tsËAÚó4^Õ¦¨trace_idÙ$95df2c41-2927-4d66-b6de-13c7de90130b­parent_run_idÀ¦run_idÙ$95df2c41-2927-4d66-b6de-13c7de90130bªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ<Name three built in message field keys aside from `content`.§context•‚´page_content_summaryÙË### Content

The content of a message text or a list of dictionaries representing [multimodal data](/docs/concepts/multimodality) (e.g., images, audio, video). The exact format of the content can vary...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË| Attribute            | Standardized/Raw | Description                                                                                                                                                 ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË## What is inside a message?

A message typically consists of the following pieces of information:

- **Role**: The role of the message (e.g., "user", "assistant").
- **Content**: The content of the m...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË# Messages

:::info Prerequisites
- [Chat Models](/docs/concepts/chat_models)
:::

## Overview

Messages are the unit of communication in [chat models](/docs/concepts/chat_models). They are used to re...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx‚´page_content_summaryÙË#### content

The **content** property of an `AIMessage` represents the response generated by the chat model.

The content is either:

- **text** -- the norm for virtually all chat models.
- A **list ...¨metadata¦sourceÙG/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/messages.mdx¦answerÚ%Three built-in message field keys aside from `content` are `role`, `id`, and `name`. The `role` distinguishes between different types of messages, while `id` and `name` serve as additional metadata. These keys help in organizing and understanding the context of the messages in a conversation.¨query_id¤Q097ªfocus_kind¶chain_execution_result‹¢idÙ@ca1ba1f04fa2de0479c39ac4621c71a970e52ecdd3fb7b53485ad29b080796cb¢tsËAÚó4^İb¨trace_id¤Q098­parent_run_idÀ¦run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?¨query_id¤Q098§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q098ªfocus_kind¯chain_execution‹¢idÙ@d62997a6d45960646aa7bed1718c45a37355208042f10699e3cff4dc2b6c5dd1¢tsËAÚó4^æh¨trace_id¤Q098­parent_run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402¦run_idÙ$8a56404c-efad-4f36-8eea-a8d142b630e9ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context¦answer ¨query_id¤Q098¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q098®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:119b190b-f3b6-befb-bb38-b414c91085dbªfocus_kind¯chain_execution‰¢idÙ@80a1c1a19d6227751d39698d7784e8e7ff51e3b2c594a352b578b3502db10979¢tsËAÚó4uß¨trace_idÙ$8a56404c-efad-4f36-8eea-a8d142b630e9­parent_run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402¦run_idÙ$8a56404c-efad-4f36-8eea-a8d142b630e9ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q098ªfocus_kind¶chain_execution_result‹¢idÙ@ef3bae4865fe8a68429142e6072961e260e0883bc418220e7eb6021d605dad35¢tsËAÚó4u"¼¨trace_id¤Q098­parent_run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402¦run_idÙ$b058644a-aaa8-42e0-a24e-9cf4a3c9a061ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q098¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q098®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7db08287-4e09-4655-9afd-c81800d65fd4ªfocus_kind¯chain_execution‹¢idÙ@c28dafc155f5b07c2ffdbea704101909ce2ecbe864715485c16a5fdecf67815a¢tsËAÚó4u&|¨trace_id¤Q098­parent_run_idÙ$b058644a-aaa8-42e0-a24e-9cf4a3c9a061¦run_idÙ$b66f149b-167b-49f0-a9ca-9260fb0dbe67ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§contextÚœ## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose
multiple Runnables and you need to add custom processing logic in one of the steps.

There are two ways to create a custom Runnable from a function:

* `RunnableLambda`: Use this for simple transformations where streaming is not required.
* `RunnableGenerator`: use this for more complex transformations when streaming is needed.

See the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.

:::important
Users should not try to subclass Runnables to create a new custom Runnable. It is
much more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.
:::

## Configurable runnables

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

Please refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.

Runnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.

* invoke: Accepts an input and returns an output.
* batch: Accepts a list of inputs and returns a list of outputs.
* stream: Accepts an input and returns a generator that yields outputs.

The **input type** and **output type** vary by component:

- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline's progress.

Streaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.

### 3. Streaming custom data

# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](
https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.

This guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q098®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7db08287-4e09-4655-9afd-c81800d65fd4­checkpoint_nsÙ-generate:7db08287-4e09-4655-9afd-c81800d65fd4¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@f99e821b451dbc9dafa44f880e67468061e4ed326cf46df3a61ccd5575f7153f¢tsËAÚó4u-¨trace_idÙ$b66f149b-167b-49f0-a9ca-9260fb0dbe67­parent_run_idÙ$b058644a-aaa8-42e0-a24e-9cf4a3c9a061¦run_idÙ$b66f149b-167b-49f0-a9ca-9260fb0dbe67ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ’messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the first step when creating a custom Runnable for streaming transformations? \nContext: ## Creating a runnable from a function {#custom-runnables}\n\nYou may need to create a custom Runnable that runs arbitrary logic. This is especially\nuseful if using [LangChain Expression Language (LCEL)](/docs/concepts/lcel) to compose\nmultiple Runnables and you need to add custom processing logic in one of the steps.\n\nThere are two ways to create a custom Runnable from a function:\n\n* `RunnableLambda`: Use this for simple transformations where streaming is not required.\n* `RunnableGenerator`: use this for more complex transformations when streaming is needed.\n\nSee the [How to run custom functions](/docs/how_to/functions) guide for more information on how to use `RunnableLambda` and `RunnableGenerator`.\n\n:::important\nUsers should not try to subclass Runnables to create a new custom Runnable. It is\nmuch more complex and error-prone than simply using `RunnableLambda` or `RunnableGenerator`.\n:::\n\n## Configurable runnables\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.\n\n## Input and output types\n\nEvery `Runnable` is characterized by an input and output type. These input and output types can be any Python object, and are defined by the Runnable itself.\n\nRunnable methods that result in the execution of the Runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) work with these input and output types.\n\n* invoke: Accepts an input and returns an output.\n* batch: Accepts a list of inputs and returns a list of outputs.\n* stream: Accepts an input and returns a generator that yields outputs.\n\nThe **input type** and **output type** vary by component:\n\n- **In LCEL Pipelines:**\nStreaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of the pipeline execute, you can stream which sub-runnable is currently running, providing real-time insight into the overall pipeline\'s progress.\n\nStreaming pipeline or workflow progress is essential in providing users with a clear picture of where the application is in the execution process.\n\n### 3. Streaming custom data\n\n# Runnable interface\n\nThe Runnable interface is the foundation for working with LangChain components, and it\'s implemented across many of them, such as [language models](/docs/concepts/chat_models), [output parsers](/docs/concepts/output_parsers), [retrievers](/docs/concepts/retrievers), [compiled LangGraph graphs](\nhttps://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph) and more.\n\nThis guide covers the main concepts and methods of the Runnable interface, which allows developers to interact with various LangChain components in a consistent and predictable manner. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@40134dc069841d37cef4eaa16d8b55b24610f482b21efa884431f117a2f0f21c¢tsËAÚó4è¹‰¨focus_msÍ§payload‚¤role©assistant§contentÚxThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be complex and error-prone. Instead, use these predefined options to implement your custom logic.ªfocus_kind¬exec_latency¨query_id¤Q098‰¢idÙ@169421e96ae4e6bfe66ed99acb219a4ca89c8d52d5c7ed4df9b75cfee2f19617¢tsËAÚó4èÎ†¨trace_idÙ$b058644a-aaa8-42e0-a24e-9cf4a3c9a061­parent_run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402¦run_idÙ$b058644a-aaa8-42e0-a24e-9cf4a3c9a061ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚxThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be complex and error-prone. Instead, use these predefined options to implement your custom logic.¨query_id¤Q098ªfocus_kind¶chain_execution_result‰¢idÙ@0c85993a9b99cb89be2b7d30604c04a7139029b74fe4d7c8b223068e3e5128a8¢tsËAÚó4èÚ#¨trace_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402­parent_run_idÀ¦run_idÙ$22319897-fc8a-47d7-90b8-4b63e08e9402ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙUWhat is the first step when creating a custom Runnable for streaming transformations?§context•‚´page_content_summaryÙË## Creating a runnable from a function {#custom-runnables}

You may need to create a custom Runnable that runs arbitrary logic. This is especially
useful if using [LangChain Expression Language (LCEL)...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPlease refer to the [Streaming Conceptual Guide](/docs/concepts/streaming) for more details on how to stream in LangChain.

## Input and output types

Every `Runnable` is characterized by an input and...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË- **In LCEL Pipelines:**
Streaming updates from an [LCEL](/docs/concepts/lcel) pipeline involves capturing progress from individual **sub-runnables**. For example, as different steps or components of ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË# Runnable interface

The Runnable interface is the foundation for working with LangChain components, and it's implemented across many of them, such as [language models](/docs/concepts/chat_models), [...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚxThe first step when creating a custom Runnable for streaming transformations is to choose between `RunnableLambda` for simple transformations or `RunnableGenerator` for more complex transformations that require streaming. It's important to avoid subclassing Runnables, as it can be complex and error-prone. Instead, use these predefined options to implement your custom logic.¨query_id¤Q098ªfocus_kind¶chain_execution_result‹¢idÙ@b21e14ac15fae4e2c5caa0a4fd64e70c1cbd9cf96272ad820b7aa8d98ed968b9¢tsËAÚó4èâÖ¨trace_id¤Q099­parent_run_idÀ¦run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8eªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?¨query_id¤Q099§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q099ªfocus_kind¯chain_execution‹¢idÙ@4aeeff9218cc28a8b548be9ba0f5ec4b41038dc682175cec874dbee026ebbd61¢tsËAÚó4èõ¡¨trace_id¤Q099­parent_run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8e¦run_idÙ$b450a4d1-13d6-451e-950d-64dc59043293ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context¦answer ¨query_id¤Q099¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q099®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:49dc4be0-a576-20d8-466a-3a4a5bf0a6b8ªfocus_kind¯chain_execution‰¢idÙ@91d90ded597eb273ee5f443d5967e7ceceac42433a8b8be69a9f5ef7aff51ac6¢tsËAÚó4ú%%¨trace_idÙ$b450a4d1-13d6-451e-950d-64dc59043293­parent_run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8e¦run_idÙ$b450a4d1-13d6-451e-950d-64dc59043293ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q099ªfocus_kind¶chain_execution_result‹¢idÙ@ac44a4c0a6fa05fc5559dbfe916f3248a857e43454a48448976cffcb093694e6¢tsËAÚó4ú/¾¨trace_id¤Q099­parent_run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8e¦run_idÙ$23a2cf68-9a7c-44f5-9f88-69219b3af0edªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q099¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q099®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7b5acd0a-bdf0-b129-1a16-f9083a93c2e1ªfocus_kind¯chain_execution‹¢idÙ@c9a105c25d9e761f2d12e2f9b49e54817613971b3c9fe6ea6b4e489c59c18385¢tsËAÚó4ú6D¨trace_id¤Q099­parent_run_idÙ$23a2cf68-9a7c-44f5-9f88-69219b3af0ed¦run_idÙ$ef2000d6-3990-4d7e-9c28-1ea9b90f5d2aªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§contextÚP## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: These are models that are officially supported by LangChain and/or model provider. You can find these models in the `langchain-<provider>` packages.
2. **Community models**: There are models that are mostly contributed and supported by the community. You can find these models in the `langchain-community` package.

LangChain chat models are named with a convention that prefixes "Chat" to their class names (e.g., `ChatOllama`, `ChatAnthropic`, `ChatOpenAI`, etc.).

Please review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.
This diversity can make it challenging for developers to switch between providers or combine components when building applications.
LangChain exposes a standard interface for key components, making it easy to switch between providers.

* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/integrations/chat/) for an up-to-date list of supported models.
* Use either LangChain's [messages](/docs/concepts/messages) format or OpenAI format.
* Standard [tool calling API](/docs/concepts/tool_calling): standard interface for binding tools to models, accessing tool call requests made by models, and sending tool results back to the model.
* Standard API for [structuring outputs](/docs/concepts/structured_outputs/#structured-output-method) via the `with_structured_output` method.
* Provides support for [async programming](/docs/concepts/async), [efficient batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), [a rich streaming API](/docs/concepts/streaming).

## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](/docs/how_to/tool_calling)
- [How to: stream runnables](/docs/how_to/streaming)
- [How to: debug your LLM apps](/docs/how_to/debugging/)

## Components

These are the core building blocks you can use when building applications.

### Chat models

[Chat Models](/docs/concepts/chat_models) are newer forms of language models that take messages in and output a message.
See [supported integrations](/docs/integrations/chat/) for details on getting started with chat models from a specific provider.

Please review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suffix in their name typically refer to older models that do not follow the chat model interface and instead use an interface that takes a string as input and returns a string as output.
:::


## Interface

LangChain chat models implement the [BaseChatModel](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) interface. Because `BaseChatModel` also implements the [Runnable Interface](/docs/concepts/runnables), chat models support a [standard streaming interface](/docs/concepts/streaming), [async programming](/docs/concepts/async), optimized [batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), and more. Please see the [Runnable Interface](/docs/concepts/runnables) for more details.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q099®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:7b5acd0a-bdf0-b129-1a16-f9083a93c2e1­checkpoint_nsÙ-generate:7b5acd0a-bdf0-b129-1a16-f9083a93c2e1¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@71895d51b5a25dc4a14f638a0c6a68febf5f6f30d9309b14640bf8fd8c200de8¢tsËAÚó4ú>É¨trace_idÙ$ef2000d6-3990-4d7e-9c28-1ea9b90f5d2a­parent_run_idÙ$23a2cf68-9a7c-44f5-9f88-69219b3af0ed¦run_idÙ$ef2000d6-3990-4d7e-9c28-1ea9b90f5d2aªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ6messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How does LangChain differentiate official vs community chat model integrations? \nContext: ## Integrations\n\nLangChain has many chat model integrations that allow you to use a wide variety of models from different providers.\n\nThese integrations are one of two types:\n\n1. **Official models**: These are models that are officially supported by LangChain and/or model provider. You can find these models in the `langchain-<provider>` packages.\n2. **Community models**: There are models that are mostly contributed and supported by the community. You can find these models in the `langchain-community` package.\n\nLangChain chat models are named with a convention that prefixes "Chat" to their class names (e.g., `ChatOllama`, `ChatAnthropic`, `ChatOpenAI`, etc.).\n\nPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.\n\n## Features\n\nThere are several primary needs that LangChain aims to address:\n\n1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components](/docs/integrations/vectorstores/) for AI applications has resulted in a wide variety of different APIs that developers need to learn and use.\nThis diversity can make it challenging for developers to switch between providers or combine components when building applications.\nLangChain exposes a standard interface for key components, making it easy to switch between providers.\n\n* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/integrations/chat/) for an up-to-date list of supported models.\n* Use either LangChain\'s [messages](/docs/concepts/messages) format or OpenAI format.\n* Standard [tool calling API](/docs/concepts/tool_calling): standard interface for binding tools to models, accessing tool call requests made by models, and sending tool results back to the model.\n* Standard API for [structuring outputs](/docs/concepts/structured_outputs/#structured-output-method) via the `with_structured_output` method.\n* Provides support for [async programming](/docs/concepts/async), [efficient batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), [a rich streaming API](/docs/concepts/streaming).\n\n## Key features\n\nThis highlights functionality that is core to using LangChain.\n\n- [How to: return structured data from a model](/docs/how_to/structured_output/)\n- [How to: use a model to call tools](/docs/how_to/tool_calling)\n- [How to: stream runnables](/docs/how_to/streaming)\n- [How to: debug your LLM apps](/docs/how_to/debugging/)\n\n## Components\n\nThese are the core building blocks you can use when building applications.\n\n### Chat models\n\n[Chat Models](/docs/concepts/chat_models) are newer forms of language models that take messages in and output a message.\nSee [supported integrations](/docs/integrations/chat/) for details on getting started with chat models from a specific provider.\n\nPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.\n\n:::note\nModels that do **not** include the prefix "Chat" in their name or include "LLM" as a suffix in their name typically refer to older models that do not follow the chat model interface and instead use an interface that takes a string as input and returns a string as output.\n:::\n\n\n## Interface\n\nLangChain chat models implement the [BaseChatModel](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) interface. Because `BaseChatModel` also implements the [Runnable Interface](/docs/concepts/runnables), chat models support a [standard streaming interface](/docs/concepts/streaming), [async programming](/docs/concepts/async), optimized [batching](/docs/concepts/runnables/#optimized-parallel-execution-batch), and more. Please see the [Runnable Interface](/docs/concepts/runnables) for more details. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2d36f13a7b147691e55e23c13d3711a76727a99dd4859c60facc3978c8fe9816¢tsËAÚó5^¨focus_msÍ§payload‚¤role©assistant§contentÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.ªfocus_kind¬exec_latency¨query_id¤Q099‰¢idÙ@7d5760e17b9ddf2a938f1f568be0011c9fb3b474e77b2f702a5dfb95d8c8fe99¢tsËAÚó5^¥Ó¨trace_idÙ$23a2cf68-9a7c-44f5-9f88-69219b3af0ed­parent_run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8e¦run_idÙ$23a2cf68-9a7c-44f5-9f88-69219b3af0edªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.¨query_id¤Q099ªfocus_kind¶chain_execution_result‰¢idÙ@73b964efaaa88344aba643571cad0a3594995b663036953844b547eda68f0395¢tsËAÚó5^²–¨trace_idÙ$25581861-537c-499f-bae4-3e67eda7ef8e­parent_run_idÀ¦run_idÙ$25581861-537c-499f-bae4-3e67eda7ef8eªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙOHow does LangChain differentiate official vs community chat model integrations?§context•‚´page_content_summaryÙË## Integrations

LangChain has many chat model integrations that allow you to use a wide variety of models from different providers.

These integrations are one of two types:

1. **Official models**: ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Features

There are several primary needs that LangChain aims to address:

1. **Standardized component interfaces:** The growing number of [models](/docs/integrations/chat/) and [related components...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË* Integrations with many chat model providers (e.g., Anthropic, OpenAI, Ollama, Microsoft Azure, Google Vertex, Amazon Bedrock, Hugging Face, Cohere, Groq). Please see [chat model integrations](/docs/...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË## Key features

This highlights functionality that is core to using LangChain.

- [How to: return structured data from a model](/docs/how_to/structured_output/)
- [How to: use a model to call tools](...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙËPlease review the [chat model integrations](/docs/integrations/chat/) for a list of supported models.

:::note
Models that do **not** include the prefix "Chat" in their name or include "LLM" as a suff...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚ®LangChain differentiates official and community chat model integrations based on their support and source. Official models are supported by LangChain and/or the model provider, found in the `langchain-<provider>` packages, while community models are contributed and supported by the community, located in the `langchain-community` package. This distinction helps users identify the level of support and reliability for each model.¨query_id¤Q099ªfocus_kind¶chain_execution_result‹¢idÙ@1cc68fb27c4a673f6598cf3414869df3b2691d0a07decdfd71c10835bde07b66¢tsËAÚó5^¼
¨trace_id¤Q100­parent_run_idÀ¦run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abbªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?¨query_id¤Q100§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q100ªfocus_kind¯chain_execution‹¢idÙ@80e6e147c21789d13978b0d7f3a7f7de046000465aaee0367f5ab6f2d4ceec8f¢tsËAÚó5^Å¨trace_id¤Q100­parent_run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abb¦run_idÙ$eea8d254-78dc-4717-b14e-02795564e664ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context¦answer ¨query_id¤Q100¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q100®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:b992fb87-b4da-ca8c-bae1-ddcc5058fe25ªfocus_kind¯chain_execution‰¢idÙ@d40bdff3f1cfb23bd940908dc1d34b6f5903a453ee771577e464ff7a6d150a5c¢tsËAÚó5»J¨trace_idÙ$eea8d254-78dc-4717-b14e-02795564e664­parent_run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abb¦run_idÙ$eea8d254-78dc-4717-b14e-02795564e664ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¨query_id¤Q100ªfocus_kind¶chain_execution_result‹¢idÙ@ead53651eab33e8874c8d314cdc5bd1a2962926d471acc48038aaf691db12108¢tsËAÚó5Åu¨trace_id¤Q100­parent_run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abb¦run_idÙ$eeb3ee92-5e4d-4d8a-87ac-331acc09ee8cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answer ¨query_id¤Q100¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q100®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9779d02f-ff09-51e4-a91d-1c0a421d274eªfocus_kind¯chain_execution‹¢idÙ@38a1f366c9e03ab3181b1e0f6bcbba8154e0f3502ab5d908a564b6f143565f2f¢tsËAÚó5Ê—¨trace_id¤Q100­parent_run_idÙ$eeb3ee92-5e4d-4d8a-87ac-331acc09ee8c¦run_idÙ$d2296231-8fb5-4267-acd9-9a2936958672ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§contextÚK### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs/how_to/example_selectors)
- [How to: select examples by length](/docs/how_to/example_selectors_length_based)
- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)
- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)
- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)
- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)

### LLMs

What LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.

# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).

This gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.
Sometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.

**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.

## Related resources

* [Example selector how-to guides](/docs/how_to/#example-selectors)

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |

:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).
* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).
* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).

:::

### Semantic meaning based

Unlike the previous methods, semantic-based splitting actually considers the *content* of the text. 
While other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.
There are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.
As an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q100®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:9779d02f-ff09-51e4-a91d-1c0a421d274e­checkpoint_nsÙ-generate:9779d02f-ff09-51e4-a91d-1c0a421d274e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@9dc4f102935998d454bfee6d3d26f8bc835611af217aa24f8fabbd359fce6ceb¢tsËAÚó5Ò[¨trace_idÙ$d2296231-8fb5-4267-acd9-9a2936958672­parent_run_idÙ$eeb3ee92-5e4d-4d8a-87ac-331acc09ee8c¦run_idÙ$d2296231-8fb5-4267-acd9-9a2936958672ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ6messages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: Which two sources explain creating example selectors based on semantic similarity? \nContext: ### Example selectors\n\n[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.\n\n- [How to: use example selectors](/docs/how_to/example_selectors)\n- [How to: select examples by length](/docs/how_to/example_selectors_length_based)\n- [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)\n- [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)\n- [How to: select examples by maximal marginal relevance](/docs/how_to/example_selectors_mmr)\n- [How to: select examples from LangSmith few-shot datasets](/docs/how_to/example_selectors_langsmith/)\n\n### LLMs\n\nWhat LangChain calls [LLMs](/docs/concepts/text_llms) are older forms of language models that take a string in and output a string.\n\n# Example selectors\n\n:::note Prerequisites\n\n- [Chat models](/docs/concepts/chat_models/)\n- [Few-shot prompting](/docs/concepts/few_shot_prompting/)\n:::\n\n## Overview\n\nOne common prompting technique for achieving better performance is to include examples as part of the prompt. This is known as [few-shot prompting](/docs/concepts/few_shot_prompting).\n\nThis gives the [language model](/docs/concepts/chat_models/) concrete examples of how it should behave.\nSometimes these examples are hardcoded into the prompt, but for more advanced situations it may be nice to dynamically select them.\n\n**Example Selectors** are classes responsible for selecting and then formatting examples into prompts.\n\n## Related resources\n\n* [Example selector how-to guides](/docs/how_to/#example-selectors)\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |\n\n:::info[Further reading]\n\n* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).\n* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive_json_splitter/).\n* See the how-to guide for [Code splitting](/docs/how_to/code_splitter/).\n* See the how-to guide for [HTML splitting](/docs/how_to/split_html/).\n\n:::\n\n### Semantic meaning based\n\nUnlike the previous methods, semantic-based splitting actually considers the *content* of the text. \nWhile other approaches use document or text structure as proxies for semantic meaning, this method directly analyzes the text's semantics.\nThere are several ways to implement this, but conceptually the approach is split text when there are significant changes in text *meaning*.\nAs an example, we can use a sliding window approach to generate embeddings, and compare the embeddings to find significant differences: \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@59f43d9a09c35cb2b3174deed2ea7ed5341fd0fd65d206206cfd09b90cf62a56¢tsËAÚó5Òq!¨focus_msÍë§payload‚¤role©assistant§contentÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)ªfocus_kind¬exec_latency¨query_id¤Q100‰¢idÙ@c7d6a7aec2b81e84a63172116953ef5f6441b8d99fdded089e354f4b2e20161f¢tsËAÚó5Ò|(¨trace_idÙ$eeb3ee92-5e4d-4d8a-87ac-331acc09ee8c­parent_run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abb¦run_idÙ$eeb3ee92-5e4d-4d8a-87ac-331acc09ee8cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)¨query_id¤Q100ªfocus_kind¶chain_execution_result‰¢idÙ@2b4382d4684902afbab3682d6aa99d003466d6d7345cb0caba92626554711467¢tsËAÚó5Ò‡è¨trace_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abb­parent_run_idÀ¦run_idÙ$9bca5a4a-5861-4e2b-9233-3a9e15680abbªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙRWhich two sources explain creating example selectors based on semantic similarity?§context•‚´page_content_summaryÙË### Example selectors

[Example Selectors](/docs/concepts/example_selectors) are responsible for selecting the correct few shot examples to pass to the prompt.

- [How to: use example selectors](/docs...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË# Example selectors

:::note Prerequisites

- [Chat models](/docs/concepts/chat_models/)
- [Few-shot prompting](/docs/concepts/few_shot_prompting/)
:::

## Overview

One common prompting technique for...¨metadata¦sourceÙP/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/example_selectors.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the how-to guide for [Markdown splitting](/docs/how_to/markdown_header_metadata_splitter/).
* See the how-to guide for [Recursive JSON splitting](/docs/how_to/recursive...¨metadata¦sourceÙM/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/text_splitters.mdx¦answerÚThe two sources that explain creating example selectors based on semantic similarity are:  
1. [How to: select examples by semantic similarity](/docs/how_to/example_selectors_similarity)  
2. [How to: select examples by semantic ngram overlap](/docs/how_to/example_selectors_ngram)¨query_id¤Q100ªfocus_kind¶chain_execution_result‹¢idÙ@d2025d3ebf3af18b2a5a7951aba031a413543f90eae294620685ec2ac64c3bf0¢tsËAÚó5Ò‘G¨trace_id¤Q101­parent_run_idÀ¦run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?¨query_id¤Q101§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q101ªfocus_kind¯chain_execution‹¢idÙ@3778fdc0dbcf9ce4f99d0d8ed38dc186f74c240b1ae45351beb9648eaf92122e¢tsËAÚó5Ò¡¨trace_id¤Q101­parent_run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1¦run_idÙ$32c5b976-00a6-4a00-a61d-6b66523a9430ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context¦answer ¨query_id¤Q101¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q101®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:d3da2d4f-6684-15dc-9e7b-2af0ce8eb416ªfocus_kind¯chain_execution‰¢idÙ@888af0bf2724124ba76c85e3a78bf4bb0377cceb841db359205fbddca21c4880¢tsËAÚó5ıER¨trace_idÙ$32c5b976-00a6-4a00-a61d-6b66523a9430­parent_run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1¦run_idÙ$32c5b976-00a6-4a00-a61d-6b66523a9430ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q101ªfocus_kind¶chain_execution_result‹¢idÙ@44844c21672c0c29e7d65b153c1678840662ffbee02bd122c21997bd6abbd587¢tsËAÚó5ıP±¨trace_id¤Q101­parent_run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1¦run_idÙ$f81a41da-7d06-4c2e-a199-b51ecdbc4186ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q101¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q101®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e3f32df0-d66f-87b2-d2bf-c3578e3373e2ªfocus_kind¯chain_execution‹¢idÙ@1db64b7b2c28978453a1c4582c001178fd514d3105de6d01c377ae492f538680¢tsËAÚó5ıZ‰¨trace_id¤Q101­parent_run_idÙ$f81a41da-7d06-4c2e-a199-b51ecdbc4186¦run_idÙ$fb701c98-a629-466b-8999-ed030b3c18daªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§contextÚöIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)  in Python 3.9 and 3.10 which did
not accept a `context` argument.

Propagating the `RunnableConfig` manually is done like so:

```python
async def foo(input, config): # <-- Note the config argument
    return await bar_runnable.ainvoke(input, config=config)
    
foo_runnable = RunnableLambda(foo)
```

:::caution
When using Python 3.10 or lower and writing async code, `RunnableConfig` cannot be propagated
automatically, and you will need to do it manually! This is a common pitfall when
attempting to stream data using `astream_events` and `astream_log` as these methods
rely on proper propagation of [callbacks](/docs/concepts/callbacks) defined inside of `RunnableConfig`.
:::

If you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableGenerator`, or `Tool` that invokes other runnables
and is running `async` in python&lt;=3.10, will have to propagate callbacks to child
objects manually. This is because LangChain cannot automatically propagate
callbacks to child objects in this case.

This is a common reason why you may fail to see events being emitted from custom
runnables or tools.
:::

For specifics on how to use callbacks, see the [relevant how-to guides here](/docs/how_to/#callbacks).

## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html#RunnableConfig)). This argument is a dictionary that contains configuration for the Runnable that will be used
at run time during the execution of the runnable.

A `RunnableConfig` can have any of the following properties defined:

1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnables)  (e.g., `RunnableLambda`) or using the `@tool` decorator:

    ```python
    def foo(input):
        # Note that .invoke() is used directly here
        return bar_runnable.invoke(input)
    foo_runnable = RunnableLambda(foo)
    ```

LangChain will try to propagate `RunnableConfig` automatically for both of the patterns. 

For handling the second pattern, LangChain relies on Python's [contextvars](https://docs.python.org/3/library/contextvars.html).

In Python 3.11 and above, this works out of the box, and you do not need to do anything special to propagate the `RunnableConfig` to the sub-calls.

In Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it.

Passing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'key': 'value'}
      
   }
)
```

### Propagation of RunnableConfig

Many `Runnables` are composed of other Runnables, and it is important that the `RunnableConfig` is propagated to all sub-calls made by the Runnable. This allows providing run time configuration values to the parent Runnable that are inherited by all sub-calls.

If this were not the case, it would be impossible to set and propagate [callbacks](/docs/concepts/callbacks) or other configuration values like `tags` and `metadata` which
are expected to be inherited by all sub-calls.

There are two main patterns by which new `Runnables` are created:

1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q101®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:e3f32df0-d66f-87b2-d2bf-c3578e3373e2­checkpoint_nsÙ-generate:e3f32df0-d66f-87b2-d2bf-c3578e3373e2¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@e6d0f57e43763e41d6855e5c07d2c9fb30ad2b2733ed60deebcd174ee5d4032d¢tsËAÚó5ıb_¨trace_idÙ$fb701c98-a629-466b-8999-ed030b3c18da­parent_run_idÙ$f81a41da-7d06-4c2e-a199-b51ecdbc4186¦run_idÙ$fb701c98-a629-466b-8999-ed030b3c18daªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content="You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the impact of not propagating `RunnableConfig` in Python 3.10 async code? \nContext: In Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. \n\nThis is due to a limitation in [asyncio's tasks](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)  in Python 3.9 and 3.10 which did\nnot accept a `context` argument.\n\nPropagating the `RunnableConfig` manually is done like so:\n\n```python\nasync def foo(input, config): # <-- Note the config argument\n    return await bar_runnable.ainvoke(input, config=config)\n    \nfoo_runnable = RunnableLambda(foo)\n```\n\n:::caution\nWhen using Python 3.10 or lower and writing async code, `RunnableConfig` cannot be propagated\nautomatically, and you will need to do it manually! This is a common pitfall when\nattempting to stream data using `astream_events` and `astream_log` as these methods\nrely on proper propagation of [callbacks](/docs/concepts/callbacks) defined inside of `RunnableConfig`.\n:::\n\nIf you're creating a custom chain or runnable, you need to remember to propagate request time\ncallbacks to any child objects.\n\n:::important Async in Python&lt;=3.10\n\nAny `RunnableLambda`, a `RunnableGenerator`, or `Tool` that invokes other runnables\nand is running `async` in python&lt;=3.10, will have to propagate callbacks to child\nobjects manually. This is because LangChain cannot automatically propagate\ncallbacks to child objects in this case.\n\nThis is a common reason why you may fail to see events being emitted from custom\nrunnables or tools.\n:::\n\nFor specifics on how to use callbacks, see the [relevant how-to guides here](/docs/how_to/#callbacks).\n\n## RunnableConfig\n\nAny of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called\n`RunnableConfig` ([API Reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html#RunnableConfig)). This argument is a dictionary that contains configuration for the Runnable that will be used\nat run time during the execution of the runnable.\n\nA `RunnableConfig` can have any of the following properties defined:\n\n1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):\n\n    ```python\n    chain = prompt | chat_model | output_parser\n    ```\n\n2. Using a [custom Runnable](#custom-runnables)  (e.g., `RunnableLambda`) or using the `@tool` decorator:\n\n    ```python\n    def foo(input):\n        # Note that .invoke() is used directly here\n        return bar_runnable.invoke(input)\n    foo_runnable = RunnableLambda(foo)\n    ```\n\nLangChain will try to propagate `RunnableConfig` automatically for both of the patterns. \n\nFor handling the second pattern, LangChain relies on Python's [contextvars](https://docs.python.org/3/library/contextvars.html).\n\nIn Python 3.11 and above, this works out of the box, and you do not need to do anything special to propagate the `RunnableConfig` to the sub-calls.\n\nIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it.\n\nPassing `config` to the `invoke` method is done like so:\n\n```python\nsome_runnable.invoke(\n   some_input, \n   config={\n      'run_name': 'my_run', \n      'tags': ['tag1', 'tag2'], \n      'metadata': {'key': 'value'}\n      \n   }\n)\n```\n\n### Propagation of RunnableConfig\n\nMany `Runnables` are composed of other Runnables, and it is important that the `RunnableConfig` is propagated to all sub-calls made by the Runnable. This allows providing run time configuration values to the parent Runnable that are inherited by all sub-calls.\n\nIf this were not the case, it would be impossible to set and propagate [callbacks](/docs/concepts/callbacks) or other configuration values like `tags` and `metadata` which\nare expected to be inherited by all sub-calls.\n\nThere are two main patterns by which new `Runnables` are created:\n\n1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):\n\n    ```python\n    chain = prompt | chat_model | output_parser\n    ``` \nAnswer:", additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@f498c3b7b4457891b076066b4db4c4f5d882d5b272ce298d7833cdd12b765c09¢tsËAÚó6q~³¨focus_msÍ§payload‚¤role©assistant§contentÚÃNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, you may fail to see events emitted from custom runnables or tools, which can hinder functionality.ªfocus_kind¬exec_latency¨query_id¤Q101‰¢idÙ@77fdcf4ac195b8cc0c00a895276ba61542162da6f577bf21f1ff16c1339c5e31¢tsËAÚó6qœZ¨trace_idÙ$f81a41da-7d06-4c2e-a199-b51ecdbc4186­parent_run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1¦run_idÙ$f81a41da-7d06-4c2e-a199-b51ecdbc4186ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚÃNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, you may fail to see events emitted from custom runnables or tools, which can hinder functionality.¨query_id¤Q101ªfocus_kind¶chain_execution_result‰¢idÙ@a40dfdb57905c782beec5b881d88e0fc628b46e617ad1aca59a58ad8352548da¢tsËAÚó6q¬Ú¨trace_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1­parent_run_idÀ¦run_idÙ$a5433c67-c236-4266-a44e-a12a78c483a1ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙQWhat is the impact of not propagating `RunnableConfig` in Python 3.10 async code?§context•‚´page_content_summaryÙËIn Python 3.9 and 3.10, if you are using **async code**, you need to manually pass the `RunnableConfig` through to the `Runnable` when invoking it. 

This is due to a limitation in [asyncio's tasks](h...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËIf you're creating a custom chain or runnable, you need to remember to propagate request time
callbacks to any child objects.

:::important Async in Python&lt;=3.10

Any `RunnableLambda`, a `RunnableG...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/callbacks.mdx‚´page_content_summaryÙË## RunnableConfig

Any of the methods that are used to execute the runnable (e.g., `invoke`, `batch`, `stream`, `astream_events`) accept a second argument called
`RunnableConfig` ([API Reference](http...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË1. Declaratively using [LangChain Expression Language (LCEL)](/docs/concepts/lcel):

    ```python
    chain = prompt | chat_model | output_parser
    ```

2. Using a [custom Runnable](#custom-runnabl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËPassing `config` to the `invoke` method is done like so:

```python
some_runnable.invoke(
   some_input, 
   config={
      'run_name': 'my_run', 
      'tags': ['tag1', 'tag2'], 
      'metadata': {'...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÚÃNot propagating `RunnableConfig` in Python 3.10 async code can lead to issues where callbacks and configuration values, such as tags and metadata, are not inherited by sub-calls. This manual propagation is necessary because `asyncio` tasks in Python 3.9 and 3.10 do not accept a `context` argument, making automatic propagation impossible. As a result, you may fail to see events emitted from custom runnables or tools, which can hinder functionality.¨query_id¤Q101ªfocus_kind¶chain_execution_result‹¢idÙ@d5d6bd8c39160003d4aeab05f8e05bc1db510904074334b71c8153e3f6891766¢tsËAÚó6q¿Ê¨trace_id¤Q102­parent_run_idÀ¦run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.¨query_id¤Q102§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q102ªfocus_kind¯chain_execution‹¢idÙ@cc5d1c275527ee78efefe512c015f01cce94542745199492d773e9e9d1c75f40¢tsËAÚó6qĞO¨trace_id¤Q102­parent_run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511¦run_idÙ$1bf3384b-b477-4b38-b234-e02a9aed1474ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context¦answer ¨query_id¤Q102¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q102®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:0afb5d36-2b5b-753f-e7e9-aeaa6c69f85fªfocus_kind¯chain_execution‰¢idÙ@3bb25530f91d87dc135a2d511135319cf04ac9fcafaf6c7c9826c9c6501f4c57¢tsËAÚó6…|¨trace_idÙ$1bf3384b-b477-4b38-b234-e02a9aed1474­parent_run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511¦run_idÙ$1bf3384b-b477-4b38-b234-e02a9aed1474ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¨query_id¤Q102ªfocus_kind¶chain_execution_result‹¢idÙ@da14f5b2ad5280a24eff87ec38cec120d97375ec212654b46fb5fa5a775b7220¢tsËAÚó6…„¨trace_id¤Q102­parent_run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511¦run_idÙ$2d463a70-3240-4628-8b1a-92d780585b72ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¦answer ¨query_id¤Q102¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q102®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:0159971a-06c4-cc04-6778-58313fc6afa0ªfocus_kind¯chain_execution‹¢idÙ@be4b1ca6a49d45f10a936b8df6a1e6a01a5ca9669630e3c69fefc291ce20b7b0¢tsËAÚó6…‰¨trace_id¤Q102­parent_run_idÙ$2d463a70-3240-4628-8b1a-92d780585b72¦run_idÙ$43fdb331-1a2e-407c-ae0a-106831e68843ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§contextÚ¶You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool's schema.

### InjectedToolArg

There are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool's schema.

For example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:

```python
from langchain_core.tools import tool, InjectedToolArg

@tool
def user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:
    """Tool that processes input data."""
    return f"User {user_id} processed {input_data}"
```

See [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's function signature to configure the run time behavior of the tool.

The following type annotations will end up **removing** the argument from the tool's schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.

- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.
- **RunnableConfig**: Pass in the RunnableConfig object to the tool.
- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.
- **InjectedStore**: Pass in the LangGraph store object to the tool.

You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

The key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schema for the tool's arguments.

The key methods to execute the function associated with the **tool**:

- **invoke**: Invokes the tool with the given arguments.
- **ainvoke**: Invokes the tool with the given arguments, asynchronously. Used for [async programming with Langchain](/docs/concepts/async).

## Create tools using the `@tool` decorator

@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value": "some_value"}})
```

The `config` will not be part of the tool's schema and will be injected at runtime with appropriate values.

:::note
You may need to access the `config` object to manually propagate it to subclass. This happens if you're working with python 3.9 / 3.10 in an [async](/docs/concepts/async) environment and need to manually propagate the `config` object to sub-calls.

Please read [Propagation RunnableConfig](/docs/concepts/runnables/#propagation-of-runnableconfig) for more details to learn how to propagate the `RunnableConfig` down the call chain manually (or upgrade to Python 3.11 where this is no longer an issue).
:::

### InjectedState

## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).

Please see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.

## Tool artifacts¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q102®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:0159971a-06c4-cc04-6778-58313fc6afa0­checkpoint_nsÙ-generate:0159971a-06c4-cc04-6778-58313fc6afa0¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@32e923b4cde037c6d165c2a2c6b30717641f5fc3a488a136c81fbadc1da1ba9f¢tsËAÚó6…d¨trace_idÙ$43fdb331-1a2e-407c-ae0a-106831e68843­parent_run_idÙ$2d463a70-3240-4628-8b1a-92d780585b72¦run_idÙ$43fdb331-1a2e-407c-ae0a-106831e68843ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ¾messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Describe the `@tool` option to hide a parameter while still injecting it at runtime. \nContext: You can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\n- **Annotated[..., "string literal"]** -- Adds a description to the argument that will be exposed in the tool\'s schema.\n\n### InjectedToolArg\n\nThere are cases where certain arguments need to be passed to a tool at runtime but should not be generated by the model itself. For this, we use the `InjectedToolArg` annotation, which allows certain parameters to be hidden from the tool\'s schema.\n\nFor example, if a tool requires a `user_id` to be injected dynamically at runtime, it can be structured in this way:\n\n```python\nfrom langchain_core.tools import tool, InjectedToolArg\n\n@tool\ndef user_specific_tool(input_data: str, user_id: InjectedToolArg) -> str:\n    """Tool that processes input data."""\n    return f"User {user_id} processed {input_data}"\n```\n\nSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.\n\n## Special type annotations\n\nThere are a number of special type annotations that can be used in the tool\'s function signature to configure the run time behavior of the tool.\n\nThe following type annotations will end up **removing** the argument from the tool\'s schema. This can be useful for arguments that should not be exposed to the model and that the model should not be able to control.\n\n- **InjectedToolArg**: Value should be injected manually at runtime using `.invoke` or `.ainvoke`.\n- **RunnableConfig**: Pass in the RunnableConfig object to the tool.\n- **InjectedState**: Pass in the overall state of the LangGraph graph to the tool.\n- **InjectedStore**: Pass in the LangGraph store object to the tool.\n\nYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool\'s schema.\n\nThe key attributes that correspond to the tool\'s **schema**:\n\n- **name**: The name of the tool.\n- **description**: A description of what the tool does.\n- **args**: Property that returns the JSON schema for the tool\'s arguments.\n\nThe key methods to execute the function associated with the **tool**:\n\n- **invoke**: Invokes the tool with the given arguments.\n- **ainvoke**: Invokes the tool with the given arguments, asynchronously. Used for [async programming with Langchain](/docs/concepts/async).\n\n## Create tools using the `@tool` decorator\n\n@tool\nasync def some_func(..., config: RunnableConfig) -> ...:\n    """Tool that does something."""\n    # do something with config\n    ...\n\nawait some_func.ainvoke(..., config={"configurable": {"value": "some_value"}})\n```\n\nThe `config` will not be part of the tool\'s schema and will be injected at runtime with appropriate values.\n\n:::note\nYou may need to access the `config` object to manually propagate it to subclass. This happens if you\'re working with python 3.9 / 3.10 in an [async](/docs/concepts/async) environment and need to manually propagate the `config` object to sub-calls.\n\nPlease read [Propagation RunnableConfig](/docs/concepts/runnables/#propagation-of-runnableconfig) for more details to learn how to propagate the `RunnableConfig` down the call chain manually (or upgrade to Python 3.11 where this is no longer an issue).\n:::\n\n### InjectedState\n\n## Configuring the schema\n\nThe `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description\nor parse the function\'s doc-string to infer the schema).\n\nPlease see the [API reference for @tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for more details and review the [how to create custom tools](/docs/how_to/custom_tools/) guide for examples.\n\n## Tool artifacts \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@f9890ef107e4b5cd51537b8c087481f54e949248bb3393ad323dec324d9ffe40¢tsËAÚó7ÍS¨focus_msÍ`§payload‚¤role©assistant§contentÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.ªfocus_kind¬exec_latency¨query_id¤Q102‰¢idÙ@251e87d35eaf1e30eade54a5b9c79ea858388677811dadbb51de08220cde6f3f¢tsËAÚó7Õˆ¨trace_idÙ$2d463a70-3240-4628-8b1a-92d780585b72­parent_run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511¦run_idÙ$2d463a70-3240-4628-8b1a-92d780585b72ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.¨query_id¤Q102ªfocus_kind¶chain_execution_result‰¢idÙ@5b132d22d2568628a7fd7d9a64feaae58912eda761f8b2d3e6f695599c0b5f88¢tsËAÚó7Ü­¨trace_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511­parent_run_idÀ¦run_idÙ$89840d7f-c8a4-4132-bdb8-51af1b468511ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙTDescribe the `@tool` option to hide a parameter while still injecting it at runtime.§context•‚´page_content_summaryÙËYou can also use the `Annotated` type with a string literal to provide a **description** for the corresponding argument that **WILL** be exposed in the tool's schema.

- **Annotated[..., "string liter...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËSee [how to return artifacts from tools](/docs/how_to/tool_artifacts/) for more details.

## Special type annotations

There are a number of special type annotations that can be used in the tool's fun...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙËThe key attributes that correspond to the tool's **schema**:

- **name**: The name of the tool.
- **description**: A description of what the tool does.
- **args**: Property that returns the JSON schem...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË@tool
async def some_func(..., config: RunnableConfig) -> ...:
    """Tool that does something."""
    # do something with config
    ...

await some_func.ainvoke(..., config={"configurable": {"value"...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx‚´page_content_summaryÙË## Configuring the schema

The `@tool` decorator offers additional options to configure the schema of the tool (e.g., modify name, description
or parse the function's doc-string to infer the schema).
...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tools.mdx¦answerÚ˜The `@tool` option allows the use of the `InjectedToolArg` annotation to hide certain parameters from the tool's schema while still injecting them at runtime. This is useful for arguments that should not be exposed to the model, such as a `user_id` that is dynamically provided. By using `InjectedToolArg`, these parameters can be passed manually during invocation without being visible in the tool's schema.¨query_id¤Q102ªfocus_kind¶chain_execution_result‹¢idÙ@5dbef55fa7d7f9363768292dd4f5135d4109d9a758c065216686c31addb13474¢tsËAÚó7ãH¨trace_id¤Q103­parent_run_idÀ¦run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6eeªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?¨query_id¤Q103§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q103ªfocus_kind¯chain_execution‹¢idÙ@98dc35a1c6b7112e73e8b455c75d30f4be1c68bf51f22ea66ede8a5d7d6f573c¢tsËAÚó7ëÀ¨trace_id¤Q103­parent_run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6ee¦run_idÙ$9cf3baa1-2bbc-4117-80ea-c09fb0c9a0bcªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context¦answer ¨query_id¤Q103¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q103®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:e06020c3-7fd7-8e37-21f8-99b320643462ªfocus_kind¯chain_execution‰¢idÙ@d96a7b6e65c06d78ac2dda05294a62d1e49f800819561c1d035b72902b47a648¢tsËAÚó77¨trace_idÙ$9cf3baa1-2bbc-4117-80ea-c09fb0c9a0bc­parent_run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6ee¦run_idÙ$9cf3baa1-2bbc-4117-80ea-c09fb0c9a0bcªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¨query_id¤Q103ªfocus_kind¶chain_execution_result‹¢idÙ@2f1b8efe53cda2348a9a451df744b8897f1c85ac369de95d32ef9d5074794e5e¢tsËAÚó7=†¨trace_id¤Q103­parent_run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6ee¦run_idÙ$c30cd1de-7fde-48f5-8045-b14088e15970ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answer ¨query_id¤Q103¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q103®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5c24b82a-a150-fd3b-0815-3cf7c8ddd20eªfocus_kind¯chain_execution‹¢idÙ@9fb175d38a24adab52cf09116c9d7bf942b1687e9a45538cdd0affac614dd34c¢tsËAÚó7A¦¨trace_id¤Q103­parent_run_idÙ$c30cd1de-7fde-48f5-8045-b14088e15970¦run_idÙ$c687542e-d306-4455-94fa-63c091cd6aadªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§contextÚp```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we combine search results from many retrievers? 
This motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).

### Source document retention 

Many retrievers utilize some kind of index to make documents easily searchable.
The process of indexing can include a transformation step (e.g., vectorstores often use document splitting). 
Whatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.

![Retrieval with full docs](/img/retriever_full_docs.png)

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Document` objects given a search query, it is possible to combine multiple retrievers using ensembling.
This is particularly useful when you have multiple retrievers that are good at finding different types of relevant documents.
It is easy to create an [ensemble retriever](/docs/how_to/ensemble_retriever/) that combines multiple retrievers with linear weighted scores:

```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.

::: 

### Vector store 

[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. 
A vectorstore can be used as a retriever by calling the `as_retriever()` method.

```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble

- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)
- [How to: write a custom retriever class](/docs/how_to/custom_retriever)
- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)
- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)
- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)
- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)
- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)
- [How to: generate metadata filters](/docs/how_to/self_query)
- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)

![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small chunk size for indexing documents in a vectorstore. 
If you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. 

LangChain has two different retrievers that can be used to address this challenge. 
The [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. 
The [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q103®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:5c24b82a-a150-fd3b-0815-3cf7c8ddd20e­checkpoint_nsÙ-generate:5c24b82a-a150-fd3b-0815-3cf7c8ddd20e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@8788110ab1eaa8552701c9e408b9c4fb2b4468b4fa9f562833c2fc32e29cd29c¢tsËAÚó7Gª¨trace_idÙ$c687542e-d306-4455-94fa-63c091cd6aad­parent_run_idÙ$c30cd1de-7fde-48f5-8045-b14088e15970¦run_idÙ$c687542e-d306-4455-94fa-63c091cd6aadªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ`messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Which notebook illustrates using an ensemble retriever strategy? \nContext: ```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\nWhen ensembling, how do we combine search results from many retrievers? \nThis motivates the concept of re-ranking, which takes the output of multiple retrievers and combines them using a more sophisticated algorithm such as [Reciprocal Rank Fusion (RRF)](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf).\n\n### Source document retention \n\nMany retrievers utilize some kind of index to make documents easily searchable.\nThe process of indexing can include a transformation step (e.g., vectorstores often use document splitting). \nWhatever transformation is used, can be very useful to retain a link between the *transformed document* and the original, giving the retriever the ability to return the *original* document.\n\n![Retrieval with full docs](/img/retriever_full_docs.png)\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble \n\nBecause the retriever interface is so simple, returning a list of `Document` objects given a search query, it is possible to combine multiple retrievers using ensembling.\nThis is particularly useful when you have multiple retrievers that are good at finding different types of relevant documents.\nIt is easy to create an [ensemble retriever](/docs/how_to/ensemble_retriever/) that combines multiple retrievers with linear weighted scores:\n\n```python\n# Initialize the ensemble retriever\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]\n)\n```\n\n:::info[Further reading]\n\n* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.\n* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.\n* See the [Elasticsearch](/docs/integrations/retrievers/elasticsearch_retriever/) retriever integration.\n\n::: \n\n### Vector store \n\n[Vector stores](/docs/concepts/vectorstores/) are a powerful and efficient way to index and retrieve unstructured data. \nA vectorstore can be used as a retriever by calling the `as_retriever()` method.\n\n```python\nvectorstore = MyVectorStore()\nretriever = vectorstore.as_retriever()\n```\n\n## Advanced retrieval patterns\n\n### Ensemble\n\n- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)\n- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)\n- [How to: use contextual compression to compress the data retrieved](/docs/how_to/contextual_compression)\n- [How to: write a custom retriever class](/docs/how_to/custom_retriever)\n- [How to: add similarity scores to retriever results](/docs/how_to/add_scores_retriever)\n- [How to: combine the results from multiple retrievers](/docs/how_to/ensemble_retriever)\n- [How to: reorder retrieved results to mitigate the "lost in the middle" effect](/docs/how_to/long_context_reorder)\n- [How to: generate multiple embeddings per document](/docs/how_to/multi_vector)\n- [How to: retrieve the whole document for a chunk](/docs/how_to/parent_document_retriever)\n- [How to: generate metadata filters](/docs/how_to/self_query)\n- [How to: create a time-weighted retriever](/docs/how_to/time_weighted_vectorstore)\n\n![Retrieval with full docs](/img/retriever_full_docs.png)\n\nThis is particularly useful in AI applications, because it ensures no loss in document context for the model.\nFor example, you may use small chunk size for indexing documents in a vectorstore. \nIf you return *only* the chunks as the retrieval result, then the model will have lost the original document context for the chunks. \n\nLangChain has two different retrievers that can be used to address this challenge. \nThe [Multi-Vector](/docs/how_to/multi_vector/) retriever allows the user to use any document transformation (e.g., use an LLM to write a summary of the document) for indexing while retaining linkage to the source document. \nThe [ParentDocument](/docs/how_to/parent_document_retriever/) retriever links document chunks from a text-splitter transformation for indexing while retaining linkage to the source document. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@881325e79d80730fe5377be59dec0a9ffd29cc347b425d6f88a2c88b0ee32bf3¢tsËAÚó7²á	¨focus_msÍ	P§payload‚¤role©assistant§contentÚ\The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers.ªfocus_kind¬exec_latency¨query_id¤Q103‰¢idÙ@b94db4da04923ac31299755e95abac00c7a951ba6da0f2301b9acd524a0441c3¢tsËAÚó7²í¨trace_idÙ$c30cd1de-7fde-48f5-8045-b14088e15970­parent_run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6ee¦run_idÙ$c30cd1de-7fde-48f5-8045-b14088e15970ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ\The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers.¨query_id¤Q103ªfocus_kind¶chain_execution_result‰¢idÙ@aecc3257289710a21e303f5800b4bfe7de32af745d14bd959f46c8378972ef45¢tsËAÚó7²ò¨trace_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6ee­parent_run_idÀ¦run_idÙ$c67a9884-15a7-4b12-9014-1f1ca615e6eeªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ@Which notebook illustrates using an ensemble retriever strategy?§context•‚´page_content_summaryÙË```python
# Initialize the ensemble retriever
ensemble_retriever = EnsembleRetriever(
    retrievers=[bm25_retriever, vector_store_retriever], weights=[0.5, 0.5]
)
```

When ensembling, how do we comb...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË```python
vectorstore = MyVectorStore()
retriever = vectorstore.as_retriever()
```

## Advanced retrieval patterns

### Ensemble 

Because the retriever interface is so simple, returning a list of `Do...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË:::info[Further reading]

* See the [BM25](/docs/integrations/retrievers/bm25/) retriever integration.
* See the [TF-IDF](/docs/integrations/retrievers/tf_idf/) retriever integration.
* See the [Elast...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx‚´page_content_summaryÙË- [How to: use a vector store to retrieve data](/docs/how_to/vectorstore_retriever)
- [How to: generate multiple queries to retrieve data for](/docs/how_to/MultiQueryRetriever)
- [How to: use contextu...¨metadata¦sourceÙB/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/index.mdx‚´page_content_summaryÙË![Retrieval with full docs](/img/retriever_full_docs.png)

This is particularly useful in AI applications, because it ensures no loss in document context for the model.
For example, you may use small ...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/retrievers.mdx¦answerÚ\The notebook that illustrates using an ensemble retriever strategy is the one that includes the initialization of the `EnsembleRetriever` with multiple retrievers, such as `bm25_retriever` and `vector_store_retriever`. This is demonstrated in the provided code snippet where the ensemble retriever is created with equal weights for both retrievers.¨query_id¤Q103ªfocus_kind¶chain_execution_result‹¢idÙ@88a7536ce3c2d19c6b39293b8f927b82706cf5044861696dc03cc9da0a2860ba¢tsËAÚó7²÷,¨trace_id¤Q104­parent_run_idÀ¦run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).¨query_id¤Q104§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q104ªfocus_kind¯chain_execution‹¢idÙ@1c5f2fac2d93d4855a98ecda33ca08c54ed2b8e8375975d9cec21fa280c20b6e¢tsËAÚó7²ÿ‹¨trace_id¤Q104­parent_run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203¦run_idÙ$cc4ef4dc-58b1-42a6-87a2-98eb02066987ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context¦answer ¨query_id¤Q104¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q104®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:40fcbc3b-025e-c5d8-3c1c-cc64398052d5ªfocus_kind¯chain_execution‰¢idÙ@327e4027b7e4cc25859ad8a3138068afbc795fe41ee863c5f81f25afbd225e8f¢tsËAÚó7Ã¡Ï¨trace_idÙ$cc4ef4dc-58b1-42a6-87a2-98eb02066987­parent_run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203¦run_idÙ$cc4ef4dc-58b1-42a6-87a2-98eb02066987ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¨query_id¤Q104ªfocus_kind¶chain_execution_result‹¢idÙ@31a5799dc2f8acd42eb7f6da353d2aec6a3f17de9cc4b5477e529a61ec9701b7¢tsËAÚó7Ãª¨¨trace_id¤Q104­parent_run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203¦run_idÙ$c752a3b6-7742-43c1-b043-c402ae79b827ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answer ¨query_id¤Q104¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q104®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:226317be-d52c-437b-5912-45502e716d6eªfocus_kind¯chain_execution‹¢idÙ@28cfd7a787c59db64581445419311f77ef63cd9015626ab5c3a92fd26173647a¢tsËAÚó7Ã±2¨trace_id¤Q104­parent_run_idÙ$c752a3b6-7742-43c1-b043-c402ae79b827¦run_idÙ$e3814ed8-947f-4a92-bdf6-2a188bf1d876ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§contextÚ¾Other benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is happening at every step.
With LCEL, **all** steps are automatically logged to [LangSmith](https://docs.smith.langchain.com/) for maximum observability and debuggability.
- **Standard API**: Because all chains are built using the Runnable interface, they can be used in the same way as any other Runnable.
- [**Deployable with LangServe**](/docs/concepts/architecture#langserve): Chains built with LCEL can be deployed using for production use.

## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.

This means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

We often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::note
* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.
* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.
* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.
:::

## Benefits of LCEL

LangChain optimizes the run-time execution of chains built with LCEL in a number of ways:

- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(time elapsed until the first chunk of output from a [chat model](/docs/concepts/chat_models) or [llm](/docs/concepts/text_llms) comes out).

## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

While we have seen users run chains with hundreds of steps in production, we generally recommend using LCEL for simpler orchestration tasks. When the application requires complex state management, branching, cycles or multiple agents, we recommend that users take advantage of [LangGraph](/docs/concepts/architecture#langgraph).

In LangGraph, users define graphs that specify the application's flow. This allows users to keep using LCEL within individual nodes when LCEL is needed, while making it easy to define complex orchestration logic that is more readable and maintainable.

Here are some guidelines:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q104®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:226317be-d52c-437b-5912-45502e716d6e­checkpoint_nsÙ-generate:226317be-d52c-437b-5912-45502e716d6e¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@8ae0efc07293d1849a221e0540fa8f60f740639ace1cf3c3d5b5d498fd2fb934¢tsËAÚó7Ãº¨trace_idÙ$e3814ed8-947f-4a92-bdf6-2a188bf1d876­parent_run_idÙ$c752a3b6-7742-43c1-b043-c402ae79b827¦run_idÙ$e3814ed8-947f-4a92-bdf6-2a188bf1d876ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Give two benefits of the LangChain Expression Language (LCEL). \nContext: Other benefits include:\n\n- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)\nAs your chains get more and more complex, it becomes increasingly important to understand what exactly is happening at every step.\nWith LCEL, **all** steps are automatically logged to [LangSmith](https://docs.smith.langchain.com/) for maximum observability and debuggability.\n- **Standard API**: Because all chains are built using the Runnable interface, they can be used in the same way as any other Runnable.\n- [**Deployable with LangServe**](/docs/concepts/architecture#langserve): Chains built with LCEL can be deployed using for production use.\n\n## Should I use LCEL?\n\nLCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.\n\n# LangChain Expression Language (LCEL)\n\n:::info Prerequisites\n* [Runnable Interface](/docs/concepts/runnables)\n:::\n\nThe **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https://en.wikipedia.org/wiki/Declarative_programming) approach to building new [Runnables](/docs/concepts/runnables) from existing Runnables.\n\nThis means that you describe what *should* happen, rather than *how* it should happen, allowing LangChain to optimize the run-time execution of the chains.\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\nWe often refer to a `Runnable` created using LCEL as a "chain". It\'s important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).\n\n:::note\n* The [LCEL cheatsheet](/docs/how_to/lcel_cheatsheet/) shows common patterns that involve the Runnable interface and LCEL expressions.\n* Please see the following list of [how-to guides](/docs/how_to/#langchain-expression-language-lcel) that cover common tasks with LCEL.\n* A list of built-in `Runnables` can be found in the [LangChain Core API Reference](https://python.langchain.com/api_reference/core/runnables.html). Many of these Runnables are useful when composing custom "chains" in LangChain using LCEL.\n:::\n\n## Benefits of LCEL\n\nLangChain optimizes the run-time execution of chains built with LCEL in a number of ways:\n\n- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(time elapsed until the first chunk of output from a [chat model](/docs/concepts/chat_models) or [llm](/docs/concepts/text_llms) comes out).\n\n## Should I use LCEL?\n\nLCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.\n\nWhile we have seen users run chains with hundreds of steps in production, we generally recommend using LCEL for simpler orchestration tasks. When the application requires complex state management, branching, cycles or multiple agents, we recommend that users take advantage of [LangGraph](/docs/concepts/architecture#langgraph).\n\nIn LangGraph, users define graphs that specify the application\'s flow. This allows users to keep using LCEL within individual nodes when LCEL is needed, while making it easy to define complex orchestration logic that is more readable and maintainable.\n\nHere are some guidelines: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@13e5645473f0435e23743c038e5820ea4688915deaab818b8c161ecc5f6e7291¢tsËAÚó8ró¨focus_msÍJ§payload‚¤role©assistant§contentÚ{Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL enables the creation of chains using a declarative approach, optimizing run-time execution.ªfocus_kind¬exec_latency¨query_id¤Q104‰¢idÙ@08622291e3e9ebf6d1f8a4799a6f43f15eec7039348db6ac2ad877e6f24a6a51¢tsËAÚó8ˆ
¨trace_idÙ$c752a3b6-7742-43c1-b043-c402ae79b827­parent_run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203¦run_idÙ$c752a3b6-7742-43c1-b043-c402ae79b827ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ{Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL enables the creation of chains using a declarative approach, optimizing run-time execution.¨query_id¤Q104ªfocus_kind¶chain_execution_result‰¢idÙ@2c6c89ee5f2c2d835df1ca18cdad5503aca1d4592af35f8e0148e02a35e57481¢tsËAÚó8¸¨trace_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203­parent_run_idÀ¦run_idÙ$65a7a716-6ddc-440f-b1f3-0ab9b28c3203ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ>Give two benefits of the LangChain Expression Language (LCEL).§context•‚´page_content_summaryÙËOther benefits include:

- [**Seamless LangSmith tracing**](https://docs.smith.langchain.com)
As your chains get more and more complex, it becomes increasingly important to understand what exactly is ...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË# LangChain Expression Language (LCEL)

:::info Prerequisites
* [Runnable Interface](/docs/concepts/runnables)
:::

The **L**ang**C**hain **E**xpression **L**anguage (LCEL) takes a [declarative](https...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙËWe often refer to a `Runnable` created using LCEL as a "chain". It's important to remember that a "chain" is `Runnable` and it implements the full [Runnable Interface](/docs/concepts/runnables).

:::n...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË- **Simplify streaming**: LCEL chains can be streamed, allowing for incremental output as the chain is executed. LangChain can optimize the streaming of the output to minimize the time-to-first-token(...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx‚´page_content_summaryÙË## Should I use LCEL?

LCEL is an [orchestration solution](https://en.wikipedia.org/wiki/Orchestration_(computing)) -- it allows LangChain to handle run-time execution of chains in an optimized way.

...¨metadata¦sourceÙC/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/lcel.mdx¦answerÚ{Two benefits of the LangChain Expression Language (LCEL) are its ability to simplify streaming, allowing for incremental output during execution, and its seamless integration with LangSmith for automatic logging of all steps, enhancing observability and debuggability. Additionally, LCEL enables the creation of chains using a declarative approach, optimizing run-time execution.¨query_id¤Q104ªfocus_kind¶chain_execution_result‹¢idÙ@c8848369d4f0bab61393446d4c329599661f0d3999e6424b41e92f223b85ee9b¢tsËAÚó8›•¨trace_id¤Q105­parent_run_idÀ¦run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?¨query_id¤Q105§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q105ªfocus_kind¯chain_execution‹¢idÙ@1fe7bfad41fe20dacd38035b808b406e58394de6b63595f5ca0fa53249299b4d¢tsËAÚó8µ¨trace_id¤Q105­parent_run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6¦run_idÙ$aa2c8787-db71-44aa-a6fe-5e07bb021ec6ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context¦answer ¨query_id¤Q105¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q105®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:837daded-a3d7-d3df-54bf-3a4685305872ªfocus_kind¯chain_execution‰¢idÙ@bd6e5067ce739ecb0be867232fed447902a1e8a9b12ba7d43fe41d9f9712a49e¢tsËAÚó8-¡<¨trace_idÙ$aa2c8787-db71-44aa-a6fe-5e07bb021ec6­parent_run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6¦run_idÙ$aa2c8787-db71-44aa-a6fe-5e07bb021ec6ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¨query_id¤Q105ªfocus_kind¶chain_execution_result‹¢idÙ@4fea3fcbfea3b5ffc7a08c34192dad55e3b835b45cc98314c9c2fb5c0942a004¢tsËAÚó8-«±¨trace_id¤Q105­parent_run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6¦run_idÙ$52bb45e8-dfec-42ff-87ab-237accdf0780ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answer ¨query_id¤Q105¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q105®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:00bb69e9-8eab-173e-2536-0d8b5c1592cbªfocus_kind¯chain_execution‹¢idÙ@fd67fbe3e36022e0db8c85cc0a0262b87d318c8be8b00f42cf161035ca77fb47¢tsËAÚó8-²_¨trace_id¤Q105­parent_run_idÙ$52bb45e8-dfec-42ff-87ab-237accdf0780¦run_idÙ$45f5117c-3f1a-45c2-a947-19794ea51b66ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§contextÚ©1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.
2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.

3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.

| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                                                                                                                                          |
| `rate_limiter` | An optional [BaseRateLimiter](https://python.langchain.com/api_reference/core/rate_limiters/langchain_core.rate_limiters.BaseRateLimiter.html#langchain_core.rate_limiters.BaseRateLimiter) to space out requests to avoid exceeding rate limits.  See [rate-limiting](#rate-limiting) below for more details. |

If the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).

The size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.

## Advanced topics
 
### Rate-limiting

Many chat model providers impose a limit on the number of requests that can be made in a given time period.

If you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.

# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.

Modern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.

The newest generation of chat models offer additional capabilities:¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q105®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:00bb69e9-8eab-173e-2536-0d8b5c1592cb­checkpoint_nsÙ-generate:00bb69e9-8eab-173e-2536-0d8b5c1592cb¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@6c08bdc9a145bb05c16069c1f182123c1d9dacc8f774c2e21dd9a55c15c41c8d¢tsËAÚó8-»D¨trace_idÙ$45f5117c-3f1a-45c2-a947-19794ea51b66­parent_run_idÙ$52bb45e8-dfec-42ff-87ab-237accdf0780¦run_idÙ$45f5117c-3f1a-45c2-a947-19794ea51b66ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚlmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What is the main purpose of the `rate_limiter` argument on ChatModels? \nContext: 1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at which requests are made to the model provider. Spacing out the requests to a given model is a particularly useful strategy when benchmarking models to evaluate their performance. Please see the [how to handle rate limits](/docs/how_to/chat_model_rate_limiting/) for more information on how to use this feature.\n2. Try to recover from rate limit errors: If you receive a rate limit error, you can wait a certain amount of time before retrying the request. The amount of time to wait can be increased with each subsequent rate limit error. Chat models have a `max_retries` parameter that can be used to control the number of retries. See the [standard parameters](#standard-parameters) section for more information.\n\n3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited.\n\n| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model\'s provider and is necessary for directing your requests.                                                                                                                                                          |\n| `rate_limiter` | An optional [BaseRateLimiter](https://python.langchain.com/api_reference/core/rate_limiters/langchain_core.rate_limiters.BaseRateLimiter.html#langchain_core.rate_limiters.BaseRateLimiter) to space out requests to avoid exceeding rate limits.  See [rate-limiting](#rate-limiting) below for more details. |\n\nIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the context window determines how much information the model can "remember" throughout a conversation. Developers often need to manage the input within the context window to maintain a coherent dialogue without exceeding the limit. For more details on handling memory in conversations, refer to the [memory](https://langchain-ai.github.io/langgraph/concepts/memory/).\n\nThe size of the input is measured in [tokens](/docs/concepts/tokens) which are the unit of processing that the model uses.\n\n## Advanced topics\n \n### Rate-limiting\n\nMany chat model providers impose a limit on the number of requests that can be made in a given time period.\n\nIf you hit a rate limit, you will typically receive a rate limit error response from the provider, and will need to wait before making more requests.\n\n# Chat models\n\n## Overview\n\nLarge Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, question answering, and more, without needing task-specific fine tuning for every scenario.\n\nModern LLMs are typically accessed through a chat model interface that takes a list of [messages](/docs/concepts/messages) as input and returns a [message](/docs/concepts/messages) as output.\n\nThe newest generation of chat models offer additional capabilities: \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@434c1247bc1453edb019fb3bd0134778e5262d7d0df8fa97f9b9dd5b881061ef¢tsËAÚó8¥iˆ¨focus_msÍM§payload‚¤role©assistant§contentÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.ªfocus_kind¬exec_latency¨query_id¤Q105‰¢idÙ@1823e5f431a218cce7680a0d2414cb216893bfca123bfa63ac9e56062dc1f22c¢tsËAÚó8¥š¨trace_idÙ$52bb45e8-dfec-42ff-87ab-237accdf0780­parent_run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6¦run_idÙ$52bb45e8-dfec-42ff-87ab-237accdf0780ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.¨query_id¤Q105ªfocus_kind¶chain_execution_result‰¢idÙ@6f3c080ca962567189eff8717350d9a6f0923245ebc2e514339742fd2cc4ed46¢tsËAÚó8¥§ç¨trace_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6­parent_run_idÀ¦run_idÙ$43979bd1-eb08-4693-8afe-a6f75d1c02e6ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙFWhat is the main purpose of the `rate_limiter` argument on ChatModels?§context•‚´page_content_summaryÙË1. Try to avoid hitting rate limits by spacing out requests: Chat models accept a `rate_limiter` parameter that can be provided during initialization. This parameter is used to control the rate at whi...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙ‘3. Fallback to another chat model: If you hit a rate limit with one chat model, you can switch to another chat model that is not rate-limited....¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË| `base_url`     | The URL of the API endpoint where requests are sent. This is typically provided by the model's provider and is necessary for directing your requests.                                ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙËIf the input exceeds the context window, the model may not be able to process the entire input and could raise an error. In conversational applications, this is especially important because the contex...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx‚´page_content_summaryÙË# Chat models

## Overview

Large Language Models (LLMs) are advanced machine learning models that excel in a wide range of language-related tasks such as text generation, translation, summarization, ...¨metadata¦sourceÙJ/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/chat_models.mdx¦answerÚlThe main purpose of the `rate_limiter` argument on ChatModels is to control the rate at which requests are made to avoid exceeding rate limits imposed by the model provider. By spacing out requests, it helps prevent hitting these limits, which is particularly useful during benchmarking. This feature allows for more efficient and effective use of the chat models.¨query_id¤Q105ªfocus_kind¶chain_execution_result‹¢idÙ@df91880df2b21fea67f1cd074de2c9e76d4a9025d19cff1df7fb34f827529b6c¢tsËAÚó8¥®Å¨trace_id¤Q106­parent_run_idÀ¦run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?¨query_id¤Q106§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q106ªfocus_kind¯chain_execution‹¢idÙ@235d1968c624b93ced7bbffc12fc02b5dc08e3d3d778c2af9753312782955cd5¢tsËAÚó8¥¶¨trace_id¤Q106­parent_run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2¦run_idÙ$ea9b6960-cafa-476c-a859-f9dae2042fc4ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context¦answer ¨query_id¤Q106¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q106®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:a065186b-aac5-3a7b-ac18-06cd97226a62ªfocus_kind¯chain_execution‰¢idÙ@aa707c5e90986abebdbaa7625a02fbc28562379c2cb09a095803cbf3b261f1ab¢tsËAÚó8¿~å¨trace_idÙ$ea9b6960-cafa-476c-a859-f9dae2042fc4­parent_run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2¦run_idÙ$ea9b6960-cafa-476c-a859-f9dae2042fc4ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¨query_id¤Q106ªfocus_kind¶chain_execution_result‹¢idÙ@ffe7723a3a08e58e7d218e138d1448ffd2ec79b69256e61590ccbe22f7320aea¢tsËAÚó8¿ˆà¨trace_id¤Q106­parent_run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2¦run_idÙ$374f8b1d-39d8-44e7-96f3-3a27950545d5ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¦answer ¨query_id¤Q106¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q106®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3ad914b4-61b7-f280-6a0b-e2533433bcedªfocus_kind¯chain_execution‹¢idÙ@903e67e073dcf6cfaab54bd50a74ea8c46d59bfcf531f1d5836cb1e4f3abba56¢tsËAÚó8¿ó¨trace_id¤Q106­parent_run_idÙ$374f8b1d-39d8-44e7-96f3-3a27950545d5¦run_idÙ$1479f448-8115-4972-8933-d61c6e997a9dªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ<How many tokens is 100 English words approximately equal to?§contextÚš## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and how they correspond to text.

According to the OpenAI post, the approximate token counts for English text are as follows:

* 1 token ~= 4 chars in English
* 1 token ~= Â¾ words
* 100 tokens ~= 75 words

# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use to break down input and generate output. In this section, we'll discuss what tokens are and how they are used by language models.

## What is a token?

A **token** is the basic unit that a language model reads, processes, and generates. These units can vary based on how the model provider defines them, but in general, they could represent:

* A whole word (e.g., "apple"),
* A part of a word (e.g., "app"),
* Or other linguistic components such as punctuation or spaces.

The way the model tokenizes the input depends on its **tokenizer algorithm**, which converts the input into tokens. Similarly, the modelâ€™s output comes as a stream of tokens, which is then decoded back into human-readable text.

## How tokens work in language models

Please see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters makes models both more efficient and better at understanding context and grammar. Tokens represent meaningful units, like whole words or parts of words, allowing models to capture language structure more effectively than by processing raw characters. Token-level processing also reduces the number of units the model has to handle, leading to faster computation.

In contrast, character-level processing would require handling a much larger sequence of input, making it harder for the model to learn relationships and context. Tokens enable models to focus on linguistic meaning, making them more accurate and efficient in generating responses.

## How tokens correspond to text

## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, language models focus on **tokens**, which represent meaningful linguistic units. Here's how the process works:

1. **Input Tokenization**: When you provide a model with a prompt (e.g., "LangChain is cool!"), the tokenizer algorithm splits the text into tokens. For example, the sentence could be tokenized into parts like `["Lang", "Chain", " is", " cool", "!"]`. Note that token boundaries donâ€™t always align with word boundaries.
    ![](/img/tokenization.png)

2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, capturing context and meaning from the input.
3. **Output Generation**: The model generates new tokens one by one. These output tokens are then decoded back into human-readable text.

Using tokens instead of raw characters allows the model to focus on linguistically meaningful units, which helps it capture grammar, structure, and context more effectively.

## Tokens donâ€™t have to be text

Although tokens are most commonly used to represent text, they donâ€™t have to be limited to textual data. Tokens can also serve as abstract representations of **multi-modal data**, such as:

- **Images**,
- **Audio**,
- **Video**,
- And other types of data.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q106®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:3ad914b4-61b7-f280-6a0b-e2533433bced­checkpoint_nsÙ-generate:3ad914b4-61b7-f280-6a0b-e2533433bced¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@9d7ec3cda11cac140f0e55313c9495926e30bc0ae1510b33bfca6eaba2c3940d¢tsËAÚó8¿—6¨trace_idÙ$1479f448-8115-4972-8933-d61c6e997a9d­parent_run_idÙ$374f8b1d-39d8-44e7-96f3-3a27950545d5¦run_idÙ$1479f448-8115-4972-8933-d61c6e997a9dªevent_type¬chain_output¬event_source¥chain§payload§outputsÚomessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: How many tokens is 100 English words approximately equal to? \nContext: ## How tokens correspond to text\n\nPlease see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and how they correspond to text.\n\nAccording to the OpenAI post, the approximate token counts for English text are as follows:\n\n* 1 token ~= 4 chars in English\n* 1 token ~= Â¾ words\n* 100 tokens ~= 75 words\n\n# Tokens\n\nModern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use to break down input and generate output. In this section, we\'ll discuss what tokens are and how they are used by language models.\n\n## What is a token?\n\nA **token** is the basic unit that a language model reads, processes, and generates. These units can vary based on how the model provider defines them, but in general, they could represent:\n\n* A whole word (e.g., "apple"),\n* A part of a word (e.g., "app"),\n* Or other linguistic components such as punctuation or spaces.\n\nThe way the model tokenizes the input depends on its **tokenizer algorithm**, which converts the input into tokens. Similarly, the modelâ€™s output comes as a stream of tokens, which is then decoded back into human-readable text.\n\n## How tokens work in language models\n\nPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.\n\n## Why not use characters?\n\nUsing tokens instead of individual characters makes models both more efficient and better at understanding context and grammar. Tokens represent meaningful units, like whole words or parts of words, allowing models to capture language structure more effectively than by processing raw characters. Token-level processing also reduces the number of units the model has to handle, leading to faster computation.\n\nIn contrast, character-level processing would require handling a much larger sequence of input, making it harder for the model to learn relationships and context. Tokens enable models to focus on linguistic meaning, making them more accurate and efficient in generating responses.\n\n## How tokens correspond to text\n\n## How tokens work in language models\n\nThe reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, language models focus on **tokens**, which represent meaningful linguistic units. Here\'s how the process works:\n\n1. **Input Tokenization**: When you provide a model with a prompt (e.g., "LangChain is cool!"), the tokenizer algorithm splits the text into tokens. For example, the sentence could be tokenized into parts like `["Lang", "Chain", " is", " cool", "!"]`. Note that token boundaries donâ€™t always align with word boundaries.\n    ![](/img/tokenization.png)\n\n2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, capturing context and meaning from the input.\n3. **Output Generation**: The model generates new tokens one by one. These output tokens are then decoded back into human-readable text.\n\nUsing tokens instead of raw characters allows the model to focus on linguistically meaningful units, which helps it capture grammar, structure, and context more effectively.\n\n## Tokens donâ€™t have to be text\n\nAlthough tokens are most commonly used to represent text, they donâ€™t have to be limited to textual data. Tokens can also serve as abstract representations of **multi-modal data**, such as:\n\n- **Images**,\n- **Audio**,\n- **Video**,\n- And other types of data. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@019cf9cadf1e49cc04160249639d02439b157e4f474d556708fa21f1ee497aed¢tsËAÚó9é§¨focus_msÍ:§payload‚¤role©assistant§contentÙÊApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would convert to around 133 tokens.ªfocus_kind¬exec_latency¨query_id¤Q106‰¢idÙ@9e80a345beb77fef58c8e845b29caf7d3ee782a10f7fe9cf56315be013caca44¢tsËAÚó9 ¨trace_idÙ$374f8b1d-39d8-44e7-96f3-3a27950545d5­parent_run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2¦run_idÙ$374f8b1d-39d8-44e7-96f3-3a27950545d5ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙÊApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would convert to around 133 tokens.¨query_id¤Q106ªfocus_kind¶chain_execution_result‰¢idÙ@12f17254fa86b77e327b685f5ed881c9930b637a7c3f6af437a8cd5aecaca542¢tsËAÚó9š¨trace_idÙ$434fa35a-8528-4103-9671-f67d31471fd2­parent_run_idÀ¦run_idÙ$434fa35a-8528-4103-9671-f67d31471fd2ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ<How many tokens is 100 English words approximately equal to?§context•‚´page_content_summaryÙË## How tokens correspond to text

Please see this post from [OpenAI](https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them) for more details on how tokens are counted and h...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË# Tokens

Modern large language models (LLMs) are typically based on a transformer architecture that processes a sequence of units known as tokens. Tokens are the fundamental elements that models use ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙËPlease see the [multimodality](/docs/concepts/multimodality) section for more information on multi-modal inputs and outputs.

## Why not use characters?

Using tokens instead of individual characters ...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË## How tokens work in language models

The reason language models use tokens is tied to how they understand and predict language. Rather than processing characters or entire sentences directly, langua...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx‚´page_content_summaryÙË2. **Processing**: The transformer architecture behind these models processes tokens sequentially to predict the next token in a sentence. It does this by analyzing the relationships between tokens, c...¨metadata¦sourceÙE/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tokens.mdx¦answerÙÊApproximately, 100 English words are equal to about 133 tokens. This is based on the approximation that 1 token is roughly equal to Â¾ of a word. Therefore, 100 words would convert to around 133 tokens.¨query_id¤Q106ªfocus_kind¶chain_execution_result‹¢idÙ@cff89d1e65e00ee561d41e83644e12a75a44ad21ac5d1031edf94594f8105432¢tsËAÚó9 ¨trace_id¤Q107­parent_run_idÀ¦run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.¨query_id¤Q107§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q107ªfocus_kind¯chain_execution‹¢idÙ@98d106e6affe7d9243122577929f95eb945655a01b337f563d10e9959bc59fd8¢tsËAÚó9?¨trace_id¤Q107­parent_run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495d¦run_idÙ$22492580-71e0-4542-803b-32ed2b5df437ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context¦answer ¨query_id¤Q107¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q107®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:abff7f9b-bef2-a488-fc92-4a6d37f0695cªfocus_kind¯chain_execution‰¢idÙ@1cc19e2c861eda23c7c623f7c10eee8f3dbf941755b28bd4c7625a6a1494406f¢tsËAÚó9 @¨trace_idÙ$22492580-71e0-4542-803b-32ed2b5df437­parent_run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495d¦run_idÙ$22492580-71e0-4542-803b-32ed2b5df437ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¨query_id¤Q107ªfocus_kind¶chain_execution_result‹¢idÙ@d1cf192cd94361a29dcff47befa21653b888fb4e698af9f06601a6b65227d741¢tsËAÚó9­—¨trace_id¤Q107­parent_run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495d¦run_idÙ$eaeaebfb-647e-4fd9-9a4c-0a2ea2a3388cªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answer ¨query_id¤Q107¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q107®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:51d77b6c-6a0d-b809-3573-72045b2a2eb3ªfocus_kind¯chain_execution‹¢idÙ@43a2a5b424018792a797768cc883cab9ebfc9e4a6af93de9be18d0443577d496¢tsËAÚó9µé¨trace_id¤Q107­parent_run_idÙ$eaeaebfb-647e-4fd9-9a4c-0a2ea2a3388c¦run_idÙ$bacf3234-0eaa-4332-8e90-24192f185f97ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§contextÚ'When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the hood, it'll have `invoke` (or `ainvoke`) use the `stream` (or `astream`) method to generate its output. The result of the invocation will be the same as far as the code that was using `invoke` is concerned; however, while the chat model is being streamed, LangChain will take care of invoking `on_llm_new_token` events in LangChain's [callback system](/docs/concepts/callbacks). These callback events
allow LangGraph `stream`/`astream` and `astream_events` to surface the chat model's output in real-time.

Example:

```python
def node(state):
    ...
    # The code below uses the invoke method, but LangChain will 
    # automatically switch to streaming mode
    # when it detects that the overall 
    # application is being streamed.
    ai_message = model.invoke(state["messages"])
    ...

## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations (e.g., making API calls, reading files) will have an asynchronous counterpart.

In LangChain, async implementations are located in the same classes as their synchronous counterparts, with the asynchronous methods having an "a" prefix. For example, the synchronous `invoke` method has an asynchronous counterpart called `ainvoke`.

Many components of LangChain implement the [Runnable Interface](/docs/concepts/runnables), which includes support for asynchronous execution. This means that you can run Runnables asynchronously using the `await` keyword in Python.

```python
await some_runnable.ainvoke(some_input)
```

```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement the [Runnable Interface](/docs/concepts/runnables) usually still follow the same rule and include the asynchronous version of method in the same class with an "a" prefix.

For example,

```python
await some_vectorstore.aadd_documents(documents)
```

Runnables created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel) can also be run asynchronously as they implement
the full [Runnable Interface](/docs/concepts/runnables).

For more information, please review the [API reference](https://python.langchain.com/api_reference/) for the specific component you are using.

## Delegation to sync methods

The result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```python
result = llm_with_tools.invoke("What is 2 multiplied by 3?")
```

As before, the output `result` will be an `AIMessage`. 
But, if the tool was called, `result` will have a `tool_calls` attribute.
This attribute includes everything needed to execute the tool, including the tool name and input arguments:

```
result.tool_calls
{'name': 'multiply', 'args': {'a': 2, 'b': 3}, 'id': 'xxx', 'type': 'tool_call'}
```

For more details on usage, see our [how-to guides](/docs/how_to/#tools)!

## Tool execution

[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.

## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitly calling the streaming methods. This is particularly useful when you use the non-streaming `invoke` method but still want to stream the entire application, including intermediate results from the chat model.

### How It Works

When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q107®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:51d77b6c-6a0d-b809-3573-72045b2a2eb3­checkpoint_nsÙ-generate:51d77b6c-6a0d-b809-3573-72045b2a2eb3¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@5ab1d2fb98c80d93be0646ca1e968ef328edee809b0a7368d7635a0c4ae84622¢tsËAÚó9ÀD¨trace_idÙ$bacf3234-0eaa-4332-8e90-24192f185f97­parent_run_idÙ$eaeaebfb-647e-4fd9-9a4c-0a2ea2a3388c¦run_idÙ$bacf3234-0eaa-4332-8e90-24192f185f97ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ!messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Explain the difference between `invoke` and `ainvoke`. \nContext: When you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. \n\nUnder the hood, it\'ll have `invoke` (or `ainvoke`) use the `stream` (or `astream`) method to generate its output. The result of the invocation will be the same as far as the code that was using `invoke` is concerned; however, while the chat model is being streamed, LangChain will take care of invoking `on_llm_new_token` events in LangChain\'s [callback system](/docs/concepts/callbacks). These callback events\nallow LangGraph `stream`/`astream` and `astream_events` to surface the chat model\'s output in real-time.\n\nExample:\n\n```python\ndef node(state):\n    ...\n    # The code below uses the invoke method, but LangChain will \n    # automatically switch to streaming mode\n    # when it detects that the overall \n    # application is being streamed.\n    ai_message = model.invoke(state["messages"])\n    ...\n\n## Langchain asynchronous APIs\n\nMany LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.\n\nTypically, any method that may perform I/O operations (e.g., making API calls, reading files) will have an asynchronous counterpart.\n\nIn LangChain, async implementations are located in the same classes as their synchronous counterparts, with the asynchronous methods having an "a" prefix. For example, the synchronous `invoke` method has an asynchronous counterpart called `ainvoke`.\n\nMany components of LangChain implement the [Runnable Interface](/docs/concepts/runnables), which includes support for asynchronous execution. This means that you can run Runnables asynchronously using the `await` keyword in Python.\n\n```python\nawait some_runnable.ainvoke(some_input)\n```\n\n```python\nawait some_runnable.ainvoke(some_input)\n```\n\nOther components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement the [Runnable Interface](/docs/concepts/runnables) usually still follow the same rule and include the asynchronous version of method in the same class with an "a" prefix.\n\nFor example,\n\n```python\nawait some_vectorstore.aadd_documents(documents)\n```\n\nRunnables created using the [LangChain Expression Language (LCEL)](/docs/concepts/lcel) can also be run asynchronously as they implement\nthe full [Runnable Interface](/docs/concepts/runnables).\n\nFor more information, please review the [API reference](https://python.langchain.com/api_reference/) for the specific component you are using.\n\n## Delegation to sync methods\n\nThe result would be an `AIMessage` containing the model\'s response in natural language (e.g., "Hello!").\nHowever, if we pass an input *relevant to the tool*, the model should choose to call it:\n\n```python\nresult = llm_with_tools.invoke("What is 2 multiplied by 3?")\n```\n\nAs before, the output `result` will be an `AIMessage`. \nBut, if the tool was called, `result` will have a `tool_calls` attribute.\nThis attribute includes everything needed to execute the tool, including the tool name and input arguments:\n\n```\nresult.tool_calls\n{\'name\': \'multiply\', \'args\': {\'a\': 2, \'b\': 3}, \'id\': \'xxx\', \'type\': \'tool_call\'}\n```\n\nFor more details on usage, see our [how-to guides](/docs/how_to/#tools)!\n\n## Tool execution\n\n[Tools](/docs/concepts/tools/) implement the [Runnable](/docs/concepts/runnables/) interface, which means that they can be invoked (e.g., `tool.invoke(args)`) directly.\n\n## "Auto-Streaming" Chat Models\n\nLangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitly calling the streaming methods. This is particularly useful when you use the non-streaming `invoke` method but still want to stream the entire application, including intermediate results from the chat model.\n\n### How It Works\n\nWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@8a4a4786aa87f0a0452be4544c077d4fbc46042bb3fd0ad3ae2e197aa8fdd09c¢tsËAÚó9}­m¨focus_msÍg§payload‚¤role©assistant§contentÚ{The `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, use `invoke` for synchronous calls and `ainvoke` for asynchronous calls.ªfocus_kind¬exec_latency¨query_id¤Q107‰¢idÙ@77399010af53072e61abbfa4ac8940b88cb6478048013084dbdbc13a91bad698¢tsËAÚó9}¿¾¨trace_idÙ$eaeaebfb-647e-4fd9-9a4c-0a2ea2a3388c­parent_run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495d¦run_idÙ$eaeaebfb-647e-4fd9-9a4c-0a2ea2a3388cªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚ{The `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, use `invoke` for synchronous calls and `ainvoke` for asynchronous calls.¨query_id¤Q107ªfocus_kind¶chain_execution_result‰¢idÙ@f660593d757fba3a9e241347e956f39d7eda1dbdc207c6aa0ddae0717c71d8a2¢tsËAÚó9}É—¨trace_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495d­parent_run_idÀ¦run_idÙ$a85c0a08-7d95-45bd-8b10-e6ce5688495dªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ6Explain the difference between `invoke` and `ainvoke`.§context•‚´page_content_summaryÙËWhen you call the `invoke` (or `ainvoke`) method on a chat model, LangChain will automatically switch to streaming mode if it detects that you are trying to stream the overall application. 

Under the...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx‚´page_content_summaryÙË## Langchain asynchronous APIs

Many LangChain APIs are designed to be asynchronous, allowing you to build efficient and responsive applications.

Typically, any method that may perform I/O operations...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙË```python
await some_runnable.ainvoke(some_input)
```

Other components like [Embedding Models](/docs/concepts/embedding_models) and [VectorStore](/docs/concepts/vectorstores) that do not implement th...¨metadata¦sourceÙD/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/async.mdx‚´page_content_summaryÙËThe result would be an `AIMessage` containing the model's response in natural language (e.g., "Hello!").
However, if we pass an input *relevant to the tool*, the model should choose to call it:

```py...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/tool_calling.mdx‚´page_content_summaryÙÍ## "Auto-Streaming" Chat Models

LangChain simplifies streaming from [chat models](/docs/concepts/chat_models) by automatically enabling streaming mode in certain cases, even when youâ€™re not explicitl...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/streaming.mdx¦answerÚ{The `invoke` method is synchronous, while `ainvoke` is its asynchronous counterpart, allowing for non-blocking execution. Both methods can trigger streaming mode in LangChain if the application is set to stream, but `ainvoke` enables the use of the `await` keyword for asynchronous operations. Essentially, use `invoke` for synchronous calls and `ainvoke` for asynchronous calls.¨query_id¤Q107ªfocus_kind¶chain_execution_result‹¢idÙ@7def257e757c4e8d9b3ddb49daae95463fcf64e95e7469292bb5c183c7ee6d0d¢tsËAÚó9}Ñt¨trace_id¤Q108­parent_run_idÀ¦run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?¨query_id¤Q108§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q108ªfocus_kind¯chain_execution‹¢idÙ@9141c50a028152c3762b5e98df5a690735659cfcb532265c894fa328a1e45dfd¢tsËAÚó9}Ş{¨trace_id¤Q108­parent_run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89¦run_idÙ$7b609e03-53ba-45bb-ac31-c12cdfd1a003ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context¦answer ¨query_id¤Q108¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q108®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:a6e8e674-68e8-9e8d-c9bf-70e06fb065cbªfocus_kind¯chain_execution‰¢idÙ@18cf91f07b7e0bf11a33231c4ada76b706fd6c962850c9a46ec548e6c935e70a¢tsËAÚó9‹±¨trace_idÙ$7b609e03-53ba-45bb-ac31-c12cdfd1a003­parent_run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89¦run_idÙ$7b609e03-53ba-45bb-ac31-c12cdfd1a003ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¨query_id¤Q108ªfocus_kind¶chain_execution_result‹¢idÙ@f56190a972bcdcd82fc2d6e35f594aa90af596c53b8c06019a42c06f229985d9¢tsËAÚó9‹ó¨trace_id¤Q108­parent_run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89¦run_idÙ$7fef0ead-29af-44f9-be20-8b9851bb1802ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answer ¨query_id¤Q108¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q108®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ddcb9a47-d223-b714-3801-be420fc1e953ªfocus_kind¯chain_execution‹¢idÙ@eabb8a59c082479885eb9b11a990f56f035246861212c7a1132d87ce56013e67¢tsËAÚó9‹"W¨trace_id¤Q108­parent_run_idÙ$7fef0ead-29af-44f9-be20-8b9851bb1802¦run_idÙ$cea93fae-1d8f-429a-bb50-b546041208ebªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§contextÚè<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.

Using these methods can significantly improve performance when needing to process multiple independent inputs, as the
processing can be done in parallel instead of sequentially.

The two batching options are:

* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.
* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.

The default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.

Some Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,
rely on a `batch` API provided by a model provider).

:::note
The async versions of `abatch` and `abatch_as_completed` relies on asyncio's [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.
:::

:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.

Chat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.
:::

### Asynchronous support
<span data-heading-keywords="async-api"></span>

Runnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).

Please refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.

## Streaming APIs
<span data-heading-keywords="streaming-api"></span>

## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.
* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.
* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.
* Inspected: Schematic information about Runnable's input, output, and configuration can be accessed.
* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.

Please review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.

<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.

### Setting max concurrency

If using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.


:::tip
If you're trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective.¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q108®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:ddcb9a47-d223-b714-3801-be420fc1e953­checkpoint_nsÙ-generate:ddcb9a47-d223-b714-3801-be420fc1e953¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@9a57a2f48287410ba581a19cebafeecddc4a0f6dcc1710cd3af5cc638a23b055¢tsËAÚó9‹(E¨trace_idÙ$cea93fae-1d8f-429a-bb50-b546041208eb­parent_run_idÙ$7fef0ead-29af-44f9-be20-8b9851bb1802¦run_idÙ$cea93fae-1d8f-429a-bb50-b546041208ebªevent_type¬chain_output¬event_source¥chain§payload§outputsÚßmessages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: What does `batch_as_completed` return with each result to help match inputs? \nContext: <a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\nLangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to process multiple inputs in parallel.\n\nUsing these methods can significantly improve performance when needing to process multiple independent inputs, as the\nprocessing can be done in parallel instead of sequentially.\n\nThe two batching options are:\n\n* `batch`: Process multiple inputs in parallel, returning results in the same order as the inputs.\n* `batch_as_completed`: Process multiple inputs in parallel, returning results as they complete. Results may arrive out of order, but each includes the input index for matching.\n\nThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for users to manage threads, and speeds up code that is I/O-bound (e.g., making API requests, reading files, etc.). It will not be as effective for CPU-bound operations, as the GIL (Global Interpreter Lock) in Python will prevent true parallel execution.\n\nSome Runnables may provide their own implementations of `batch` and `batch_as_completed` that are optimized for their specific use case (e.g.,\nrely on a `batch` API provided by a model provider).\n\n:::note\nThe async versions of `abatch` and `abatch_as_completed` relies on asyncio\'s [gather](https://docs.python.org/3/library/asyncio-task.html#asyncio.gather) and [as_completed](https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed) functions to run the `ainvoke` method in parallel.\n:::\n\n:::tip\nWhen processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency` attribute in the `RunnableConfig` dictionary. See the [RunnableConfig](/docs/concepts/runnables/#runnableconfig) for more information.\n\nChat Models also have a built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) that can be used to control the rate at which requests are made.\n:::\n\n### Asynchronous support\n<span data-heading-keywords="async-api"></span>\n\nRunnables expose an asynchronous API, allowing them to be called using the `await` syntax in Python. Asynchronous methods can be identified by the "a" prefix (e.g., `ainvoke`, `abatch`, `astream`, `abatch_as_completed`).\n\nPlease refer to the [Async Programming with LangChain](/docs/concepts/async) guide for more details.\n\n## Streaming APIs\n<span data-heading-keywords="streaming-api"></span>\n\n## Overview of runnable interface\n\nThe Runnable way defines a standard interface that allows a Runnable component to be:\n\n* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input is transformed into an output.\n* [Batched](/docs/how_to/lcel_cheatsheet/#batch-a-runnable): Multiple inputs are efficiently transformed into outputs.\n* [Streamed](/docs/how_to/lcel_cheatsheet/#stream-a-runnable): Outputs are streamed as they are produced.\n* Inspected: Schematic information about Runnable\'s input, output, and configuration can be accessed.\n* Composed: Multiple Runnables can be composed to work together using [the LangChain Expression Language (LCEL)](/docs/concepts/lcel) to create complex pipelines.\n\nPlease review the [LCEL Cheatsheet](/docs/how_to/lcel_cheatsheet) for some common patterns that involve the Runnable interface and LCEL expressions.\n\n<a id="batch"></a>\n### Optimized parallel execution (batch)\n<span data-heading-keywords="batch"></span>\n\n# Do something with the run_id\n```\n\n### Setting recursion limit\n\n:::note\nThis is an advanced feature that is unnecessary for most users.\n:::\n\nSome Runnables may return other Runnables, which can lead to infinite recursion if not handled properly. To prevent this, you can set a `recursion_limit` in the `RunnableConfig` dictionary. This will limit the number of times a Runnable can recurse.\n\n### Setting max concurrency\n\nIf using the `batch` or `batch_as_completed` methods, you can set the `max_concurrency` attribute in the `RunnableConfig` dictionary to control the maximum number of parallel calls to make. This can be useful when you want to limit the number of parallel calls to prevent overloading a server or API.\n\n\n:::tip\nIf you\'re trying to rate limit the number of requests made by a **Chat Model**, you can use the built-in [rate limiter](/docs/concepts/chat_models#rate-limiting) instead of setting `max_concurrency`, which will be more effective. \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@2a9eacdaccbca377b5c62b785df48780d8059a528a79333e3a134e872c7cd5f6¢tsËAÚó9Æ¯Ÿ¨focus_msÍ¡§payload‚¤role©assistant§contentÙü`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original inputs. This allows users to identify which input corresponds to each result, even if the results arrive out of order.ªfocus_kind¬exec_latency¨query_id¤Q108‰¢idÙ@15eac3768a8c9201f64d518206102b0d333e05a992b67106b2db3251f0c3eaef¢tsËAÚó9Æµû¨trace_idÙ$7fef0ead-29af-44f9-be20-8b9851bb1802­parent_run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89¦run_idÙ$7fef0ead-29af-44f9-be20-8b9851bb1802ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÙü`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original inputs. This allows users to identify which input corresponds to each result, even if the results arrive out of order.¨query_id¤Q108ªfocus_kind¶chain_execution_result‰¢idÙ@ad7163703ba60011eb6937f517142224d93f5ddc7b3b8340975d4725d0e77277¢tsËAÚó9Æºõ¨trace_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89­parent_run_idÀ¦run_idÙ$3cb4e864-4f91-416b-a900-849fa4b2bd89ªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙLWhat does `batch_as_completed` return with each result to help match inputs?§context•‚´page_content_summaryÙË<a id="batch"></a>
### Optimized parallel execution (batch)
<span data-heading-keywords="batch"></span>

LangChain Runnables offer a built-in `batch` (and `batch_as_completed`) API that allow you to p...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙËThe default implementation of `batch` and `batch_as_completed` use a thread pool executor to run the `invoke` method in parallel. This allows for efficient parallel execution without the need for user...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË:::tip
When processing a large number of inputs using `batch` or `batch_as_completed`, users may want to control the maximum number of parallel calls. This can be done by setting the `max_concurrency`...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË## Overview of runnable interface

The Runnable way defines a standard interface that allows a Runnable component to be:

* [Invoked](/docs/how_to/lcel_cheatsheet/#invoke-a-runnable): A single input i...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx‚´page_content_summaryÙË# Do something with the run_id
```

### Setting recursion limit

:::note
This is an advanced feature that is unnecessary for most users.
:::

Some Runnables may return other Runnables, which can lead ...¨metadata¦sourceÙH/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/runnables.mdx¦answerÙü`batch_as_completed` returns results as they complete, and each result includes the input index to help match it back to the original inputs. This allows users to identify which input corresponds to each result, even if the results arrive out of order.¨query_id¤Q108ªfocus_kind¶chain_execution_result‹¢idÙ@56a7b3a81500631e9e46897d16445ecb1a857faa0341c4b48666bf3852e34f7a¢tsËAÚó9ÆÀß¨trace_id¤Q109­parent_run_idÀ¦run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6dªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?¨query_id¤Q109§context¦answer ¯serialized_reprÀ¤tags¨metadata¨query_id¤Q109ªfocus_kind¯chain_execution‹¢idÙ@b7ddab0e4778ed135791df08a84f94b61f4b928cef1724457d86a31284f04fe4¢tsËAÚó9ÆÈ"¨trace_id¤Q109­parent_run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6d¦run_idÙ$09500d68-1689-4209-ba5b-f1cd385ceba7ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context¦answer ¨query_id¤Q109¯serialized_reprÀ¤tags‘¬graph:step:1¨metadata†¨query_id¤Q109®langgraph_step®langgraph_node¨retrieve²langgraph_triggers‘²branch:to:retrieve®langgraph_path’­__pregel_pull¨retrieve·langgraph_checkpoint_nsÙ-retrieve:0ce881fd-402c-80a7-821e-a1e9b0a6ea23ªfocus_kind¯chain_execution‰¢idÙ@461db59086d9df40d9f905debf1214239473308b5ab6558335ab618e9f9d0f40¢tsËAÚó9Ø¿'¨trace_idÙ$09500d68-1689-4209-ba5b-f1cd385ceba7­parent_run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6d¦run_idÙ$09500d68-1689-4209-ba5b-f1cd385ceba7ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¨query_id¤Q109ªfocus_kind¶chain_execution_result‹¢idÙ@4f61db7bdc0a9760abbd8c1983ee95b55ecfca33522082347317ba60bc2c388d¢tsËAÚó9ØÇô¨trace_id¤Q109­parent_run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6d¦run_idÙ$f50c514a-e381-498b-8437-b19391e69775ªevent_type«chain_start¬event_source­Unknown Chain§payload‚¦inputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answer ¨query_id¤Q109¯serialized_reprÀ¤tags‘¬graph:step:2¨metadata†¨query_id¤Q109®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f8f23917-c0f8-fcb0-bc1b-f4b5ab66efa6ªfocus_kind¯chain_execution‹¢idÙ@aea18b31d3d86793cd1eb878b3dec23048e9943f497543649a7a232c64f40f32¢tsËAÚó9ØÏ¨trace_id¤Q109­parent_run_idÙ$f50c514a-e381-498b-8437-b19391e69775¦run_idÙ$65b68519-e596-4c1d-816e-b888da43cac1ªevent_type«chain_start¬event_source²ChatPromptTemplate§payload‚¦inputs‚¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§contextÚHThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabItem value="chroma" label="Chroma" default>

This walkthrough uses the `chroma` vector database, which runs on your local machine as a library.

```bash
pip install langchain-chroma
```

```python
from langchain_chroma import Chroma

db = Chroma.from_documents(documents, OpenAIEmbeddings())
```

  </TabItem>
  <TabItem value="faiss" label="FAISS">

This walkthrough uses the `FAISS` vector database, which makes use of the Facebook AI Similarity Search (FAISS) library.

```bash
pip install faiss-cpu
```

```python
from langchain_community.vectorstores import FAISS

db = FAISS.from_documents(documents, OpenAIEmbeddings())
```

  </TabItem>
  <TabItem value="lance" label="Lance">

:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## Conclusion

LangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:
- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.
- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).

:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with embeddings.
* See Pinecone's [blog post](https://www.pinecone.io/learn/vector-similarity/) on similarity metrics.
* See OpenAI's [FAQ](https://platform.openai.com/docs/guides/embeddings/faq) on what similarity metric to use with OpenAI embeddings.

:::

### Similarity search

While algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.
As a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. 
At the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.

| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |
|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). |¯serialized_repr§summaryÚ Serialized object too long, starts with: {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'ChatPromptTemplate'], 'kwargs': {'input_variables': ['context', 'question'], 'metadata': {'lc_hub_owner': 'rlm', 'lc_hub_repo': 'rag-prompt', 'lc_hub_commit_hash': '50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6e'}, 'messages': [{'lc': 1, 'type': 'constructor', 'id': ['langchain', 'prompts', 'chat', 'HumanMessagePromptTemplate'], 'kwargs': {'prompt': {'lc': 1, 'type': 'constructor', 'id': ['langchain', 'pro...¤tags‘ªseq:step:1¨metadataŠ¨query_id¤Q109®langgraph_step®langgraph_node¨generate²langgraph_triggers‘²branch:to:generate®langgraph_path’­__pregel_pull¨generate·langgraph_checkpoint_nsÙ-generate:f8f23917-c0f8-fcb0-bc1b-f4b5ab66efa6­checkpoint_nsÙ-generate:f8f23917-c0f8-fcb0-bc1b-f4b5ab66efa6¬lc_hub_owner£rlm«lc_hub_repoªrag-prompt²lc_hub_commit_hashÙ@50442af133e61576e74536c6556cefe1fac147cad032f4377b60c436e6cdcb6eªfocus_kind¯chain_execution‰¢idÙ@61817ba9b79991ece94db0a2d20b479829279bb5ffb1872448953d7f7471b2b3¢tsËAÚó9ØÖ¨trace_idÙ$65b68519-e596-4c1d-816e-b888da43cac1­parent_run_idÙ$f50c514a-e381-498b-8437-b19391e69775¦run_idÙ$65b68519-e596-4c1d-816e-b888da43cac1ªevent_type¬chain_output¬event_source¥chain§payload§outputsÚ"messages=[HumanMessage(content='You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don\'t know the answer, just say that you don\'t know. Use three sentences maximum and keep the answer concise.\nQuestion: Why might you choose Chroma over FAISS for prototyping? \nContext: There are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.\n\n\n<Tabs>\n  <TabItem value="chroma" label="Chroma" default>\n\nThis walkthrough uses the `chroma` vector database, which runs on your local machine as a library.\n\n```bash\npip install langchain-chroma\n```\n\n```python\nfrom langchain_chroma import Chroma\n\ndb = Chroma.from_documents(documents, OpenAIEmbeddings())\n```\n\n  </TabItem>\n  <TabItem value="faiss" label="FAISS">\n\nThis walkthrough uses the `FAISS` vector database, which makes use of the Facebook AI Similarity Search (FAISS) library.\n\n```bash\npip install faiss-cpu\n```\n\n```python\nfrom langchain_community.vectorstores import FAISS\n\ndb = FAISS.from_documents(documents, OpenAIEmbeddings())\n```\n\n  </TabItem>\n  <TabItem value="lance" label="Lance">\n\n:::info[Further reading]\n\nSee our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.\n\n:::\n\n## Conclusion\n\nLangChain offers standard interfaces for components that are central to many AI applications, which offers a few specific advantages:\n- **Ease of swapping providers:** It allows you to swap out different component providers without having to change the underlying code.\n- **Advanced features:** It provides common methods for more advanced features, such as [streaming](/docs/concepts/streaming) and [tool calling](/docs/concepts/tool_calling/).\n\n:::info[Further reading]\n\n* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with embeddings.\n* See Pinecone\'s [blog post](https://www.pinecone.io/learn/vector-similarity/) on similarity metrics.\n* See OpenAI\'s [FAQ](https://platform.openai.com/docs/guides/embeddings/faq) on what similarity metric to use with OpenAI embeddings.\n\n:::\n\n### Similarity search\n\nWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.\nFor example, [maximal marginal relevance](https://python.langchain.com/v0.1/docs/modules/model_io/prompts/example_selectors/mmr/) is a re-ranking algorithm used to diversify search results, which is applied after the initial similarity search to ensure a more diverse set of results.\nAs a second example, some [vector stores](/docs/integrations/retrievers/pinecone_hybrid_search/) offer built-in [hybrid-search](https://docs.pinecone.io/guides/data/understanding-hybrid-search) to combine keyword and semantic similarity search, which marries the benefits of both approaches. \nAt the moment, there is no unified way to perform hybrid search using LangChain vectorstores, but it is generally exposed as a keyword argument that is passed in with `similarity_search`.\n\n| Name                                                                                                              | When to use                                           | Description                                                                                                                                  |\n|-------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| [Hybrid search](/docs/integrations/retrievers/pinecone_hybrid_search/)                                            | When combining keyword-based and semantic similarity. | Hybrid search combines keyword and semantic similarity, marrying the benefits of both approaches. [Paper](https://arxiv.org/abs/2210.11934). | \nAnswer:', additional_kwargs={}, response_metadata={})]ªfocus_kind¶chain_execution_result†¢idÙ@fcd21347c549abd1e565630e4f7e1ed9867643c4826a7b0dad16efc12996af5d¢tsËAÚó:;*¨focus_msÍ §payload‚¤role©assistant§contentÚoYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing of ideas.ªfocus_kind¬exec_latency¨query_id¤Q109‰¢idÙ@e9f5c12e85ffd9fcf4425f80f61282549d9b8a579211042e94b4f97f08dd1e19¢tsËAÚó:;6	¨trace_idÙ$f50c514a-e381-498b-8437-b19391e69775­parent_run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6d¦run_idÙ$f50c514a-e381-498b-8437-b19391e69775ªevent_type¬chain_output¬event_source¥chain§payload§outputs‚¦answerÚoYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing of ideas.¨query_id¤Q109ªfocus_kind¶chain_execution_result‰¢idÙ@9de4d5d4a66cd241dbd91474383910946c3fb10f284a8567f7c292454f9735c2¢tsËAÚó:;:É¨trace_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6d­parent_run_idÀ¦run_idÙ$319e85ac-00bf-4ea9-8cf2-0f512b54af6dªevent_type¬chain_output¬event_source¥chain§payload§outputs„¨questionÙ7Why might you choose Chroma over FAISS for prototyping?§context•‚´page_content_summaryÙËThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.


<Tabs>
  <TabIt...¨metadata¦sourceÙI/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/how_to/vectorstores.mdx‚´page_content_summaryÙË:::info[Further reading]

See our video playlist on [LangSmith tracing and evaluations](https://youtube.com/playlist?list=PLfaIDFEXuae0um8Fj0V4dHG37fGFU8Q5S&feature=shared) for more details.

:::

## ...¨metadata¦sourceÙL/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/why_langchain.mdx‚´page_content_summaryÙË:::info[Further reading]

* See [this documentation](https://developers.google.com/machine-learning/clustering/dnn-clustering/supervised-similarity) from Google on similarity metrics to consider with ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙËWhile algorithms like HNSW provide the foundation for efficient similarity search in many cases, additional techniques can be employed to improve search quality and diversity.
For example, [maximal ma...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx‚´page_content_summaryÙË| Name                                                                                                              | When to use                                           | Description               ...¨metadata¦sourceÙK/Users/manirashahmadi/ccode/aep/aep-sdk/docs/docs/concepts/vectorstores.mdx¦answerÚoYou might choose Chroma over FAISS for prototyping because Chroma runs entirely on your local machine as a library, making it easier to set up and use without external dependencies. Additionally, it offers a straightforward integration with LangChain, allowing for quick experimentation. This can be particularly beneficial for rapid development and testing of ideas.¨query_id¤Q109ªfocus_kind¶chain_execution_result